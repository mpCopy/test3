#!/hped/builds/bin/perl -w

#---------------------------------------------------------------------------
#  Description:  This script gets a master xml file called MASTER_DOC.xml
#                It extracts name and description fields for components, 
#                parameters, ports of all the xml files generated by ptlang
#                in the directory it receives as its argument. Then it extracts
#                the name and description of components which are instantiated
#                from other component and add this info to the master file.
#              
#                To run this script you need perl 5 to use XML::Parser.
#                
#                
#  Usage:        eesofchangedoc numeric_MASTER_DOC.xml
#  Author:       Parvin Babaeian    
#  Created:      March 16,2000
#-------------------------------------------------------------------------

use XML::Parser;

my $content = "";
my $pl_file = "";
my $RefTag = "";
my $temp_pl = "";
my $name = "";
my $component_name = "";
my $derivedfrom = "";
my $inst_file = "";
my $line_num = 0;
my $domain_line_num = 0;
my $type_line_num = 0;
my $FOUND = "FALSE";
my $DONE = "FALSE";
my $new_master = "new_master.xml";
my $CHANGE_COUNT = 0;                           
my $ERROR_COUNT = 0;
my $CURRENT_CHANGE_COUNT = 0;                           
my $CURRENT_ERROR_COUNT = 0;
my $off_set = 0;
my $master_file = $ARGV[0];
my $submiter = $ARGV[1];
#$master_file =~ s/*_//;     #strip off the pid number 

correct_pl_format ("$master_file");
if ( $FOUND eq "TRUE" ) {
   die ("error: Your file $master_file contains forbidden items { } < > & or has odd number of \" \n");
}
$temp_master = $master_file;
$temp_master  =~ s/[^_]*_//;     #strip off the pid number 

my $old_master_file = "/hped/builds/wlv/dev150/rday/opt/include/hptolemy/include/hptolemy/doc/$temp_master";

#my $submiter = "testing";
#my $old_master_file = "rootdev/include/hptolemy/doc/$master_file";
#print "old_master_file: $old_master_file\n";


#sorting master_file and put it into new_master
sort_master();
print "\n REMINDER: To update the description for parameter or port which has been inherited from parent component, you need to change the desc. in parent component!!!.\n ";
my $p = new XML::Parser(ErrorContext  => 2,
			Namespaces    => 1,
			ParseParamEnt => 1,
			Handlers      => {Start => \&sthndl,
					  End   => \&endhndl,
					  Char  => \&chrhndl
					 }
			);
$p->parsefile($new_master);
print "Number of update success: $CHANGE_COUNT\n
       Number of Errors: $ERROR_COUNT\n";
if ( $ERROR_COUNT == 0 ) {
     print "success\n";
     
   }
else {
     print "Number of update success: $CHANGE_COUNT  Number of Errors: $ERROR_COUNT\n";
 }

#--------------------------------------------------------------------------
#    correct_pl_format
#    Parameters: $file
#    Set passed variable to FALSE if the file contains forbidden item { } 
#    odd number of "
#--------------------------------------------------------------------------
sub correct_pl_format {
  my $master_xml = shift;
  my $ptr = new XML::Parser(ErrorContext  => 2,
			Namespaces    => 1,
			ParseParamEnt => 1,
			Handlers      => {
                      End   => \&check_endhndl,
					  Char  => \&check_chrhndl
					 }
			);
$ptr->parsefile($master_xml);

}
#--------------------------
#    check-endhndl
#--------------------------
sub check_endhndl {
  my ($xp, $el) = @_;
    if ($el eq "DESCRIPTION") {
 
       @chars = split //, $content;
       $count = 0;
       for $char (@chars) {
          if ( $char eq "\"" ) {
             ++$count;
	      }
          elsif ( ($content =~ m/\{/) || ($content =~ m/\}/) ) {
             $FOUND = "TRUE";
          }
       }
       if ( $count % 2 != 0 ) {
            $FOUND = "TRUE";
	   }
    }
    $content = "";
}
#--------------------------
#    check_chrhndl
#--------------------------
sub check_chrhndl {
  my ($xp, $data) = @_;
  $content = $content. $xp->xml_escape($data, '>');
 
} 

#--------------------------------------------------------------------------
#    sort_master
#    Parameters: None
#    Sorts the master_file by re arranging the parameters and ports according 
#    to their line number.
#--------------------------------------------------------------------------
sub sort_master {
 #  print "in sort_master\n";
   my %hash = ();
   my $s = "";
   my $flag = "FALSE";
   open (FP , $master_file) || die ("Cannot open $master_file\n");
   open (NFP , ">$new_master") || die ("Cannot open $new_master\n");
   while (<FP>) {
     if ( /<FILE>/ ) {
        print NFP "$_";
        $flag = "TRUE";
        $s = "";
	 }
     elsif ( /<PARAMETER>/ || /<INPUT>/ || /<OUTPUT>/ ) {
        $hash{$num} = "$s";
       # print "key: $num value: **$hash{$num}**\n";
        $s = "$_"; 
	 }
      elsif ( /<\/COMPONENT>/ ) {
        # add the last item
        $hash{$num} = "$s";
        #print "last key: $num value: **$hash{$num}**\n"; 
	    for $k ( sort { $b <=> $a } keys  %hash ) {
		   if ( $k ne "" ) {
              print NFP "$hash{$k}";
             # print "**$k**$hash{$k}***\n";
			}
	    }
        print NFP "$_";
        %hash = ();
        $flag = "FALSE";
	  }
     elsif ($flag eq "TRUE" ) {
        $s = $s ."$_";
        if (/<TYPE_LINE_NUM>/ || /<LINE_NUM>/ || /<DOMAIN_LINE_NUM>/ ) {
          # print "##$_\n";
           $num = $_;
           $num =~ s/[^>].*>([^<]*)<.*\n/$1/;
           # print "##$num\n";
	    }
     }
    
     else {
        
        print NFP "$_";
	  }
      
   }
   close (FP);
   close (NFP);
}
#--------------------------
#    sthndl
#--------------------------
sub sthndl {
  my $xp = shift;
  my $el = shift; 
  if ( $el eq "COMPONENT" ) {
       $RefTag = "COMPONENT";
       $derivedfrom = "";
       $inst_file = "";
       $CURRENT_ERROR_COUNT = $ERROR_COUNT;
       $CURRENT_CHANGE_COUNT = $CHANGE_COUNT;
      # print "start: CURRENT_ERROR_COUNT=$CURRENT_ERROR_COUNT CURRENT_CHANGE_COUNT=$CURRENT_CHANGE_COUNT\n";
     #  print " RefTag = $RefTag	\n";
  }  
  elsif ( $el eq "PARAMETER" ) {
       $RefTag = "PARAMETER";
      # print " RefTag = $RefTag	\n";
  } 
  elsif ( $el eq "INPUT" ||  $el eq "OUTPUT" ) {
       $RefTag = "PORT";
      # print " RefTag = $RefTag	\n";
    
  } 
}  # End sthndl
#--------------------------
#    enhndl
#--------------------------
sub endhndl {
  my ($xp, $el) = @_;
  my $old_desc = "";
  my $FLAG = "FALSE";
  $content =~ s/^\s*//g;     $content =~ s/\s*$//g;      
  $content =~ s/^\n//g;       $content =~ s/\n*$//g;
  
  if ( $el eq "INPUT" ||  $el eq "OUTPUT" || $el eq "PARAMETER" ) {
      $RefTag = "COMPONENT";
      $name = "";
     # print " RefTag = $RefTag	\n";
  } 
  elsif ($el eq "FILE" ) {
	if ( $inst_file ne "" ) {
        $inst_file = $content; 
       # print "in FILE inst: $inst_file\n";
	 }
  }
  elsif ( $el eq "NAME" && $RefTag eq "COMPONENT" ) {
      print "checking component: $content\n";
      $component_name = $content;
      $name = "";
  } 
  elsif ($el eq "NAME" && ( $RefTag eq "PARAMETER" || $RefTag eq "PORT" ) ) {
      $name = $content;
  } 
   elsif ($el eq "DERIVED_FROM" ) {
      $derivedfrom = $content;
  } 
  elsif ($el eq "INSTANTIATE_FROM" ) {
      $inst_file = $content;
      print "inst: $inst_file\n";
  }
  elsif ($el eq "COMPONENT" ) {
	if ( ($CURRENT_CHANGE_COUNT != $CHANGE_COUNT) && ($CURRENT_ERROR_COUNT == $ERROR_COUNT) ) {
       $cmd = "/hped/builds/bin/cvs commit -m \"auto_doc_generation: $submiter\" $pl_file";
       system ($cmd);
     #  print "file $pl_file has been checked into cvs\n";
      # print "end of $component_name: $CHANGE_COUNT  $CURRENT_CHANGE_COUNT\n";
	 }
 }
  elsif ( $el eq "DESCRIPTION" && $RefTag eq "COMPONENT" && $inst_file ne "" ) {
      # print "*$inst_file*$component_name*$content*\n";
       update_instantiate_file ($inst_file, $component_name, $content);      
       $inst_file = "";

  }
  elsif ( $el eq "DESCRIPTION" &&  $inst_file eq "" ) {
     $line_num = 0;
     $domain_line_num = 0;
     $type_line_num = 0;
  
    $old_desc = &extract_desc ($old_master_file, $component_name, $RefTag, $name);
    if ( "$content" ne "$old_desc" ) {
        print "\n\nold_desc: *$old_desc*\nnew_desc: *$content*\n";
        if ( $line_num == 0 ) {
		    if ( $RefTag eq "COMPONENT" ) {
                $DONE = &insert_desc ($pl_file, $RefTag, $domain_line_num, $content);
               # print "insert before domain: $DONE\n";
			}
            else {
                $DONE = &insert_desc ($pl_file, $RefTag, $type_line_num, $content);
               # print "insert before type: $DONE\n";
			} 

            if ( $DONE eq "TRUE" ) {
                ++$CHANGE_COUNT;
                print "CHANGE #$CHANGE_COUNT\n";
                print "added the description for $RefTag: $name  in $pl_file\n";
                print "---------------------------------------------\n";
            }
            else {
                ++$ERROR_COUNT; 
                print "ERROR #$ERROR_COUNT\n";
                print "Error: Couldn't add the description for $RefTag: $name in $pl_file\n\n";
                print "********************************************\n";
			}
        }      
	    else { 
            # print "before change:file: $pl_file**$line_num**$content**\n";
             $DONE = &change_desc ($pl_file, $line_num, $content); 
            # print "change flag: $DONE\n";
	          if ( $DONE eq "TRUE" ) {
                  ++$CHANGE_COUNT;
                  print "CHANGE #$CHANGE_COUNT\n";
                  print "changed the description for $RefTag: $name in $pl_file\n";
                 print "--------------------------------------------\n";
                  
              }
              else {
                  ++$ERROR_COUNT; 
                  print "ERROR #$ERROR_COUNT\n";
                  print "Error: changing the  description for $RefTag: $name in $pl_file\n";    
                  print "********************************************\n";
                  
             }   
        } 
	  }
  }  
  $content = "";
}  # End endhndl

#--------------------------
#    chrhndl
#--------------------------
sub chrhndl {
  my ($xp, $data) = @_;
  $content = $content. $xp->xml_escape($data, '>');
}  # End chrhndl

#------------------------------------------------------------------
#    extract_desc
#    Parameters: $file , $RefTag, $name
#    Rturns the line # and desc; 0 otherwise
#-----------------------------------------------------------------
sub extract_desc {
  local ($old_file, $comp_name, $tag, $n)= @_;
  local $old_name = "";
  local $old_component_name = "";
  local $old_tag = "";
  local $desc = "";
  local $second_content = "";
  local $flag = "FALSE";
 # print "in extract:  $old_file $component_name $tag $name \n";
  my $ptr = new XML::Parser(ErrorContext  => 2,
			Namespaces    => 1,
			ParseParamEnt => 1,
			Handlers      => {Start => \&second_sthndl,
					  End   => \&second_enhndl,
					  Char  => \&second_chrhndl
					 }
			);

   $ptr->parsefile($old_file);
  if ( $flag eq "TRUE") {
     return ($desc);
   }
  else {
     return (NULL);
   }
}
#--------------------------
#     second_sthndl
#--------------------------
sub  second_sthndl {
  my $xp = shift;
  my $el = shift; 
  if ( $el eq "COMPONENT" ) {
       $old_tag = "COMPONENT";
       $derivedfrom = "";
       $inst_file = "";
     #  print "%%$old_tag%%$tag%%\n";
  }  
  elsif ( $el eq "PARAMETER" ) {
       $old_tag = "PARAMETER";
      # print " 	\n";
  } 
  elsif ( $el eq "INPUT" ||  $el eq "OUTPUT" ) {
       $old_tag = "PORT";
    
    
  } 
}  # End sthndl
#--------------------------
#    second_enhndl
#--------------------------
sub second_enhndl {
   my $xp = shift;
   my $el = shift;
  
   $second_content =~ s/^\s*//g;     $second_content =~ s/\s*$//g;      
   $second_content =~ s/^\n//g;       $second_content =~ s/\n*$//g;

   if ($el eq "FILE" && $comp_name eq $old_component_name )   {
       $pl_file = $second_content;
       $temp_pl = $second_content;
       $temp_pl =~ s/\.pl$/\.temp/;
     #  print "in FILE pl_file: $pl_file $temp_pl\n";

   }
   elsif ($el eq "NAME" && $old_tag eq "COMPONENT" ) {
      $old_component_name = $second_content;
    #  print "old_component_name = $old_component_name\n";
      $old_name = "";
  } 
  elsif ( $el eq "NAME" && ( $old_tag eq "PARAMETER" || $old_tag eq "PORT") ) {
      $old_name = $second_content;
    #  print "old_name = $old_name\n";
  }

   elsif ( $el eq "LINE_NUM" && $old_tag eq $tag && $comp_name eq $old_component_name && $n eq $old_name ) {
      $line_num = $second_content;
  } 
  elsif ( $el eq "DOMAIN_LINE_NUM" && $old_tag eq $tag && $comp_name eq $old_component_name ) {
      $domain_line_num = $second_content;
  }
   elsif ( $el eq "TYPE_LINE_NUM" && $old_tag eq $tag && $comp_name eq $old_component_name && $n eq $old_name ) {
      $type_line_num = $second_content;
  }
  elsif ( $el eq "DESCRIPTION" && $old_tag eq $tag && $comp_name eq $old_component_name && $n eq $old_name ) {
   #  print "in elsif DESC: **$second_content**\n";
     $flag = "TRUE";
     $desc = $second_content;     
  }
  
  $second_content = "";
} # end secone_enhdel
#--------------------------
#    second_chrhndl
#--------------------------
sub second_chrhndl {
  my ($xp, $data) = @_;
  $second_content = $second_content. $xp->xml_escape($data, '>');
}  # End second_chrhndl


#------------------------------------------------------------------
#    insert_desc
#    Parameters: $file , $RefTag, $name, $desc
#    Insert the description into a pl file.
#-----------------------------------------------------------------
sub insert_desc {
  # print "in insert_desc:\n";
   my ($file , $tag, $line_count, $desc)= @_;
   my $count = 1;
   my $found = "FALSE";

   #convert the tags 
   $desc =~ s/&amp;/&/g;
   $desc =~ s/&lt;/</g;      
   $desc =~ s/&gt;/>/g;

   if ( $tag eq "COMPONENT" ) {
       $keyword = "domain";
	 } 
   else {
       $keyword = "type";
	 }
  # print "$file  $tag $line_count $desc\n";
   open (PLFP, $file) || die ("Cannot open $file\n");
   open (TMPFP, ">$temp_pl") || die ("Cannot open $temp_pl\n");
   while (<PLFP>) {
   	 if ( $count == $line_count ) {
           # print "in if $line_count:$_\n";
            
           if ( /^\s*$keyword/ ) {
             #  print "in if $keyword:$_\n";
               $new_desc = $_;        #keep the indentation 
               $new_desc =~ s/$keyword.*/desc \{ $desc }/;    
               $new_desc = $new_desc . "$_";
             #  print "in insert, new description:$new_desc\n";
               print TMPFP $new_desc;
               $found = "TRUE";    
           }
           else {
              close (PLFP);
              close (TEMPFP);
              return ($found);
			}
           ++$count;
       }
       else {
           ++$count;
           print TMPFP "$_";
	   }
   }  # while
   close (PLFP);
   close (TEMPFP);
   rename $temp_pl, $file;
   return ($found);
 }

#------------------------------------------------------------------
#    change_desc
#    Parameters: $file , $line_num, $desc
#    Changes the description located from $line_num in pl file.
#-----------------------------------------------------------------
sub change_desc {
  my ($file, $line_count, $desc)= @_;
 # print "in change_desc:\n";
  my $old_desc = "";
  my $count = 1;
  my $done = "FALSE";


   #convert the tags 
   $desc =~ s/&amp;/&/g;
   $desc =~ s/&lt;/</g;      
   $desc =~ s/&gt;/>/g;

  open (PLFP, $file) || die ("Cannot open $file\n");
  open (TMPFP, ">$temp_pl") || die ("Cannot open $temp_pl\n");
  while (<PLFP>) {
    if ( $count == $line_count ) {
      #  print "in if $line_count:$_\n";
            
        if ( /^\s*desc/ || /^\s*descriptor/) {
          #  print "in if $keyword:$_\n";
            if (/\}/) {
                $old_desc = $_;
                # print "*old_desc: $temp_pl\n";
	        }
            else {
                $old_desc = $_;
	            while (<PLFP>) {
                    if (/\}/) {
                      #  print "at second while: $old_desc\n";
                        $old_desc .= $_;
                        last;
		            }
                    else {
                        $old_desc .= $_;
	   	            }
				}  #end second while
			  }
             # keep the indentaion of old description
             $new_desc = $old_desc;
             $new_desc =~ s/\{[^\}]*\}/\{ $desc \}/;
             print TMPFP "$new_desc";
            # print "new desc after change: $new_desc\n";
             $done = "TRUE";
             ++$count;
         } # if keyword
         else {
              close (PLFP);
              close (TEMPFP);
              return ($done);
		 }
	  }
      else {
       ++$count;
       print TMPFP "$_";
	 }
  }  # end first while

  close (PLFP);
  close (TMPFP);
  rename $temp_pl, $file;  
  return ($done); 
}
#------------------------------------------------------------------
#    update_instantiate_file
#    Parameters: $name, $content
#    updates the instantiate file if needed.
#-----------------------------------------------------------------
sub update_instantiate_file {
   print "in update_instantiate_file\n";
   my ($file, $name, $desc) = @_;
   print "file: $file name: $name desc: $desc\n";
   my $new_file = $file;
   $new_file .= "new";
   my $line = `grep "\t$name\t" $file`;
   print "**$line**\n";
   if ( $line eq "" ) {
       ++$ERROR_COUNT;
       print "ERROR #$ERROR_COUNT\n";
       print "Error: Couldn't change the description for $RefTag: $name in file: $file\n";
       print "********************************************\n";
   }
   else { 
    #  print "in else: %$desc%\n";
     # print "$line\n";
      my @fields = split /\t+/, $line;
      $fields[4] =~ s/\n//;     $fields[4] =~ s/"//g;
     # print "**$fields[4]**$desc**\n";
      if ( $fields[4] ne $desc ) {
          open (IFP, $file) || die ("Cannot open file: $file.\n");
          open (NFP, ">$new_file") || die ("Cannot open file: $new_file.\n");
          while (<IFP>) {
              if ( $_ eq $line ) {
                  $new_line = $_;
                 # print "#$desc#\n";
                  $new_line =~ s/"[^"]*"$/"$desc"/;
                #  print "##$new_line##\n";
                  print NFP "$new_line\n";
                 
     	      }
              else {
                  print NFP "$_";
		      }
		  }
          close (IFP);
          close (NFP);
          rename $new_file, $file; 
          ++$CHANGE_COUNT;
          print "CHANGE #$CHANGE_COUNT\n";
          print "changed the description for $RefTag: $name  in $file\n";                print "---------------------------------------------\n";
	  }
   }
 }
