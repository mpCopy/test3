#!/hped/builds/bin/perl -w
#---------------------------------------------------------------------------
#  Description:  This script generates a master xml file called MASTER_DOC.xml
#                It extracts name and description fields for components, 
#                parameters, ports of all the xml files generated by ptlang
#                in the directory it recieves as its argument. Then it extracts
#                the name and description of components which are instantiated
#                from other component and add this info to the master file.
#              
#                To run this script you need a tamplet file (tamplet.htm)
#                and perl 5 to be able to use XML::Parser.
#                
#                
#  Usage:        eesofmastergen sdfstarsIndex
#  Author:       Parvin Babaeian    
#  Created:      March 16,2000
#-------------------------------------------------------------------------

use XML::Parser;

my $content = "";
my @xml_files = ();
my @inst_files = ();
my $ab = "";
my $bb = "";
my $instantiate_file = "instantiate";  # file with instantiation info
my $package_name = $ARGV[0];
my $install_root = $ARGV[1];
my $master_file = "$install_root/doc/$package_name" . "_MASTER_DOC.xml";

#get the xml files generated by ptlang only
get_xml_files();
#print "**@xml_files**\n";
 # sorting the files according to the file name
   @xml_files = sort { 
       ($ab) = ($a =~ m,.*/([^/]*)$,);
       ($bb) = ($b =~ m,.*/([^/]*)$,);
       $ab cmp $bb;
   } @xml_files;
#print "@xml_files\n";
if ( $#xml_files != -1 ) {
   open (MFP, ">$master_file") || die ("Cannot open file: $master_file.\n");
   $date =localtime (time);
   print MFP "<?xml version=\"1.0\"?>\n<!-- xml file generated by make createmaster at $date. -->\n<COMPONENTS>\n";

   for $xml_file (@xml_files) {
       if ( $xml_file ne "" ) {
           $xml_file =~ s/\n//;
           if (! -e "$xml_file" ) { print "Can't find file \"$xml_file\".\n" }
           else {
                extract_doc ($xml_file);
           }
       }
    }

    @inst_files = `find . -name $instantiate_file`; 

    print "**@inst_files\n";
    for $inst_file (@inst_files) {
    $inst_file =~ s/\n//;
    if ( -e $inst_file ) {
        extract_instance ($inst_file);
    }
  }
  print MFP "\n</COMPONENTS>\n";
  close (MFP);
  print "File: $master_file has been created...\n";  
}     
#--------------------------------------------------------------------------
#    get_xml_files
#    Parameters: $DIR
#    Extract list of xml files generated only by ptlang 
#--------------------------------------------------------------------------
sub get_xml_files {
   my @all_xml_files = "";
   
   @all_xml_files = `find . -name "*.xml"`; 
  
   foreach $f (@all_xml_files){

    #ignore the comp. with NI in their name in controls-displays package
    #no doc for these comp
    if ( ( $package_name eq "controls-displays" ) && ( $f =~ m/NI.pl.xml/ ) ) {
         print "ignored: $f";
     }
     else {
        open (FP, $f) || die ("Couldn't open file: $f.\n");
        while (<FP>) {
           if ( /<!\-\- xml file generated from .* by ptlang \-\->/) { 
              push @xml_files, $f;
              last;
	       }
        }
        close(FP);
	  }
   }
#  print "@xml_files\n";  
}  # get_xml_files 

#--------------------------------------------------------------------------
#    extract_doc
#    Parameters: $xml_file
#    Extract fields to be updated by learning product.
#--------------------------------------------------------------------------
sub extract_doc {
   my $file = shift;
 #  print "##$file##\n";
   my $file_name = $file;
      $file_name =~ s/.*\/([^\/]*)/$1/;
      local $path = $file;
      $path =~ s/$file_name//; 
  print "extracting information from: $xml_file\n";
   my $p = new XML::Parser(ErrorContext  => 2,
			Namespaces    => 1,
			ParseParamEnt => 1,
			Handlers      => {Start => \&sthndl,
					  End   => \&endhndl,
					  Char  => \&chrhndl
					 }
			);
$p->parsefile($file);
}

#--------------------------
#    sthndl
#--------------------------
sub sthndl {
  my $xp = shift;
  my $el = shift; 
  if ( $el eq "COMPONENT" ) {
      print MFP "   <$el>\n";	
  }  
  elsif (  $el eq "PARAMETER" || $el eq "INPUT" || $el eq "OUTPUT" || $el eq "INMULTI" || $el eq "OUTMULTI" ) {
      print MFP "     <$el>\n";	
  }
}  # End sthndl
#--------------------------
#    enhndl
#--------------------------
sub endhndl { 
  my ($xp, $el) = @_;
  $content =~ s/^\s*//g;          
  $content =~ s/\n//g;
  if ($el eq "COMPONENT" ) {
     print MFP "   </$el>\n\n";	
  }
  elsif ( $el eq "NAME" ||  $el eq "DERIVED_FROM") {
      print MFP "        <$el>$content</$el>\n";	
  }
  elsif ( $el eq "PARAMETER" || $el eq "INPUT" || $el eq "OUTPUT" || $el eq "INMULTI" || $el eq "OUTMULTI" ) {
      print MFP "     </$el>\n";	
  }
  elsif ($el eq "CLASS") {
     my $f = $path . $content .".pl";
     print MFP "        <FILE>$f</FILE>\n";
   }
  elsif ( $el eq "DESCRIPTION" || $el eq "LINE_NUM" || $el eq "DOMAIN_LINE_NUM" || $el eq "TYPE_LINE_NUM" ) {
      print MFP "        <$el>$content</$el>\n";	
  }
  $content = "";
}  # End endhndl
#--------------------------
#    chrhndl
#--------------------------
sub chrhndl {
  my ($xp, $data) = @_;
  $content = $content. $xp->xml_escape($data, '>');
}  # End chrhndl

#--------------------------------------------------------------------------
#    extract_instance
#    Parameters: $instantiate_file
#    Extract instantiates information and added to master_xml file
#--------------------------------------------------------------------------
sub extract_instance {
  my $instantiate_file = shift;
  my $flag = "FALSE";
  open (IFP, $instantiate_file) || die ("Cannot open file: $instantiate_file.\n");
  while (<IFP>) {
	if ( $flag eq "TRUE" && /^[^#].*/ && not /^\n$/){
      # print $_;
       @fields = split /\t+/, $_;
      print MFP "   <COMPONENT>\n      <NAME>$fields[1]</NAME>\n";
      $fields[2] =~ s/\..*//;
      print MFP "      <INSTANTIATE_FROM>$fields[2]</INSTANTIATE_FROM>\n";
      print MFP "      <FILE>$instantiate_file</FILE>\n";
     
      $fields[4] =~ s/\n//;     $fields[4] =~ s/"//g;
      print MFP "      <DESCRIPTION>$fields[4]</DESCRIPTION>\n   </COMPONENT>\n\n";

    }
    elsif (/#Domain/) {
       $flag = "TRUE";
    }
  }
 close (IFP);
}
