#!/hped/builds/bin/perl -w
#---------------------------------------------------------------------------
#  Description:  This script generates one htm file for each xml file listed
#                in the index file given as its argument. It also creates 
#                one index file for each library that contains a list of
#                component(s) which their xml file is being documented and
#                they're belong to this library.
#                 
#                To run this script you need a template file (template.htm)
#                and perl 5 to be able to use XML::Parser.
#                
#                
#  Usage:        eesofdocgen sdfstarsIndex
#  Author:       Parvin Babaeian    
#  Created:      Feb 3,2000
#-------------------------------------------------------------------------

use XML::Parser;
use Getopt::Long;
use File::Copy;

my $DEBUG = "FALSE";       # print debugging statement if this set to TRUE
my $compsp_list="numeric timed hof instruments antennas-prop matrix controls-displays fixpt-analysis hptolemy-kernel sdfhdlcosim ticcscosim vsa89600 ptolemyapi veelink";             # list of libraries that doc files are under compsp

GetOptions(\%optctl, "lpdir=s") || die "bad usage!";
my $LP_DIR = $optctl{lpdir};
#my $LP_DIR = "/users/pbabaeia/hptolemy";
#print "lp_dir: $LP_DIR\n";
#my $LP_DIR = "/users/pbabaeia/hptolemy/src/lp-to-xml/rootdev/include/hptolemy/doc/temp_html";
my $DOC_DIR = $LP_DIR;    # can be set to LP_DIR or LOCAL_DIR
my $LOCAL_DIR = "html";    #dir contain files needed for display doc if lp files are missing.
my $star_mk = $ARGV[0];       $star_mk =~ s/Index//;
my $install_root = $ARGV[1];

my $prod_name = $ARGV[2];
my $COMPS_INDEX = "$star_mk.idx";  # an index file with information about each component in a form of (component_name location domain)
my $TMP_htm = "$ENV{project_mk_dir}/lib/docgen/template.htm";  # template file
my $component_name = "";
my $base = "$install_root/doc/compsp";
my $search = "$install_root/doc/search";
my $index_dir = "$base/index";
#my $new_html_file = "";  # to pre append the class name to html file name.
my $RefEndTable = "FALSE"; # sets to true if we need to insert </TABLE>
my $html_file = "";
my $xml_files = "";
my $lp_html = "";           # holds the html file generated by learning product ,or the file under htm dir
my $unit_flag = "FALSE";    # sets to true if there is a unit for a parameter
my %list = ();
my @intro_list = "";         #list of starting name for library Introduction files
my @intro_files = "";        #list of all intro files
my @intro_gif_files = "";    #list of all intro gif files

# if developer creats html dir get the doc file from there
if ( -d $LOCAL_DIR ) {
    $DOC_DIR = $LOCAL_DIR;
     print "doc_dir: $DOC_DIR\n";
}
unless (-d "$base/index") {
    `mkdir -p "$base/index"`;
}
## added the hierarchy structure under doc/compsp ###
if ( $compsp_list =~ m/$prod_name/ ) { $prod_name_doc = "compsp" }
else { $prod_name_doc = $prod_name }
$DOC_DIR .= "/$prod_name_doc";
$base  .= "/$prod_name_doc";

unless (-d "$base/images") {
    `mkdir -p "$base/images"`;
}


if ( -d  $DOC_DIR ) {
 ## copy the search files only for addons (compsp search is done under hptolemy-kernel/make-defs)
  if ( not  $compsp_list =~ m/$prod_name/ ) {
	 if ( ( -d "$DOC_DIR/../search/$prod_name_doc") && ( not -e "$search/$prod_name_doc" )) {
       $cmd = "mkdir -p $search/$prod_name_doc";
       system($cmd) && print "Error: Cannot create $search directory\n";
       $cmd = "cp $DOC_DIR/../search/$prod_name_doc/* $search/$prod_name_doc";
       system($cmd) && print "Error: The search file for doc does not exist\n";
	 }
  } 
  ##set the library name to its corresponding name from learning product###
  #print "prod_name: $prod_name\n";
  SWITCH: {
    if ( $prod_name eq "numeric" )
         { @intro_list = ("Numeric", "Sinks", "Signal_Converters"); last SWITCH; }
    if ( $prod_name eq "antennas-prop" )
         { @intro_list = ("Antennas_Propagation", "Circuit_Cosimulation");   last SWITCH; }
    if ( $prod_name eq "cdma2k" ) 
         { @intro_list = ("cdma2000"); last SWITCH; }
    if ( $prod_name eq "wcdma3g" ) 
         { @intro_list = ("3GPPFDD"); last SWITCH; }
    if ( $prod_name eq "wcdma" ) 
         { @intro_list = ("W-CDMA"); last SWITCH; }
    if ( $prod_name eq "1xev" ) 
         { @intro_list = ("1xEV"); last SWITCH; }
    if ( $prod_name eq "timed" || $prod_name eq "instruments" )
         { $prod_name = ucfirst($prod_name); @intro_list = ("$prod_name"); last   SWITCH; }
     else {  $prod_name = uc($prod_name); @intro_list = ("$prod_name"); }
  }
  ##get the Introduction files
  opendir (SUBDIR, $DOC_DIR) || die "Cannot open $DOC_DIR\n";
  @intro_files = grep ( ( /^Int_/ || /^Exp_/ ), readdir(SUBDIR));
  closedir(SUBDIR);
  opendir (SUBDIR, "$DOC_DIR/images") || die "Cannot open $DOC_DIR/images\n";
  @intro_gif_files = grep ( ( /^Int_/ || /^Exp_/ ), readdir(SUBDIR)); 
  closedir(SUBDIR);

  for $n ( @intro_list ) {
     for $f ( @intro_files ) {
        $match1 = "Int_" . $n;
        $match2 = "Int_" . $n . ",_";
        $match3 = "Int_" . $n . "_";
        $match4 = "Exp_" . $n;
        $match5 = "Exp_" . $n . "_";
        $match6 = "Exp_" . $n . ",_";
       # print "**$f**$match1**$match2**\n";
        if ( $f =~ m/^$match1\./ || $f =~ m/^$match2/ || $f =~ m/^$match3/ || $f =~ m/^$match4\./ || $f =~ m/^$match5/ || $f =~ m/^$match6/ ) {
		   if ( not -e "$base/$f" ) {
               copy ("$DOC_DIR/$f", "$base/$f");
               print "$DOC_DIR/$f copied to $base/$f\n";
		    }
        }
	}
    for $f ( @intro_gif_files ) {
        if ( $f =~ m/^$match1\./ || $f =~ m/^$match2/ || $f =~ m/^$match3/ || $f =~ m/^$match4\./ || $f =~ m/^$match5/ || $f =~ m/^$match6/ ) {
		   if ( not -e "$base/images/$f" ) {
               copy ("$DOC_DIR/images/$f", "$base/images/$f");
               print "$DOC_DIR/images/$f copied to $base/images/$f\n";
		   }
        }
     }
   }
}

get_xml_files($ARGV[0]);

open (IDXFP, ">$index_dir/$COMPS_INDEX") || die ("Cannot open file $index_dir/$COMPS_INDEX\n");

for $xml_file (@xml_files) {
   if (! -e "$xml_file" ) { print "Cannot find file \"$xml_file\".\n" }
   else {
      $component_name = $xml_file;       $component_name =~ s/.xml//; 
      $html_file = $component_name . ".htm";
      open (TMPFP, $TMP_htm) || die ("Cannot open file $TMP_htm\n");
      open (OFP, ">$base/$html_file") || die ("Cannot open file $base/$html_file\n");
      # ignore the unit column if there is no unit beside UNITLESS_UNIT
      $unit_flag = "FALSE";
      $unit = `grep "<UNIT>" $xml_file`;
      $unit =~ s/\s*<UNIT>UNITLESS_UNIT<\/UNIT>\s*//g;
      if ( $unit ne "" ) {
          $unit_flag = "TRUE";
	  }
      while (<TMPFP>) {
	     if (/<!-- DATA -->/) {
            create_htm ($xml_file);
         }
         else {
            print OFP "$_";
         }
      }
      close(TMPFP);
      close(OFP);

     # rename "$base/$html_file", "$base/$new_html_file";
      print "File: $base/$html_file has been created. \n";
   } 
 } 
close (IDXFP);

print "File: $index_dir/$COMPS_INDEX has been created.\n";

################
## End main
################

#--------------------------------------------------------------------------
#    get_xml_files
#    Parameters: $Index
#    Extract list of xml files.
#--------------------------------------------------------------------------
sub get_xml_files {
   if ($DEBUG eq "TRUE") {
       print "start sub: get_xml_files\n";
   }
   my $input = shift;
   if ( $input =~ /Index/ ) {
     # print "\n ***$input****";
      open (IDX, $input) || die ("Couldn't open Index file: $input.\n");
      while (<IDX>) {
         $_ =~ s/\s//g;
         push @xml_files, $_;
      }
      close(IDX);
   }
   else {
      #  print "\n ***$input****";
       die ("Usage: Specify an Index file!!\n");
   } 
}  # get_xml_files 

#--------------------------------------------------------------------------
#    create_htm
#    Parameters: $file
#    Creates a html file by extracting information from two associated
#    xml files.
#-------------------------------------------------------------------------- 
sub create_htm {
   if ($DEBUG eq "TRUE") {
       print "start sub: create_htm\n";
   } 
my $file = shift;

my $ParameterCount = 0;    # holds the number of parameters
my $OutputCount = 0;       # holds the number of outputs
my $InputCount = 0;        # holds the number of inputs
my $RefEndTable = "FALSE"; # sets to true if we need to insert </TABLE>
my $content = "";          # holds the data of a tag if it contains a new line
my $str1 = "";             # holds the stuff to be printed after print_version
my $second_content = "";   # holds the data for second xml file
my $derivedFromFlag = "FALSE"; # sets to true if we need to extract derived from
my $enumChoices = "";       #holds the choices for enum state
#my $idx_line = "";         # line to keep the information entered in idx file
my $class = "";             # holds the class name
my $domain = "";            # holds the domain name
my $component_name = "";    # holds the name of component
my $match = "";             # holds the info extracted from lp_html
my $lp_flag = "FALSE";      # set to TRUE if html file from learning product exist.
my $RangeofUsage = "";      # sets to not "" if html file from learning product contains Range of usage
my $symbol = "";            # sets to not "" if html file from learning product contains symbol for parameter
my $valueRange = "";        # sets to not "" if html file from learning product contains Value Range for parameter
my $footnote = "";        # sets to not "" if html file from learning product contains footnote for parameters table
my $ColumnCount = 0;        # keep the number of columns
my %param_value = ();
my %param_symbol = ();
my $param_name = "";

my $p = new XML::Parser(ErrorContext  => 2,
			Namespaces    => 1,
			ParseParamEnt => 1,
			Handlers      => {Start => \&sthndl,
					  End   => \&endhndl,
					  Char  => \&chrhndl
					 }
			);
$p->parsefile($file);

}
#--------------------------
#    sthndl
#--------------------------
sub sthndl {
  my $xp = shift;
  my $el = shift;

  if ($el eq "COMPONENT") { 
     $RefTag = "COMPONENT";
     $content = "";
      }
  elsif ($el eq "LIBRARY") {
      $str1 .= "<table border=0  width=\"50%\">\n";
	}
  elsif ($el eq "PARAMETER") {
     $RefTag = "PARAMETER";
     ++$ParameterCount;
     if ($ParameterCount == 1) { 
        print OFP "<h5><font color=\"#003366\" face=\"Verdana, Arial, Helvetica, sans-serif\">Parameters</font></h5></p>\n";
        print OFP "<table border=2 ALIGN=\"CENTER\" width=\"100%\">\n";
        print OFP "<thead><tr bgcolor=#BFCDEA><td><b>Name</b></td><td><b>Description</b></td><td><b>Default</b></td>";
        $ColumnCount = 3;
        
        if ( -e $lp_html ) {
             $valueRange = `grep "<h3>Parameters_Table</h3>" $lp_html`;
             $symbol =  `grep "<thead><tr bgcolor=#BFCDEA><td><b>Name</b></td><td><b>Symbol</b></td>" $lp_html`;
            
             $RangeofUsage = `grep "<h3>Range of Usage</h3>" $lp_html`;
           #  print "in exist lp_html:\nvalue: $valueRange\nsymbol: $symbol\nRangeofUsage: $RangeofUsage\n";
             
             if ( $symbol ne "" ) {

                 print OFP "<td><b>Symbol</b></td>";
                 ++$ColumnCount;
             }
             if ( $unit_flag eq "TRUE" ) {
                  print OFP "<td><b>Unit</b></td><td><b>Type</b></td>";
                  ++$ColumnCount;
                  ++$ColumnCount;
			 }
             else {
                   print OFP "<td><b>Type</b></td>";
                   ++$ColumnCount; 
             } 
             if ( $RangeofUsage eq "" && $valueRange ne "" ) {
                 print OFP "<td><b>Value Range</b></td>";
                  ++$ColumnCount;
                ######extract symbol and value range######
                eesof_get_value_Symbol ($lp_html);

			 }
        }
        else { 
        if ( $unit_flag eq "TRUE" ) {
                  print OFP "<td><b>Unit</b></td><td><b>Type</b></td>";
                  ++$ColumnCount;
                  ++$ColumnCount;
			 }
             else {
                   print OFP "<td><b>Type</b></td>";
                   ++$ColumnCount; 
             } 
	    }
        print OFP "</tr></thead>\n";
        $RefEndTable = "PARAMETER";
        $enumChoices = "";
     } 
  }
  elsif ($el eq "DEFAULT") { 
	if ( $enumChoices ne "" ) {
        $enumChoices =~ s/^, //; 
       # print "**enumChoices: $enumChoices\n";
        print OFP ": $enumChoices";
        $enumChoices = "";
	    
	}
  }
  elsif ($el eq "UNIT" && $RefTag eq "PARAMETER" ) {  
      if ( $unit_flag eq "TRUE" ) {
               print OFP "</td>";
	  } 
  }
  elsif ($el eq "RANGE_OF_USAGE") {
      if ($RefEndTable eq "PARAMETER") {

          #adding footnote
          if ( -e $lp_html ) {
              $footnote = `grep "<h3>Footnote</h3>" $lp_html`;
              if ( $footnote ne "" ) {
                  eesof_get_footnote($lp_html);
			  }
		 }
         $RefEndTable = "";
         print OFP "</table></center>\n";     
      }
      if ( $RangeofUsage ne "" ) {
          eesof_add_RangeofUsage ($lp_html);
	 }

  }
  elsif ($el eq "INPUT") {
     
     $RefTag = "INPUT";
     ++$InputCount;
     if ($InputCount == 1){ 
        print OFP "<h5><font color=\"#003366\" face=\"Verdana, Arial, Helvetica, sans-serif\">Pin Inputs</font></h5></p>\n";
        print OFP "<table border=2 ALIGN=\"CENTER\" width=\"100%\">\n";
        print OFP "<thead><tr bgcolor=#BFCDEA><td><b>Pin No.</b></td><td><b>Name</b></td><td><b>Description</b></td><td><b>Signal Type</b></td></tr></thead>\n";
        $RefEndTable = "INPUT";
       }
  }
  elsif ($el eq "OUTPUT") {
     if ($RefEndTable eq "INPUT") {
         print OFP "</table></center>\n";
       
     }
     $RefTag = "OUTPUT";
     ++$OutputCount;
     if ($OutputCount == 1){ 
        print OFP "<h5><font color=\"#003366\" face=\"Verdana, Arial, Helvetica, sans-serif\">Pin Outputs</font></h5></p>\n";
        print OFP "<table border=2 ALIGN=\"CENTER\" width=\"100%\"> \n";
        print OFP "<thead><tr bgcolor=#BFCDEA><td><b>Pin No.</b></td><td><b>Name</b></td><td><b>Description</b></td><td><b>Signal Type</b></td></tr></thead>\n";
        $RefEndTable = "OUTPUT";

       }
  }
  elsif ($el eq "HTM_DOC") {
       $content = "";
     }
}  # End sthndl
#--------------------------
#    enhndl
#--------------------------
sub endhndl {
  my ($xp, $el) = @_;
    if ($el eq "NAME" && $RefTag eq "COMPONENT") {
    $content =~ s/^\s*//g;          
    $content =~ s/\n//g;
    $name = $content;
    print OFP "<script language=\"Javascript\">\n    function favoritestitle() { return \"$name\"; }\n</script>\n<title>$name</title>\n</head>\n<body bgcolor=\"#FFFFFF\">\n<font color=\"#000000\" size=\"1\" face=\"Verdana, Arial, Helvetica, sans-serif\"><b><a href=\"../../doc.html\" target=\"_parent\">Manuals</a>&gt;<a href=\"../index.html\" target=\"_top\">Signal Processing Components</a></b></font><br>";
    print IDXFP "$name ";
    # file generated by learning product or developer and contains Range of Usage and Notes   
    $lp_html = "$DOC_DIR/$content.html";

    $RangeofUsage = "";
    $valueRange = "";
    $symbol = "";
    $content = "";
  }
  elsif ($el eq "DESCRIPTION" && $RefTag eq "COMPONENT") {
     $content =~ s/^\s*//g;
     $content =~ s/^\n//g;
     $content =~ s/\n$//g;
     $str1 = "<h2><font color=\"#003366\" face=\"Verdana, Arial, Helvetica, sans-serif\">$name ($content)</font></h2></p>\n";
      $content = "";
      ####add the c++ code if pl file for this component is shipped to customer
      if ( -e "$install_root/../package/docpl" ) {
          $pl =  $component_name . ".pl";
          $htm = $component_name . ".htm";
          my $example = "";
          $example = `grep "$pl" "$install_root/../package/docpl"`;
          if ( $example ne "" ) {
               $str1 .= "<a href=\"../../sp_items/$htm\"><img wight=200 hight=50 src=\"../C_Code.gif\" alt=\"C++ Code\" border=0></a></font></p>";
          print "Link to C++ Code has been added to $html_file\n";
		  }

      }
       
  }
  elsif ($el eq "LIBRARY") {

     my $new_name = $content;
     $new_name =~ s/\n//g;
     $new_name =~ s/^\s//g;       #  stripe off leading spaces 
     $new_name =~ s/\s/_/g;
     print IDXFP "$new_name ";
     # disabled print version temporary for ADS2001 release
     # for print_version (pdf file)
     $pdf_name = $new_name;
     if ( $pdf_name =~ m/,/ ) {
               $pdf_name =~ s/,.*//;
	 }
     $pdf_name =~ s/_\&amp;//;
    # print OFP "<font size=\"1\" face=\"Verdana, Arial, Helvetica, sans-serif\"><b><a href=\"../pdf/" . $pdf_name . ".pdf\">Print version of this Book (PDF file)</a></b></font>";
     # print saved info
     print OFP $str1;

     print OFP "<tr><td><b><font size=-1 color=\"#003366\" face=\"Verdana, Arial, Helvetica, sans-serif\">Library</font></b></td><td>$content</td></tr>\n";
    
     $content = "";
  }
  elsif ($el eq "DOMAIN") {
     $content =~ s/\s//g;    # strip all the white spaces and newline
     $content =~ s/\n//g;
     print IDXFP "$prod_name_doc/$component_name.htm\n";
     $domain = $content;
    # $new_html_file = $content . $html_file;   # pre append class name to html file name.
     $content = "";
   }
  elsif ($el eq "CLASS") {
     $current_dir=`pwd`;
     $class = $content;
     # ignore the class for subcircuts
     unless ( $current_dir =~ m/subckts/ ) {
         print OFP "<tr><td><b><font size=-1 color=\"#003366\" face=\"Verdana, Arial, Helvetica, sans-serif\">Class</font></b></td><td>$content</td></tr>\n";
         $content = "";
         #print "\ncontent: $content";
         $DerivedFromFlag = "TRUE";
         #print "\nDerivedFromFlag: $DerivedFromFlag";
         $class =~ s/\s//g;    # strip all the white spaces from class name
         $doc_file = $class . ".pl.xml"; 
         # parsing xml file produced by ptlang to get derivedfrom 
         if (-e "$doc_file") {
            # print "\nin -e $DerivedFromFlag\n";
            second_parse ($doc_file);
	     }
	 }
     $DerivedFromFlag = "FALSE";
  }
  elsif ($el eq "SYMBOL") {
     $content =~ s/\s//g;    # strip all the white spaces and newline
     $content =~ s/\n//g;
     if ( -e "$DOC_DIR/images/$content" ) {
         print OFP "</table>\n<h5><font color=\"#003366\" face=\"Verdana, Arial, Helvetica, sans-serif\">Symbol</font></h5></p>\n";
         print OFP "<center><font><img src=\"images/$content\"></font></center>\n</p>\n";
     
        copy ("$DOC_DIR/images/$content", "$base/images/$content");
     } 
     else {
         print OFP "</table>\n";
         print "warning: The symbol $DOC_DIR/images/$content is missing.\n";
     }  
	 
     $content = "";
  }
  elsif ($el eq "NAME" && $RefTag eq "PARAMETER") {
     $content =~ s/\s//g;    # strip all the white spaces and newline
     $content =~ s/\n//g;
     print OFP "<tr bgcolor=#DFE4EE><td>$content</td>";
     $param_name = $content;
     $content = ""; 
  }
  elsif (($el eq "NAME" && $RefTag eq "INPUT") || ($el eq "NAME" && $RefTag eq "OUTPUT")) {
      print OFP "<td>$content</td>";
     $content = "";
  }
  elsif ($el eq "DESCRIPTION" && ( $RefTag eq "PARAMETER" || $RefTag eq "INPUT" || $RefTag eq "OUTPUT" )) {
    $content =~ s/\n$//;   $content =~ s/^\n//;
    $content =~ s/^\s*//;
    $content = &reformat ($content);
   # print "**$content**\n";
    if ( $content eq "" ) {
        print OFP "<td>&#0160";
    }
    else {
         print OFP "<td>$content";
    }
    $content = "";
  }
  elsif ($el eq "ENUMCHOICE" && $RefTag eq "PARAMETER") {
    $content =~ s/\n//g;   $content =~ s/^\s*//;
    $enumChoices = $enumChoices . ", " . $content;
   # print "#enumChoices: $enumChoices\n";
    $content = "";
  }
  elsif ($el eq "UNIT" && $RefTag eq "PARAMETER") {
    $content =~ s/\n//g;    
    $content =~ s/^\s*//; 
    $content =~ tr/A-Z/a-z/;
    $content =~ s/_unit//;
    $content =~ s/unitless//;
    if ( $content eq "" ) {
        if ( $unit_flag eq "TRUE" ) {
               print OFP "<td>&#0160</td>";
	    } 
    }
    else {
      if ( $unit_flag eq "TRUE" ) {
            print OFP "<td>$content</td>";
	  }    
    }
    $content = "";
  }
  elsif (($el eq "TYPE" && $RefTag eq "PARAMETER") || ($el eq "TYPE" && $RefTag eq "INPUT") || ($el eq "TYPE" && $RefTag eq "OUTPUT")) {
    # change to lowercase and proper name
    $content =~ tr/A-Z/a-z/;
    $content =~ s/int/integer/;
	$content =~ s/float/floating-point/;
	$content =~ s/ *array/ array/;
    $content =~ s/ /\&nbsp;/g;

    print OFP "<td>$content</td>";
#####################add the information coming from lp(fix later)####################
    if ($el eq "TYPE" && $RefTag eq "PARAMETER") {
        if ( $RangeofUsage eq "" && $valueRange ne "" ) {
            if ( defined $param_value{$param_name} ) {
                 if ( $param_value{$param_name} eq "" ) {
                      print OFP "<td>&#0160</td>";
		         }
                 else {
                     if ( defined $param_symbol{$param_name} ) {
					   if ( $param_symbol{$param_name} =~ m/chars\// ) {
                              $param_value{$param_name} =~ s/, /,&nbsp;/g;
					   } else {
                              $param_value{$param_name} =~ s/, /,/g;
                       }
                    } 
				    print OFP "<td>$param_value{$param_name}</td>\n";
	   	         }
                # print "added value range for $param_name: $param_value{$param_name} \n";
	        }
            else {
                print OFP "<td>&#0160</td>";
            }
	    }
    }
   
    print OFP "</tr>\n";
    $content = "";
  }
  elsif ($el eq "DEFAULT" && $RefTag eq "PARAMETER" ) {
    $content =~ s/\n//g;     $content =~ s/^\s*//;   
    if ( $content eq "" ) {
        print OFP "<td>&#0160</td>";
    }
    else {
         print OFP "<td>$content</td>";
    }
#################add the information coming from lp(fix later)############
    if ( $symbol ne "" ) {
	   if ( defined $param_symbol{$param_name} ) {
		  if ( $param_symbol{$param_name} eq "" ) {
               print OFP "<td>&#0160</td>";
		  }
          else {
               print OFP "<td>$param_symbol{$param_name}</td>";
	   	  }
         # print "added symbol for $param_name: $param_symbol{$param_name} \n";
	   }
       else {
           print OFP "<td>&#0160</td>";
       }
    }  
    $content = "";
  }
  elsif (($el eq "PIN_NO" && $RefTag eq "INPUT") || ($el eq "PIN_NO" && $RefTag eq "OUTPUT")) {
      print OFP "<tr bgcolor=#DFE4EE><td>$content</td>";
      $content = "";
  }

  if ($el eq "COMPONENT") {
     if (($RefEndTable eq "PARAMETER" || $RefEndTable eq "INPUT" || $RefEndTable eq "OUTPUT")) {
        print OFP "</table></center>\n";
        $RefEndTable = "FALSE";
     }

     # extract Notes/Equations/References from Learning product html file 
     if (-e "$lp_html") {
        eesof_add_notes ($lp_html);
	  }
     else {
        print " NOTE: $lp_html does not exist.\n";
        # parsing xml file produced by ptlang which contains htm_doc
        if (-e "$doc_file") {
           second_parse ($doc_file);
        }
	  }
     $content = "";
     $ParameterCount = 0;
     $OutputCount = 0;      
     $InputCount = 0;
  }
  
}  # End endhndl

#--------------------------
#    chrhndl
#--------------------------
sub chrhndl {
  my ($xp, $data) = @_;
  $content = $content. $xp->xml_escape($data, '>');
}  # End chrhndl

#--------------------------------------------------------------------------
#    second_parse
#    Parameters: $file
#    Parse through the xml file generated by ptgem.
#--------------------------------------------------------------------------
sub second_parse {
   if ($DEBUG eq "TRUE") {
       print "start sub: second_parse\n";
   }
   my $file = shift;
   my $ptr = new XML::Parser(ErrorContext  => 2,
			Namespaces    => 1,
			ParseParamEnt => 1,
			Handlers      => {Start => \&second_sthndl,
					  End   => \&second_enhndl,
					  Char  => \&second_chrhndl
					 }
			);

   $ptr->parsefile($file);
}
#--------------------------
#    second_sthndl
#--------------------------
sub second_sthndl {
   my $xp = shift;
   my $el = shift;
   $second_content = "";
}
#--------------------------
#    second_enhndl
#--------------------------
sub second_enhndl {
   my $xp = shift;
   my $el = shift;
  # print "\nsecondparse $DerivedFromFlag\n";
   if ( $DerivedFromFlag eq "TRUE" && $el eq "DERIVED_FROM") {
       $second_content =~ s/\n//g;    
       $second_content =~ s/^\s*//g;
       $second_content =~ s/$domain//;
       my $temp_htm_name = "$domain$second_content.htm";
       # print "\nin if $DerivedFromFlag\n";
       if ( -e "$base/$temp_htm_name" ) {
           
            print OFP "<tr><td><b><font size=-1 color=\"#003366\" face=\"Verdana, Arial, Helvetica, sans-serif\">Derived From</font></b></td><td><a href=\"$temp_htm_name\">$second_content</td></tr>\n";
		  }
       else {
            print OFP "<tr><td><b><font size=-1 color=\"#003366\" face=\"Verdana, Arial, Helvetica, sans-serif\">Derived From</font></b></td><td>$second_content</td></tr>\n";
       }
       $content = "";
  }

   if ( $DerivedFromFlag eq "FALSE" && $el eq "HTM_DOC") {
       $second_content = &reformat ($second_content);
       print OFP "<p>\n<h5><font color=\"#003366\" face=\"Verdana, Arial, Helvetica, sans-serif\">Notes/Equations/References</font></h5>\n$second_content  \n";
       $second_content = "";
   }
}   # End second_enhndl
#--------------------------
#    second_chrhndl
#--------------------------
sub second_chrhndl {
   my ($xp, $data) = @_;
   $second_content= $second_content. $xp->xml_escape($data, '>');
} # second_chrhndl

#--------------------------------------------------------------------------
#    eesof_add_notes
#    Parameters: $file
#    Adds Notes/Equations/References extracted from Learning product html file #    to htm file.
#--------------------------------------------------------------------------
sub eesof_add_notes {
  #  if ($DEBUG eq "TRUE") {
       print "start sub: eesof_add_notes\n";
  # }
  my $file = shift;
  my $flag = "FALSE";
  open (FP , $file) || die ("Cannot open  $file\n");
  while (<FP>) {
	  if ( /<h3>Notes<\/h3>/ ) {
          print OFP "<h5>\n";
          $flag = "TRUE";
	   }
       elsif ( /<\/html>/  ) {
	       last;
	   }
	   elsif ( $flag eq "TRUE" ) {
          # handeling images
           if ( /<img src="images/ ) {
                  $gif_file = $_;
                  $gif_file =~ s/.*<img src="images\/([^"]*)".*\n/$1/;
				  if ( -e "$DOC_DIR/images/$gif_file" ) {
                     copy ("$DOC_DIR/images/$gif_file", "$base/images/$gif_file");
                     print "$DOC_DIR/images/$gif_file copied to $base/images/$gif_file\n"; 
		          }
		  }
                  
          print OFP "$_";
        
	   }
   }
   close (FP);
}

#--------------------------------------------------------------------------
#    eesof_add_RangeofUsage
#    Parameters: $file
#    Adds Range of Usage extracted from Learning product html file to htm file.
#--------------------------------------------------------------------------
sub eesof_add_RangeofUsage {
   # if ($DEBUG eq "TRUE") {
       print "start sub: eesof_add_RangeofUsage\n";
  # }

   my $file = shift;
   my $flag = "FALSE";
   open (FP , $file) || die ("Cannot open  $file\n");
   while (<FP>) {
	  if (/<h3>Range of Usage<\/h3>/ ) {
          print OFP "<h5><font color=\"#003366\" face=\"Verdana, Arial, Helvetica, sans-serif\">Range of Usage</font></h5>";
          $flag = "TRUE";
	   }
       elsif ( /<h3>Notes<\/h3>/ ) {
		  if ( $flag eq "FALSE" ) {
             print "Error: unable to add Range of Usage!!\n";
		  }
          else {
              $flag = "FALSE";
		  }
          last;
	   }
	  elsif ( $flag eq "TRUE" ) {
           # handeling images

           if ( /<img src="images/ ) {
                  $gif_file = $_;
                  $gif_file =~ s/.*<img src="images\/([^"]*)".*\n/$1/;
				  if ( -e "$DOC_DIR/images/$gif_file" ) {
                     copy ("$DOC_DIR/images/$gif_file", "$base/images/$gif_file");
                     print "$DOC_DIR/images/$gif_file copied to $base/images/$gif_file\n"; 
				   }
           print OFP "$_";
           
          }
          elsif (/<h5>/) {
             print "\n";
          }
          else {
             print OFP "$_";
          } 
	   }
   }
   close (FP);
}

#--------------------------------------------------------------------------
#    eesof_reformat
#    Parameters: $string
#    Reformat a string, change &lt; to <   &gt; to > &amp; to &
#--------------------------------------------------------------------------
sub reformat {
  my $s = shift;
  $s =~ s/\&amp;/&/g;
  $s =~ s/\&lt;/</g;  
  $s =~ s/\&gt;/>/g;
  return ($s);
}

#--------------------------------------------------------------------------
#    eesof_get_value_Symbol
#    Parameters: $file
#    Extracts value range and symbol for parameters from lp_file
#--------------------------------------------------------------------------
sub eesof_get_value_Symbol {
   # if ($DEBUG eq "TRUE") {
       print "start sub: eesof_get_value_Symbol\n";
  # }
  my $file = shift;
  my $flag = "FALSE";
  open (FP , $file) || die ("Cannot open  $file\n");
  while (<FP>) {
	 if ( /<table border=2>/ ) {
         $flag = "TRUE";
	 }
     elsif ( /<\/table>/  ) {
	     last;
	 }
	 elsif ( $flag eq "TRUE" ) {
		if ( /<tr>/ ) {
           $line = $_;
           if ( $symbol ne "" ) {
              $line =~ s/<tr><td>(.*)<\/td>\s*<td>(.*)<\/td><td>(.*)<\/td>.*\n//;
              $param_name = $1;
              $param_symbol{$param_name} = $2;
              $param_value{$param_name} = $3;
		   }
           else {
              $line =~ s/<tr><td>(.*)<\/td><td>(.*)<\/td>.*\n//;
              $param_name = $1;
              $param_value{$param_name} = $2;
           }      
        }
      }
   } #end while
  close(FP);
}      
#--------------------------------------------------------------------------
#    eesof_get_footnote
#    Parameters: $file
#    Extracts footnote for parameters table from lp_file
#--------------------------------------------------------------------------
sub  eesof_get_footnote {
   # if  ($DEBUG eq "TRUE") {
       print "start sub: eesof_get_footnote \n";
   # }
   my $file = shift;
   my $flag = "FALSE";
   open (FP , $file) || die ("Cannot open  $file\n");
   while (<FP>) {
	  if ( /<h3>Footnote<\/h3>/ ) {
         $flag = "TRUE";
	 }
	 elsif ( $flag eq "TRUE" ) {
          $_ =~ s/colspan=xxx/colspan=$ColumnCount/;
          print OFP "<tr bgcolor=#DFE4EE>\n$_\n</tr>\n";
          last;
     }
  } #end while
  close(FP);
}      

