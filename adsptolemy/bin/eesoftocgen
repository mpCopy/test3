#!/hped/builds/bin/perl -w
#---------------------------------------------------------------------------
#  Description:  This script is designed to generate needed files to 
#                display the documentation for ptolemy components.
#                
#                It grab all the *.idx files under install_root/doc/compsp 
#                and generates two files (compspTOC.html, compspix.html) \
#                for all the html files listed in *.idx files. 
#                 
#                To run this script you need perl parser and 
#                some files under sp-modelbuilder/docgen.
#                
#                
#  Usage:        eesoftocgen $install_root
#  Author:       Parvin Babaeian     
#  Created:      Feb 3,2000
#-------------------------------------------------------------------------

my $hpeesof_dir = $ENV{"HPEESOF_DIR_ARCH"} || $ENV{"HPEESOF_DIR"};

my $ptmk = $ENV{project_mk_dir} || "$hpeesof_dir/adsptolemy";

my $DEBUG = "FALSE";       # print debuging statement if this set to TRUE

my $XXXtoc_htm = "$ptmk/lib/docgen/XXXtoc.html";   # default toc file
my $new_toc_htm = "compspTOC.html"; # holds the toc file generated by this script
my $XXXix_htm = "$ptmk/lib/docgen/XXXix.html";     # default ix file 
my $new_ix_htm = "compspix.html";  # holds the ix file generated by this script
my $XXXheader_htm = "$ptmk/lib/docgen/XXXheader.htm";   # default package header file
my $header_htm = "";    # holds the header file for each entry under tree structure
my $header_list = "headerList";   # holds the list of generated header files
my $print_version = ""; # holds the line for print version
my %ix_list = (); 
my %toc_list = ();           
my @idx_files = "";               # holds the list of idx files
my @tree = "";                    # holds items of the tree
my @positions = "";               # holds positions of each item
my @end_tags = "";                # holds the ending tag for each item
my @subdirs = "";                 # holds the sub directorys under compsp
my @intro_files = "";             #list of all intro files
my $install_root = $ARGV[0];
my $base = "$install_root/compsp";
my $index_dir = "$base/index";
if ( -d $index_dir ) {

   ##get the Introduction files
   get_int_exp_files();
   get_idx_files ($index_dir);
   if ( @idx_files == 0 ) {
       die "Error: nothing is done, no .idx file exist under $index_dir\n.";
   } 
   ## remove old header files 
   if ( -e "$base/$header_list" ) {
       open (FP, "$base/$header_list") || die "Cannot open $base/$header_list\n";
       while (<FP>) {
         chop;
         if ( -e "$base/$_" ) { unlink "$base/$_" }

       }
       close (FP);
       unlink "$base/$header_list";
   }
   open (HFL, ">$base/$header_list") || die "Cannot open $base/$header_list\n";

   create_hash (@idx_files);
   generate_toc_htm (%toc_list);
   generate_ix_htm (%ix_list);
   close (HFL);
 }
else {
   die "Error: directory $index_dir does not exist.\n";
 }

###############
## End  Main
###############
#--------------------------------------------------------------------------
#    get_int_exp_files
#    Parameters: None
#    Find a list of Introduction and Examples file
#--------------------------------------------------------------------------
sub get_int_exp_files {
   if ($DEBUG eq "TRUE") {
       print "start sub: get_int_exp_files\n";
   }
   opendir (DIR, "$base") || die "Cannot open $base\n";
   @subdirs = grep !/^\.\.?$/ , readdir DIR;
   for $i (@subdirs) {
     @tmp_files="";
	 if ( -d "$base/$i" ) {
      
       opendir (SUBDIR, "$base/$i") || die "Cannot open $base/$i\n";
       @tmp_files = grep ( ( /^Int_/ || /^Exp_/ ), readdir(SUBDIR));
       closedir(SUBDIR);
       for $f (@tmp_files) {
          $tmp="$i/$f";
          push @intro_files,$tmp;
       }
     }    
   }
}
#--------------------------------------------------------------------------
#    get_idx_files
#    Parameters: dir
#    Extract list of idx files from $install_root/doc dir.
#--------------------------------------------------------------------------
sub get_idx_files {
   if ($DEBUG eq "TRUE") {
       print "start sub: get_idx_files\n";
   }
   my $dir = shift;
  # print "dir: $dir\n";
   opendir (DIR, "$dir") || die ("Couldn't open directory: $dir.\n");
   @idx_files = grep (/\.idx$/, readdir(DIR));  # all *.idx files
   closedir (DIR);
}

#--------------------------------------------------------------------------
#    create_hash
#    Parameters: None
#    Creates a hash table.
#-------------------------------------------------------------------------- 
sub create_hash {
  if ($DEBUG eq "TRUE") {
       print "start sub: create_hash\n";
	 }
   my @ind_files; 
   my $temp_htm_file = "";

	for $file (@idx_files) {
      open (FP , "$index_dir/$file") || die "Cannot open the file: $index_dir/$file\n";
    #  print "processing: $index_dir/$file\n";
      while (<FP>) {
		chop;
        $_ =~ s/\015$//g;
		next if (/^\s*$/);
            @temp = split / /, $_;
            ($name, $library, $temp_htm_file) = @temp;
           # print "name: $name library: $library file: $temp_htm_file\n";
            # creating a hash to be used for toc file generation
	    	if ( $library ne "Testing_(for_development_use_only)" && $library ne "" ) {
               if ( exists  $toc_list{$library} ) {
                   $toc_list{$library} .= " $name $temp_htm_file";
			   } else {
                   $toc_list{$library} = $name . " " . $temp_htm_file;
		       }
               # creating a hash to be used for ix file generation
               if ( exists  $ix_list{$name} ) {
                  $ix_list{$name} .= " $temp_htm_file";
		       } else {
                   $ix_list{$name} =  $temp_htm_file;
	           }
			 }
	  }
      close (FP);
   }  # end for
   # create a new toc hash for sub libraries
   
 

   if ( $DEBUG eq "TRUE" ) {   
       for $k (sort keys %toc_list) {
           print "key: $k \n value: $toc_list{$k}\n";
       }
       print "*******************************\n";
       $count = 0;
       for $k (sort keys %ix_list) {
           print "key: $k \n value: $ix_list{$k}\n";
           ++$count;
       }
       print "count: $count\n";
    } # if DEBUG
}
#--------------------------------------------------------------------------
#    generate_toc_htm
#    Parameters: %toc_list
#    Generates file: compsTOC.html
#-------------------------------------------------------------------------- 
sub generate_toc_htm {
   if ($DEBUG eq "TRUE") {
       print "start sub: generate_toc_htm\n";
   }
   my %toc_list = @_; 
   my $count = 0;
   $tree[$count] = "menu";
   $positions[$count] = 0;
   $end_tags[$count] = "";
   $tree[1] = "";
   $tree[2] = "";
   open (TOCFP, $XXXtoc_htm) || die;
   open (OFP, ">$base/$new_toc_htm") || die;
   while (<TOCFP>) {
     if (/<!-- DATA -->/) {
	    for $library (sort { lc($a) cmp lc($b) } keys %toc_list) {
          $temp_name = $library;
		  if ( $temp_name =~ m/,/ ) {
               $temp_name =~ s/,.*//;
		  }
          $temp_name =~ s/_\&amp;//;
          # disabled print version temporary for ADS2001 release see XXXheader.htm
         # $print_version = "<td><font size=\"1\" face=\"Verdana, Arial, Helvetica, sans-serif\"><b><a href=\"../pdf/" . $temp_name . ".pdf\">Print version of this Book (PDF file)</a></b></font></td>\n";
           @library_names = split /,/, $library;
           $count = 0;
           for $library_name ( @library_names ) {
              ++$count;
              $new_name = $library_name;
              $new_name =~ s/_/ /g;  # change _ to space
              $new_name=~ s/^ //;
# NOTE: if name has - or &amp; it must changed to something else per mtmcode.js###
              $base_library = $library_name;
              $base_library =~ s/\W//g;
              $base_library =~ s/\&amp;//;
              $base_library = "$tree[$count-1]_$base_library";
	          # skip the node which has been created already
              if ( $base_library ne $tree[$count] ) {
			      if ( $end_tags[$count-1] ne "" ) {
                     ++$positions[$count-1];
                     print OFP "$end_tags[$count-1]\n";
				  }
                  $positions[$count] = 0;
                  $tree[$count] = $base_library;
 
                  # generating a header file for this entry to tree structure
                  $header_htm = $tree[$count]; 
                  $header_htm =~ s/menu_//;
                  $header_htm = $header_htm . ".htm";

                  #get the dir under compsp (hierarchy structure)
                  $tmp_dir = $toc_list{$library};
                  $tmp_dir =~ s/^[^ ].* ([^\/]*).*/$1/;
                  $header_htm = "$tmp_dir/$header_htm";

                  generate_header ($header_htm, $new_name);                  
                  $end_tags[$count] = ""; 
                  print OFP "   $tree[$count-1].MTMAddItem(new MTMenuItem (\"$new_name\", \"$header_htm\", \"helpcontents\"))\n;\n";
                  print OFP "   // nested submenu  $tree[$count]\n";
                  print OFP "   var  $tree[$count] = null;\n";
                  print OFP "   $tree[$count] = new MTMenu();\n";
                  $examples_line = "";
                  SWITCH: {
                   if ( $new_name eq "Antennas &amp; Propagation" )
                     {  $intro_file = "Antennas and Propagation"; last SWITCH; }
                   if ( $new_name eq "cdma2000" )
                     {  $intro_file = "cdma2000"; last SWITCH; } 
                   if ( $new_name eq "W-CDMA" )
                     {  $intro_file = "W-CDMA"; last SWITCH; } 
                   if ( $new_name eq "3GPPFDD" )
                     {  $intro_file = "3GPPFDD"; last SWITCH; }
                   if ( $new_name eq "Synthesizable DSP : Xilinx" )
                     {  $intro_file = "Numeric, Xilinx Synthesizable DSP"; last SWITCH; }
                 
                   else {
                        $intro_file = $header_htm;
                        $intro_file =~ s/^[^\/].*\///;
                        $intro_file =~ s/\.htm//;
                        $intro_file =~ s/__/,_/g;
                        $intro_file =~ s/_/ /g;
					}
				  }
                #  print "%%%%$intro_file%%%\n";
                  for $f (sort { lc($a) cmp lc($b) } @intro_files ) {
                    if ( -f "$base/$f" ) {
                       #get the title line
                       open ( FP, "$base/$f" )  || die "Cannot open the file: $base/$f\n";
                       while (<FP>) {
						 if ( /<title>/ ) {
                            $temp_name = "$_";
                            last;
						 }
                      }
                      close (FP);
                      $string = "Introduction: " . $intro_file . " ";     
					  if ( $temp_name =~ m/$string/ ) {
                         $intro_name = $temp_name;
                         $intro_name =~ s/<title>([^<]*).*\n/$1/;
                         $intro_name =~ s/^\s*//g;
                         $intro_name =~ s/\s*$//g;
                      #   print "title: **$intro_name**\n";
                         $intro_name =~ s/^Introduction: //;
                         $intro_name =~ s/ Components$//;
                         $intro_name =~ s/ Design Library$//;
                         $intro_name =~ s/$intro_file//;
                         $intro_name =~ s/^\s*//g;
                         $intro_name =~ s/\s*$//g;
                         $intro_name =~ s/_/ /g;
                       # print "Int: **$f**$intro_name**\n";
                         if ( $intro_name eq "" ) {
                             $intro_name = "Introduction";
						 }
                         print OFP "      $tree[$count].MTMAddItem(new MTMenuItem(\"$intro_name\", \"$f\", \"helpcontents\"));\n";
                         ++$positions[$count]
					   } 
                       else {
                          $string = "Examples: " . $intro_file . " ";
                          if ( $temp_name =~ m/$string/ ) {
                             $examples_name = $temp_name;
                             $examples_name =~ s/<title>([^<]*).*\n/$1/;
                             $examples_name =~ s/^\s*//g;
                             $examples_name =~ s/\s*$//g;  
                             $examples_name =~ s/ Design Examples$//;
                             $examples_name =~ s/EDGE Designs$/EDGE EDGE Designs/;
                             $examples_name =~ s/$intro_file//;
                             $examples_name =~ s/^ //;
                             if ( $examples_name eq "Examples: " ) {
                                $examples_name = "Examples";
						     }
                             $examples_line .= "      $tree[$count].MTMAddItem(new MTMenuItem(\"$examples_name\", \"$f\", \"helpcontents\"));\n";
						 }
					   }
					 }  #  if ( -f "$base/$f" )

				  }  #  for $f (sort { lc($a) cmp lc($b) } @intro_files )
                  $end_tags[$count-1] = $examples_line . "\n  $tree[$count-1].items[$positions[$count-1]].MTMakeSubmenu($tree[$count]);\n";
                  
             } 
             
		   }
           
           # prepare the toc_list 
           @temp = split / /, $toc_list{$library};
           # if a component htm file is listed more than once, ignore the rest
           %list = ();
           for ($i = 0; $i<@temp; $i = $i+2) {
              if ( exists ( $list{$temp[$i+1]})) {
                  next;
              }
              else {
                 $list{$temp[$i+1]} =  $temp[$i];
		      }
           }
           if ( $DEBUG eq "TRUE") {
              for $f (@temp) {
               print "**$f\n**";
			  }
			}
	       # let the component name be the key for sorting purpose
           %new_list = ();
           for $k( keys %list) {
              $new_list{$list{$k}} = $k;
		   }

           # print a line for each comp.
           for $comp (sort keys %new_list) {
              print OFP "      $tree[$count].MTMAddItem(new MTMenuItem(\"$comp\", \"$new_list{$comp}\", \"helpcontents\"));\n";
	       }

           #attach subtree to the parent tree in right position
           print OFP "$end_tags[$count-1]\n";
           $end_tags[$count-1] = "";
           ++$positions[$count-1];
         }
         print OFP "$end_tags[0]\n"; 
	  }
       else {
           print OFP "$_";
      }
   }
   close (OFP);
   close (TOCFP);
 #  print "File: $base/$new_toc_htm has been created.\n";
} #generate_toc_htm

#--------------------------------------------------------------------------
#    generate_ix_htm
#    Parameters: %ix_list
#    Generates file: compspix.html 
#
#-------------------------------------------------------------------------- 
sub generate_ix_htm {
   if ($DEBUG eq "TRUE") {
       print "start sub: generate_ix_htm\n";
   }
   my %ix_list = @_;
   my $char = "A";
   my $count = 1;
   

   open (IXFP, $XXXix_htm) || die;
   open (OFP, ">$base/$new_ix_htm") || die;
   while (<IXFP>) {
      if (/<!-- DATA -->/) {     # replacing data with new info
        #sort without regard to case
    	for $name (sort { lc($a) cmp lc($b) } keys %ix_list) { 
       
           # print the header if needed
           @chars = split //, $name;   # get the first char
           $first_char = $chars[0]; 
           $first_char = uc($first_char);
          # print " first_char: $first_char \n";
           if ( $first_char ne $char ) {
              $char = $first_char;
              print OFP "<tr><td><font size=\"2\" face=\"Verdana, Arial, Helvetica, sans-serif\"><a name=\"IX_$char\"><strong>$char</strong></a></font></td></tr>";
	       }
           elsif ( $count == 1 ) {   # if the first name starts with A
              print OFP "<tr><td><font size=\"2\" face=\"Verdana, Arial, Helvetica, sans-serif\"><a name=\"IX_A\"><strong>A</strong></a></font></td></tr>\n";
	       }

           # print one line for each html file
           @temp = split / /, $ix_list{$name};
          
           # keep only one copy of each html file
           @new_temp = "";
           for ($i = 0 ; $i<@temp; ++$i) {
              $found = "FALSE";
			  for ($j = 0; $j<@new_temp; ++$j) {
			     if ( $temp[$i] ne $new_temp[$j] ) {
                     next;
			     } else {
                     $found = "TRUE";
                    # print "### found: $temp[$i]\n";
                 }
			  }
			  if ( $found eq "FALSE" ) {
                   push  @new_temp, $temp[$i];
			  }
			}
           if ( $DEBUG eq "TRUE") {
             print "@new_temp\n";
           }
           for $f (sort @new_temp) {
			 if ( $f ne "") {
	             print OFP "<tr><td><font size=\"2\" face=\"Verdana, Arial, Helvetica, sans-serif\">&nbsp;&nbsp;&nbsp;<a href=\"$f\">$name</a></font></td></tr>\n";
			}
           } 
           ++$count;
		 }
      }
      else {
           print OFP "$_";
      }
    } # end of while
    close (OFP);
    close (IXFP);
  #  print "File: $base/$new_ix_htm has been created.\n";
} #generate_ix_htm  
#--------------------------------------------------------------------------
#    generate_header
#    Parameters: header_htm, new_name
#    Generates header file for each entry under tree structure
#-------------------------------------------------------------------------- 
sub generate_header {
   if ($DEBUG eq "TRUE") {
       print "start sub: generate_header\n";
   }
   my ($htm_file,$lib_name) = @_;
   open (HFP, $XXXheader_htm) || die("Couldn't open file: $XXXheader_htm\n");
   open (NHFP, ">$base/$htm_file") || die("Couldn't open file: $base/$htm_file\n");
   while (<HFP>) {
     # disabled print version temporary for ADS2001 release see XXXheader.htm
     if (/<!-- PRINT VERSION -->/) {
         print NHFP "$print_version";
	   }
     elsif (/<!-- DATA -->/) {
         print NHFP "$lib_name Components\n";
	   }
     else {
         print NHFP $_;
	   }
  }
  print HFL "$htm_file\n";
  close (HFP);
  close (NHFP);

 } #generate_header
