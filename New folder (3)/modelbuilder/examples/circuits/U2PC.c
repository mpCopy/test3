/* Copyright Keysight Technologies 2002 - 2011 */ 
LOCAL const char sccs_cui_circuit_template[]="@(#) $Source: /cvs/sr/src/geminiui/modelbuilder/U2PC.c,v $ $Revision: 1.4 $ $Date: 2011/08/27 00:17:20 $";

/******************************************************************************

   This template file can be modified by the user, it will never be modified
   by the Analog Model Development interface.  The structure of the files
   is (assuming user's model is called XYZ):

   XYZ_h.c         This file is auto-generated each time during the compile
                   process. It includes:

                   userdefs.h    the header file (copied to the local
                                 project's network directory only once).
                                 The file includes the <math.h> system
                                 header file.

                   XYZ.c         this file

   XYZ.dsn         This is the symbol file.

   XYZ.ael         This file contains the AEL code necessary to describe
                   the component and its parameters to the ADS design
                   environment (note that an .atf version of this file
                   is automatically generated by ADS when the component
                   is loaded).


   Each of the function calls below can be modified by the user.  Note
   that all functions are not necessarily used, this depends on the
   settings in the Code Options...  dialog box (the XYZ_h.c file
   redirects unused functions to NULL).

   Several other files will be installed in the networks directory:

   userindx.c      This file is for backwards compatibility with the
                   Series IV Senior interface. Once copied, it is never
                   modified by the Analog Model Development interface.

   cui_indx.c      This file is auto-generated each time a compile/link
                   is performed. It contains the list of calls from the
                   simulator to link in the boot_modules in the user's
                   code.

   hpeesof*.mak    This is the makefile that will be used to compile/link
                   (* = debug or opt).  It will #include two other files:

                   modelbuilder.mak   This file is auto-generated each
                                      time and contains the files to
                                      complile/link based on the dialog
                                      box settings.

                   user.mak           This file is copied only once and
                                      never modified by the Analog Model
                                      Development interface. It can be
                                      modified by the user.

***************************************************************************/

/*
 * Lossy transmission line with parameters
 * characteristic impedance, length,
 * relative permittivity (dielectric constant),
 * attenuation (dB/length):
 * ELEMENT U2PC Id n1 n2 Z=# L=# E=# A=#
 */
#define VLIGHT 2.9979250e8 /* m/sec */
#define sqr(x) ((x)*(x))
#define TWENTY_LOGE 8.6858896
#define ZO 50 /* reference impedance */
#include "stdio.h"

static char ErrMsg[101];


static boolean compute_y(
  UserInstDef *userInst,
  double omega,
  COMPLEX *yPar)
{
  double z, len, e, a, lenUnit;
  double alphal, betal, vphase;
  double sinbl, cosbl;
  double expmal, exppal;
  double sinhal, coshal;
  double twozzo, sumzsq, denom;
  COMPLEX s11, s21, S[4];
  UserParamData *pData = userInst->pData;

  lenUnit = get_lenunit(userInst->eeElemInst);

  z = pData[0].value.dVal;
  len = pData[1].value.dVal * lenUnit;
  e = pData[2].value.dVal;
  a = pData[3].value.dVal/lenUnit;
  if (e < 1.0)
  {
    (void)sprintf(ErrMsg, "u2pc_y(%s): invalid E=%g", userInst->tag, e);
    return FALSE;
  }
  vphase = VLIGHT / sqrt(e);
  betal = omega * len / vphase;
  sinbl = sin(betal);
  cosbl = cos(betal);
  alphal = a * len / TWENTY_LOGE;
  if (alphal > 30.0)
    alphal = 30.0;
  exppal = exp(alphal);
  expmal = 1.0 / exppal;
  sinhal = 0.5 * (exppal - expmal);
  coshal = 0.5 * (exppal + expmal);
  twozzo = 2.0 * z * ZO;
  sumzsq = sqr(z) + sqr(ZO);
  denom = sqr(twozzo * coshal * cosbl + sumzsq * sinhal * cosbl)
        + sqr(twozzo * sinhal * sinbl + sumzsq * coshal * sinbl);
  s11.real = (sqr(z) - sqr(ZO)) *
             (twozzo * sinhal * coshal +
              sumzsq * (sqr(sinhal) * sqr(cosbl) + sqr(coshal) * sqr(sinbl)))
            / denom;
  s11.imag = (sqr(z) - sqr(ZO)) * sinbl * cosbl * twozzo / denom;
  s21.real = twozzo * (twozzo * coshal * cosbl + sumzsq * sinhal * cosbl)
           / denom;
  s21.imag = -twozzo * (twozzo * sinhal * sinbl + sumzsq * coshal * sinbl)
           / denom;

  S[3] = S[0] = s11;
  S[2] = S[1] = s21;
  return s_y_convert(S, yPar, 1, ZO, 2);
}

/*----------------------------------------------------------------------------*/

static boolean fix_tr(
  UserInstDef *userInst)
{
  UserParamData *pData = userInst->pData;
  boolean status = TRUE;
  double lenUnit;
  double z0, len, eps, att;
  double td, attdb, loss;

  lenUnit = get_lenunit(userInst->eeElemInst);

  z0  = pData[0].value.dVal;
  len = pData[1].value.dVal * lenUnit;
  eps = pData[2].value.dVal;
  att = pData[3].value.dVal/lenUnit;
  if (eps < 1.0)
  {
    (void)sprintf(ErrMsg, "fix_tr(%s): invalid E=%g", userInst->tag, eps);
    send_info_to_scn(ErrMsg);
    return FALSE;
  }
  td = len * sqrt(eps) / VLIGHT;
  attdb = att * len;
  loss = pow(10.0, -attdb/20.0);

  status = add_tr_tline(userInst, 0, 1, GND, GND, z0, td, loss);

  return status;
}

/*----------------------------------------------------------------------------*/

static boolean analyze_tr(
  UserInstDef *userInst,
  double *vPin)
{
  /*
   * once the transmission line is placed by fix_tr,
   * no real action is required here as the transmission line will be
   * automatically analyzed. this routine must still exist and return
   * a value of TRUE.
   */

  return TRUE;
}

#undef VLIGHT
#undef TWENTY_LOGE

