// Copyright Keysight Technologies 1998 - 2014  
// @(#) $Source: /cvs/sr/src/genfun/source/signal_proc_fun.ael,v $ $Revision: 1.21 $ $Date: 2011/08/23 21:25:20 $



// basic signal processing AEL expressions functions


defun peak_to_average(a)
{
    return max(a)-mean(a);
}

//**************************************************************
//      Add two RF modulated signal represented by the triplet I,Q,Fc

/*BEGIN_DOC
FUN_NAME: add_rf()
FUN_DESCRIPTION: Returns the sum of two Timed Complex Envelope signals defined by the triplet in-phase (real or I(t)) and quadrature-phase (imaginary or Q(t)) part of a modulated carrier frequency(Fc). 
RETURNED_VALUE: Complex
CATEGORY: Signal Processing
SYNTAX: y = add_rf(T1, T2) 
EXAMPLE:
y= add_rf(T1, T2)
ARGUMENT
  ARG_NAME: T1
  ARG_DESCRIPTION: Timed Complex Envelope signals at carrier frequencies Fc1
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: T2
  ARG_DESCRIPTION: Timed Complex Envelope signals at carrier frequencies Fc2
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
DEFINED_IN: $HPEESOF_DIR/expressions/ael/signal_proc_fun.ael
SEE ALSO: None
NOTES:
Used in Signal processing designs that output Timed Signals using Timed Sinks 

This equation determines the sum of two Timed Complex Envelope at a new carrier frequency Fc3. Given Fc1 and Fc2 as the carrier frequencies of the two input waveforms, the output carrier frequency Fc3 will be the greater of the two. 
EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS
END_DOC*/

//**************************************************************

defun add_rf(eNv1,eNv2)
{ 
  // First, do preliminary checking for data validity
  
  decl deltawt;
  decl reNv3;
  decl ieNv3; 
  decl eNv3;
  decl fc3;
  decl fc1 = get_attr(eNv1, "fc");
  decl fc2 = get_attr(eNv2, "fc");
    
  if(fc1 < 0){
    print_function_error("add_rf","First argument data type is not Timed Complex Envelope\n\
    Can not add this type of data, Use standard add (+)");
    return;
  }

  if(fc2 < 0){
    print_function_error("add_rf","Second argument data type is not Timed Complex Envelope\n\
    Can not add this type of data, Use standard add (+)");
    return;
  }
  
    
  if((fc1 == 0.0) || (fc2 == 0.0)){
    fc3 = 0.0;
  }
  else{
    fc3 = (fc2 > fc1) ? fc2 : fc1;
  }
  
  // the following is for testing till indep() expression works
  
  
  //assuming both time axes are the same
  decl timAx = indep(eNv1, "time");

  // FIXME:
  //decl tstep = timAx[1] - timAx[0];
  //decl deltfc = abs(fc2 - fc1);
  //if ( deltafc > 0. && tstep>1./deltafc/5 ){
  //  print("Warnning: Time step used is too large & may cause loss of information.\n\
  //  The recommended Tstep is :\n");
  //  print(1./deltafc/5);
  //}

  if((fc1 < 1e-20 &&  fc2 < 1e-20) || fc1==fc2){
    eNv3 = eNv1 + eNv2;
    set_attr(eNv3, "fc", 0.0);
    set_attr(eNv3, "dataType", "TimedBB");
  } 
  else if(fc1 > fc2 && fc2 > 0.0){
    deltawt= 2.0*PI*(fc2-fc1)*timAx;
    reNv3 = cos(deltawt).*real(eNv2)-sin(deltawt).*imag(eNv2);
    ieNv3 = sin(deltawt).*real(eNv2)+cos(deltawt).*imag(eNv2);
    eNv3 = reNv3 + sqrt(-1) * ieNv3;
    set_attr(eNv3, "fc", identify_value(fc1));
    set_attr(eNv3, "dataType", "TimedCE");
  }
  else if(fc2 > fc1 && fc1 > 0.0){
    deltawt= 2.0*PI*(fc1-fc2)*timAx;
    reNv3 = cos(deltawt).*real(eNv1)-sin(deltawt).*imag(eNv1);
    ieNv3 = sin(deltawt).*real(eNv1)+cos(deltawt).*imag(eNv1);
    eNv3 = reNv3 + sqrt(-1) * ieNv3;
    set_attr(eNv3, "fc", identify_value(fc2));
    set_attr(eNv3, "dataType", "TimedCE");
  }  
  else if(fc1 == 0.0){
    deltawt= 2.0*PI*(fc1-fc2)*timAx;
    reNv3 = cos(deltawt).*real(eNv2)-sin(deltawt).*imag(eNv2);
    eNv3 = reNv3 + sqrt(-1) * 0.0 ;
    set_attr(eNv3, "fc", 0.0);
    set_attr(eNv3, "dataType", "TimedBB");
  } 
  else {  // if(fc2 == 0.0)
    deltawt= 2.0*PI*(fc2-fc1)*timAx;
    reNv3 = cos(deltawt).*real(eNv1)-sin(deltawt).*imag(eNv1);
    eNv3 = reNv3 + sqrt(-1) * 0.0;
    set_attr(eNv3, "fc", 0.0);
    //setattr(eNv3, "dataType", "TimedBB");
  } 
  
  return eNv3;
}


//****************************************************************************
//spec_power
//computes the integrated signal power of the spectrum (in dBm)
/*BEGIN_DOC
FUN_NAME: spec_power()
FUN_DESCRIPTION: Returns the integrated signal power (dBm) of a spectrum
RETURNED_VALUE: Real
CATEGORY: Signal Processing
SYNTAX: y = spec_power(spectralData{, lowerFrequencyLimit, upperFrequencyLimit})
EXAMPLE:
total_power = spec_power(dBm(Mod_Spectrum), 60 MHz, 71 MHz)
where Mod_Spectrum is the instance name of a SpectrumAnalyzer sink component, will return the integrated power between 60 and 71 MHz.

total_power = spec_power(dBm(fs(Vout[1])), indep(m1), indep(m2))
where Vout is a named node in a Circuit Envelope simulation, will return the integrated power between markers 1 and 2.

ARGUMENT
  ARG_NAME: spectralData
  ARG_DESCRIPTION: spectral data in dBm
  ARG_DEFAULT: None
  ARG_RANGE: None
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: lowerFrequencyLimit
  ARG_DESCRIPTION: lower frequency limit to be used in calculating the integrated power
  ARG_DEFAULT: min(indep(spectralData))
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: upperFrequencyLimit
  ARG_DESCRIPTION: upper frequency limit to be used in calculating the integrated power
  ARG_DEFAULT: max(indep(spectralData))
  ARG_RANGE: [lowerFrequencyLimit:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: NO
DEFINED_IN: $HPEESOF_DIR/expressions/ael/signal_proc_fun.ael
SEE ALSO: None
NOTES:
Used in Circuit Envelope simulation, HB, Data Flow simulation. 

This expression can be used with spectral data of up to 6 dimensions (frequency should be the inner dimension).

The spec_power() returns the power (in dBm) of a spectrum integrated between the lower and upper frequency limits specified. If no lower (upper) limit is specified the lowest (highest) frequency in the spectral data is used instead.

The input spectral data must be in dBm. Spectral data can be generated in several different ways, such as applying the fs() expression on voltage or current time domain data or using the SpectrumAnalyzer sink component. The obsolete components SpecAnalyzer and FFTAnalyzer also generate spectral data.

The fs() expression returns the voltage or current spectrum of the input data and so the dBm() expression should be applied to the fs() output before it is passed to the spec_power() expression. The frequency axis values in the spectral data returned by fs() are in Hz and so if lower and/or upper frequency limits are to be passed to spec_power() they should be specified in Hz.

Similarly, the SpectrumAnalyzer sink component returns the voltage spectrum of the input signal and so the dBm() expression should be applied to the spectral data generated by SpectrumAnalyzer before it is passed to the spec_power() expression. The frequency axis values in the spectral data generated by SpectrumAnalyzer are in Hz and so if lower and/or upper frequency limits are to be passed to spec_power() they should be specified in Hz.

On the contrary, the obsolete SpecAnalyzer and FFTAnalyzer sink components can return the spectrum of the input signal in dBm, dBV, or Magnitude (based on the value of their Display parameter). If dBm is selected, then the spectral data generated by these two sinks can be directly passed to spec_power(). Otherwise, the appropriate transformation from dBV to dBm or Magnitude to dBm should be applied first. The frequency axis values in the spectral data generated by SpecAnalyzer and FFTAnalyzer are in the unit specified by their DisplayFreqUnit parameter and so if lower and/or upper frequency limits are to be passed to spec_power() they should be specified in the same unit.

EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS
END_DOC*/
//****************************************************************************
defun spec_power(spectrum, u_f_start, u_f_stop)
{ 
  decl z, sweepDim = sweep_dim(spectrum);
  
  switch(sweepDim)
    {
    case 0:
      z = spectrum;
      break;
    case 1:
      z = spec_power_1d(spectrum, u_f_start, u_f_stop);
      break;
    case 2: 
      z = spec_power_2d(spectrum, u_f_start, u_f_stop);
      break;
    case 3: 
      z = spec_power_3d(spectrum, u_f_start, u_f_stop);
      break;
    case 4: 
      z = spec_power_4d(spectrum, u_f_start, u_f_stop);
      break;
    case 5: 
      z = spec_power_5d(spectrum, u_f_start, u_f_stop);
      break;
    case 6: 
      z = spec_power_6d(spectrum, u_f_start, u_f_stop);
      break;
    default:
      print_function_error("spec_power"," does not support data with dimensions greater than six.");
      return; 
      break;
    }
     
  return z;
} // fun - spec_power

defun spec_power_1d(spectrum, u_f_start, u_f_stop)
{
    decl f_start, f_stop;
    decl freq = indep(spectrum);
    
    if (u_f_start == NULL)
	f_start = freq[0];
    else
	f_start = u_f_start;

    if (u_f_stop == NULL)
	f_stop = freq[sweep_size(freq)-1];
    else
	f_stop = u_f_stop;
    
    decl l_index=find_index(freq, f_start);
    decl h_index=find_index(freq, f_stop);

    if ( l_index > h_index )
    {
	decl tmp = l_index;
	l_index = h_index;
	h_index = tmp;
    }
    
    decl power_in_watts = pow(10,(spectrum[l_index::h_index]-30)/10);
    decl total_power = sum(power_in_watts);

    return 10*log10(total_power)+30;
}

defun spec_power_2d(spectrum, u_f_start, u_f_stop)
{ 
  decl z, i;
  
  decl z = spectrum[::,0];
  decl numPts = sweep_size(z);
  for(i=0; i< numPts; i++)
    z[i] = spec_power_1d(spectrum[i,::], u_f_start, u_f_stop);
  return z;
}

defun spec_power_3d(spectrum, u_f_start, u_f_stop)
{ 
  decl z, i;
  
  decl z = spectrum[::,::,0];
  decl numPts = sweep_size(z[::,0]);
  for(i=0; i< numPts; i++)
    z[i,::] = spec_power_2d(spectrum[i,::,::], u_f_start, u_f_stop);
  return z;
}

defun spec_power_4d(spectrum, u_f_start, u_f_stop)
{ 
  decl z, i;
  
  decl z = spectrum[::,::,::,0];
  decl numPts = sweep_size(z[::,0,0]);
  for(i=0; i< numPts; i++)
    z[i,::,::] = spec_power_3d(spectrum[i,::,::,::], u_f_start, u_f_stop);
  return z;
}

defun spec_power_5d(spectrum, u_f_start, u_f_stop)
{ 
  decl z, i;
  
  decl z = spectrum[::,::,::,::,0];
  decl numPts = sweep_size(z[::,0,0,0]);
  for(i=0; i< numPts; i++)
    z[i,::,::,::] = spec_power_4d(spectrum[i,::,::,::,::], u_f_start, u_f_stop);
  return z;
}

defun spec_power_6d(spectrum, u_f_start, u_f_stop)
{ 
  decl z, i;
  
  decl z = spectrum[::,::,::,::,::,0];
  decl numPts = sweep_size(z[::,0,0,0,0]);
  for(i=0; i< numPts; i++)
    z[i,::,::,::,::] = spec_power_5d(spectrum[i,::,::,::,::,::], u_f_start, u_f_stop);
  return z;
}






// NOT DELETE THE FOLLOWING!!!!! *****
//
// This obviously isn't a C++ file, but the C++ editing mode works.
//
// Local Variables:
// mode: c++
// header-comment-character: ?*
// header-prefix: "/* -*-C++-*-"
// header-suffix: "*/"
// End:
//
//
