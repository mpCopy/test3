// Copyright Keysight Technologies 1998 - 2018  
// @(#) $Source: /cvs/sr/src/genfun/source/digital_wireless_fun.ael,v $ $Revision: 1.72 $ $Date: 2012/09/04 22:45:27 $


decl    dwf_debug_filename;
decl    dwf_debug_fp;

dwf_debug_filename = "debuglog.dwf";
dwf_debug_fp = stderr;

defun dwf_pptokens (var)             // pretty-printer for debugging
{
    decl        msg;

    if (!dwf_debug_fp)
    {
        dwf_debug_fp = fopen(dwf_debug_filename, "w");
    }
    msg = identify_value(fmt_tokens(var));
    fputs(dwf_debug_fp, msg);
    fflush(dwf_debug_fp);
    // Also send the string to stderr ...
    //fputs(stderr, msg);
}


defun __single_channel_power(psd, channel_limits)
{
    decl indep_psd = indep(psd);
    if ( sweep_dim(psd) ==6 )
    {
       indep_psd =indep(psd[0,0,0,0,0,::]);
    }
    else if ( sweep_dim(psd) ==5 )
    {
       indep_psd =indep(psd[0,0,0,0,::]);
    }
    else if ( sweep_dim(psd) ==4 )
    {
       indep_psd =indep(psd[0,0,0,::]);
    }
    else if ( sweep_dim(psd) ==3 )
    {
       indep_psd =indep(psd[0,0,::]);
    }
    else if ( sweep_dim(psd) ==2 )
    {
       indep_psd =indep(psd[0,::]);
    }
    else indep_psd =indep(psd);

  decl dfreq = (1+1e-9)*(indep_psd[1]-indep_psd[0])/2;
  decl l_index=find(abs(indep_psd-channel_limits(1))<=dfreq);
  decl l_indexSwpSz=sweep_size(l_index);
  if (l_indexSwpSz > 1)
    l_index = l_index[0];
  else if (l_index < 0)
    l_index = 0;
  decl h_index=find(abs(indep_psd-channel_limits(2))<=dfreq);
  decl h_indexSwpSz=sweep_size(h_index);
  if (h_indexSwpSz > 1)
    h_index = h_index[h_indexSwpSz-1];
  else if (h_index < 0)
    h_index = sweep_size(indep_psd)-1;

  return sum(psd[l_index::h_index]);
} //fun - __single_channel_power

defun channel_power(psd, channel_limits)
{
  decl ch_pow = __single_channel_power(psd, channel_limits);
  return ch_pow;
}

// Adjacent Channel Power Ratio Measurement using voltage and current
defun __acpr(psd, mainCh, lowerAdjCh, upperAdjCh)
{ 
  decl main_channel_power, upper_adj_channel_power,  lower_adj_channel_power;
  decl upper_acpr, lower_acpr;
    
  main_channel_power = channel_power(psd, mainCh);
  lower_adj_channel_power = channel_power(psd, lowerAdjCh);
  upper_adj_channel_power = channel_power(psd, upperAdjCh);

  upper_acpr = 10*log(upper_adj_channel_power/main_channel_power);
  lower_acpr = 10*log(lower_adj_channel_power/main_channel_power);     

  return {lower_acpr, upper_acpr};
} //fun - __acpr

//************************************************************************
/*BEGIN_DOC
FUN_NAME: acpr_vi()
FUN_DESCRIPTION: Computes the adjacent-channel power ratio following a Circuit Envelope simulation
RETURNED_VALUE: Real
CATEGORY: Envelope
SYNTAX: ACPRvals = acpr_vi(voltage, current, mainCh, lowerAdjCh, upperAdjCh, winType, winConst)
EXAMPLE: 
VloadFund = vload[1]
IloadFund = iload.i[1]
mainlimits = {-16.4 kHz, 16.4 kHz}
UpChlimits = {mainlimits + 30 kHz}
LoChlimits = {mainlimits - 30 kHz}
TransACPR = acpr_vi(VloadFund, IloadFund, mainlimits, LoChlimits, UpChlimits, "Kaiser") 

where vload is the named connection at a load, and iload.i is the name of the current probe that samples the current into the node. The {} braces are used to define vectors, and the upper channel limit and lower channel limit frequencies do not need to be defined by means of the vector that defines the main channel limits. 

examples/RF_Board/NADC_PA_wrk/NADC_PA_ACPRtransmitted.dds 

ARGUMENT
  ARG_NAME: voltage
  ARG_DESCRIPTION: single complex voltage spectral component (for example, the fundamental) across a load versus time
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: current
  ARG_DESCRIPTION: single complex current spectral component into the same load versus time
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: mainCh
  ARG_DESCRIPTION: two-dimensional vector defining the main channel frequency limits (as an offset from the single voltage and current spectral component)
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: lowerAdjCh
  ARG_DESCRIPTION: the two-dimensional vector defining the lower adjacent-channel frequency limits (as an offset from the single voltage and current spectral component);
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: upperAdjCh
  ARG_DESCRIPTION: two-dimensional vector defining the upper adjacent channel frequency limits (as an offset from the single voltage and current spectral component); 
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: winType
  ARG_DESCRIPTION: window type
  ARG_DEFAULT: None
  ARG_RANGE: dagger.gif
  ARG_TYPE: string
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: winConst
  ARG_DESCRIPTION: window constant that affects the shape of the applied window.
  ARG_DEFAULT: 0.75
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: NO
FOOTNOTES: dagger.gif winType can be: "none", "hamming", "hanning", "gaussian", "kaiser", "8510", "blackman","blackman-harris"
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: acpr_vr(), channel_power_vi(), channel_power_vr(), relative_noise_bw() 
NOTES:
Used in Adjacent-channel power computations 

The user must supply a single complex voltage spectral component (for example, the fundamental) across a load versus time and a single complex current spectral component into the same load. The user must also supply the upper and lower adjacent-channel and main-channel frequency limits, as offsets from the spectral component frequency of the voltage and current.  These frequency limits must be entered as two-dimensional vectors. An optional window and window constant may also be supplied, for use in processing non-periodic data. 

EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/

//************************************************************************
defun acpr_vi(voltage, current, mainCh, lowerAdjCh, upperAdjCh, winType, winConst)
{
   decl vsd, isd, psd;
   decl l_index, h_index;
   decl main_channel_power, upper_adj_channel_power,  lower_adj_channel_power;
   decl acpr;
   decl indep_psd;

   // relative noise bandwidth compensation:
   decl rel_noise_bw = relative_noise_bw(winType, winConst);

   // Power spectral density calculation at power amplifier output
   vsd = fs(voltage,,,,,winType,winConst);
   isd = fs(current,,,,,winType,winConst);

   psd = 0.5*real(vsd*conj(isd))/rel_noise_bw;

   return __acpr(psd, mainCh, lowerAdjCh, upperAdjCh);
} //fun - acpr_vi


//************************************************************************
// Adjacent Channel Power Ratio Measurement using voltage and resistance
//************************************************************************
/*BEGIN_DOC
FUN_NAME: acpr_vr()
FUN_DESCRIPTION: Computes the adjacent-channel power ratio following a Circuit Envelope simulation.
RETURNED_VALUE: Real
CATEGORY: Envelope
SYNTAX: ACPRvals = acpr_vr(voltage, resistance, mainCh, lowerAdjCh, upperAdjCh, winType, winConst) 
EXAMPLE: 
Vfund = vOut[1]
mainlimits = {-(1.2288 MHz/2), (1.2288 MHz/2)}
UpChlimits = {885 kHz, 915 kHz}
LoChlimits = {-915 kHz, -885 kHz}
TransACPR = acpr_vr(VloadFund, 50, mainlimits, LoChlimits, UpChlimits, "Kaiser") 

where vOut is the named connection at a resistive load. The {} braces are used to define vectors. 

Note    vOut is a named connection on the schematic. Assuming that a Circuit Envelope simulation was run, vOut is output to the dataset as a two-dimensional matrix. The first dimension is time, and there is a value for each time point in the simulation. The second dimension is frequency, and there is a value for each fundamental frequency, each harmonic, and each mixing term in the analysis, as well as the baseband term.

vOut[1] is the equivalent of vOut[::, 1], and specifies all time points at the lowest non-baseband frequency (the fundamental analysis frequency, unless a multitone analysis has been run and there are mixing products). For former MDS users, the notation "vOut[*, 2]" in MDS corresponds to the notation of "vOut[1]".

examples/Tutorial/ModSources_wrk/IS95RevLinkSrc.dds 

ARGUMENT
  ARG_NAME: voltage
  ARG_DESCRIPTION: single complex voltage spectral component (for example, the fundamental) across a load versus time
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: resistance
  ARG_DESCRIPTION: load resistance in ohms
  ARG_DEFAULT: 50
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: mainCh
  ARG_DESCRIPTION: two-dimensional vector defining the main channel frequency limits (as an offset from the single voltage spectral component)
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: lowerAdjCh
  ARG_DESCRIPTION: the two-dimensional vector defining the lower adjacent-channel frequency limits (as an offset from the single voltage spectral component);
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: upperAdjCh
  ARG_DESCRIPTION: two-dimensional vector defining the upper adjacent channel frequency limits (as an offset from the single voltage spectral component); 
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: winType
  ARG_DESCRIPTION: window type
  ARG_DEFAULT: None
  ARG_RANGE: dagger.gif
  ARG_TYPE: string
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: winConst
  ARG_DESCRIPTION: window constant that affects the shape of the applied window.
  ARG_DEFAULT: 0.75
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: NO
FOOTNOTES: dagger.gif winType can be: "none", "hamming", "hanning", "gaussian", "kaiser", "8510", "blackman","blackman-harris"
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: acpr_vi(), channel_power_vi(), channel_power_vr(), relative_noise_bw() 
NOTES:
Used in Adjacent-channel power computations 

The user must supply a single complex voltage spectral component (for example, the fundamental) across a resistive load versus time and the load resistance. The user must also supply the upper and lower adjacent-channel and main-channel frequency limits, as offsets from the spectral component frequency of the voltage. These frequency limits must be entered as two-dimensional vectors. An optional window and window constant may also be supplied, for use in processing non-periodic data. 

EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/

defun acpr_vr(voltage, resistance, mainCh, lowerAdjCh, upperAdjCh, winType, winConst)
{
  decl vsd, psd;
  decl l_index, h_index;
  decl main_channel_power, upper_adj_channel_power,  lower_adj_channel_power;
  decl upper_acpr, lower_acpr;
  decl indep_psd;

  // relative noise bandwidth compensation:
  decl rel_noise_bw = relative_noise_bw(winType, winConst);

  // Power spectral density calculation at power amplifier output
  vsd = fs(voltage,,,,,winType,winConst);

  psd = 0.5*mag(vsd**2)/resistance/rel_noise_bw;
    
  return __acpr(psd, mainCh, lowerAdjCh, upperAdjCh);
} //fun - acpr_vr

//************************************************************************
// Channel Power Measurement using voltage and current
/*BEGIN_DOC
FUN_NAME: channel_power_vi()
FUN_DESCRIPTION: Computes the power (in watts) in an arbitrary frequency channel following a Circuit Envelope simulation. 
RETURNED_VALUE: Real
CATEGORY: Envelope
SYNTAX: Channel_power = channel_power_vi(voltage, current, mainCh, winType, winConst) 
EXAMPLE: 
VloadFund = vload[1]
IloadFund = iload.i[1]
mainlimits = {-16.4 kHz, 16.4 kHz}
Main_Channel_Power = channel_power_vi(VloadFund, IloadFund, mainlimits, "Kaiser") 

where vload is the named connection at a load, and iload.i is the name of the current probe that samples the current into the node. The {} braces are used to define a vector. Note that the computed power is in watts. Use the following equation to convert the power to dBm.

Main_Channel_Power_dBm = 10 * log(Main_Channel_Power) + 30 

Do not use the dBm function, which operates on voltages. 

examples/RF_Board/NADC_PA_wrk/NADC_PA_ACPRtransmitted.dds 

ARGUMENT
  ARG_NAME: voltage
  ARG_DESCRIPTION: single complex voltage spectral component (for example, the fundamental) across a load versus time
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: current
  ARG_DESCRIPTION: single complex current spectral component into the same load versus time
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: mainCh
  ARG_DESCRIPTION: two-dimensional vector defining channel frequency limits (as an offset from the single voltage and current spectral component dagger.gif
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: winType
  ARG_DESCRIPTION: window type
  ARG_DEFAULT: None
  ARG_RANGE: dagger.gif
  ARG_TYPE: string
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: winConst
  ARG_DESCRIPTION: window constant that affects the shape of the applied window.
  ARG_DEFAULT: 0.75
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: NO
FOOTNOTES: dagger.gif note that these frequency limits do not have to be centered on the voltage and current spectral component frequency. 
dagger.gif winType can be: "none", "hamming", "hanning", "gaussian", "kaiser", "8510", "blackman","blackman-harris"
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: acpr_vi(), acpr_vr(), channel_power_vr()
NOTES:
Used in Channel power computations 

The user must supply a single complex voltage spectral component (for example, the fundamental) across a load versus time, and a single complex current spectral component into the same load. The user must also supply the channel frequency limits, as offsets from the spectral component frequency of the voltage and current. These frequency limits must be entered as a two-dimensional vector. An optional window and window constant may also be supplied, for use in processing non-periodic data. 

EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/

//************************************************************************
defun channel_power_vi(voltage, current, mainCh, winType, winConst)
{
     decl vsd, isd, psd, mainCh_limits;
     decl time = indep(voltage,1);
     
     // First time sweep is used to calculate time step.  Time step is not
     // assumed to be a function of the outer sweep variable.
     if (sweep_dim(time) >1)
     	 time = time[0,::];
    
     decl time_step = time[1] -time[0];
          
     // relative noise bandwidth compensation:
     decl rel_noise_bw = relative_noise_bw(winType, winConst);

     // Power spectral density calculation at power amplifier output
     vsd = fs(voltage,,,,,winType,winConst);
     isd = fs(current,,,,,winType,winConst);

     psd = 0.5*real(vsd*conj(isd))/rel_noise_bw;
 
     if (mainCh == NULL)
         mainCh_limits={-0.5/time_step,0.5/time_step};
     else
     	 mainCh_limits=mainCh;    
     	    
     // channel power returned as a 1 length vector
     return {channel_power(psd,mainCh_limits)};
}


//****************************************************************************
// Channel Power Measurement using voltage and resistance
/*BEGIN_DOC
FUN_NAME: channel_power_vr()
FUN_DESCRIPTION: Computes the power (in watts) in an arbitrary frequency channel following a Circuit Envelope simulation. 
RETURNED_VALUE: Real
CATEGORY: Envelope
SYNTAX: Channel_power = channel_power_vr(voltage, resistance, mainCh, winType, winConst) 
EXAMPLE: 
Vmain_fund = Vmain[1]
mainlimits = {-16.4 kHz, 16.4 kHz}
Main_Channel_Power = channel_power_vr(Vmain_fund, 50, mainlimits, "Kaiser") 

where Vmain is the named connection at a resistive load (50 ohms in this case.) The {} braces are used to define a vector. Note that the computed power is in watts. Use the equation 

Main_Channel_Power_dBm = 10 * log(Main_Channel_Power) + 30 

to convert the power to dBm. Do not use the dBm function, which operates on voltages. 

Example file 

examples/RF_Board/NADC_PA_wrk/NADC_PA_ACPRreceived.dds

ARGUMENT
  ARG_NAME: voltage
  ARG_DESCRIPTION: single complex voltage spectral component (for example, the fundamental) across a load versus time
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: resistance
  ARG_DESCRIPTION: load resistance in ohms
  ARG_DEFAULT: 50
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: mainCh
  ARG_DESCRIPTION: two-dimensional vector defining the main channel frequency limits (as an offset from the single voltage spectral component) dagger.gif
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: winType
  ARG_DESCRIPTION: window type
  ARG_DEFAULT: None
  ARG_RANGE: dagger.gif dagger.gif
  ARG_TYPE: string
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: winConst
  ARG_DESCRIPTION: window constant that affects the shape of the applied window.
  ARG_DEFAULT: 0.75
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: NO
FOOTNOTES: dagger.gif note that these frequency limits do not have to be centered on the voltage and current spectral component frequency
dagger.gif dagger.gif winType can be: "none", "hamming", "hanning", "gaussian", "kaiser", "8510", "blackman","blackman-harris"
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: acpr_vi(), acpr_vr(), channel_power_vi()
NOTES:
Used in Channel power computations 

The user must supply a single complex voltage spectral component (for example, the fundamental) across a load versus time and the resistance of the load. The user must also supply the channel frequency limits, as offsets from the spectral component frequency of the voltage.  These frequency limits must be entered as a two-dimensional vector. An optional window and window constant may also be supplied, for use in processing non-periodic data. 

EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/

//***************************************************************************
defun channel_power_vr(voltage, resistance, mainCh, winType, winConst)
{
     decl vsd, psd, mainCh_limits;
     decl time = indep(voltage,1);
     
     // First time sweep is used to calculate time step.  Time step is not
     // assumed to be a function of the outer sweep variable.
     if (sweep_dim(time) >1)
     	 time = time[0,::];
    
     decl time_step = time[1] -time[0];
 
     // relative noise bandwidth compensation:
     decl rel_noise_bw = relative_noise_bw(winType, winConst);

     // Power spectral density calculation at power amplifier output
     vsd = fs(voltage,,,,,winType,winConst);

     psd = 0.5*mag(vsd**2)/resistance/rel_noise_bw;
     
     if (mainCh == NULL)
         mainCh_limits={-0.5/time_step,0.5/time_step};
     else
     	 mainCh_limits=mainCh;    
     	
     // channel power returned as a 1 length vector
     return {channel_power(psd,mainCh_limits)};
}


//**************************************************************************
defun __single_constellation(i_data, q_data, symbol_rate, delay)
{
  decl start_time = if (delay) then delay else 0.0;
  decl stop_time = max(indep(i_data));

  decl incr;
  
  if (symbol_rate)
    incr = 1/symbol_rate;
    
  decl interp_i_data = interp(i_data,start_time,stop_time,incr);
  decl interp_q_data = interp(q_data,start_time,stop_time,incr);
    
  // package the result up for plotting
  return vs(interp_q_data, interp_i_data);
} // __single_constellation

defun __constellation_2D(i_data, q_data, symbol_rate, delay)
{
  decl constell;
  // outer independent
  decl outer_indep = indep(i_data,2);
  // clone result so it has correct outer indep and size
  decl temp = __single_constellation(i_data[0,::], q_data[0,::], symbol_rate, delay);
  constell=i_data[::,0::1/(sweep_size(temp)-1)::1];
  decl indep_constell = indep(constell);
  constell[0,::]=temp;
  indep_constell[0,::]=indep(temp);

  // calculate each entry        
  decl i;
  for ( i=1; i<sweep_size(outer_indep); i++) {
    temp = __single_constellation(i_data[i,::], q_data[i,::], symbol_rate, delay);
    constell[i,::] = temp;
    indep_constell[i,::]=indep(temp);
  }
  return constell;
} //fun - __constellation_2D
//************************************************************************
/*BEGIN_DOC
FUN_NAME: constellation()
FUN_DESCRIPTION: Generates the constellation diagram from Circuit Envelope, Transient, or Ptolemy simulation I and Q data.
RETURNED_VALUE: Real
CATEGORY: Transient, Envelope
SYNTAX: Const = constellation(i_data, q_data, symbol_rate, delay) 
EXAMPLE: 

Rotation = -0.21
Vfund =vOut[1] * exp(j * Rotation)
delay =1/sym_rate[0, 0] - 0.5 * tstep[0, 0]
Vimag = imag(Vfund)
Vreal = real(Vfund)
Const = constellation(Vreal, Vimag, sym_rate[0, 0], delay) 

where Rotation is a user-selectable parameter that rotates the constellation by that many radians, and vOut is the named connection at a node. The parameter delay can be a numeric value, or in this case an equation using sym_rate, the symbol rate of the modulated signal, and tstep, the time step of the simulation. If these equations are to be used in a Data Display window, sym_rate and tstep must be defined by means of a variable (VAR) component, and they must be passed into the dataset as follows: Make the parameter Other visible on the Envelope simulation component, and edit it so that 

Other = OutVar = sym_rate OutVar = tstep 

In some cases, it may be necessary to experiment with the value of delay to get the constellation diagram with the tightest points. 

Note    vOut is a named connection on the schematic. Assuming that a Circuit Envelope simulation was run, vOut is output to the dataset as a two-dimensional matrix. The first dimension is time, and there is a value for each time point in the simulation.  The second dimension is frequency, and there is a value for each fundamental frequency, each harmonic, and each mixing term in the analysis, as well as the baseband term.

vOut[1] is the equivalent of vOut[::, 1], and specifies all time points at the lowest non-baseband frequency (the fundamental analysis frequency, unless a multitone analysis has been run and there are mixing products). For former MDS users, the notation "vOut[*, 2]" in MDS corresponds to the notation of "vOut[1]". 

ARGUMENT
  ARG_NAME: i_data
  ARG_DESCRIPTION: in-phase component of data versus time of a single complex voltage spectral component (for example, the fundamental) dagger.gif
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: q_data
  ARG_DESCRIPTION: quadrature-phase component of data versus time of a single complex voltage spectral component (for example, the fundamental) dagger.gif
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: symbol_rate
  ARG_DESCRIPTION: symbol rate of the modulation signal
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: delay
  ARG_DESCRIPTION: delay value dagger.gif dagger.gif
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: NO
FOOTNOTES:  dagger.gif this could be a baseband signal instead, but in either case it must be real-valued versus time.
dagger.gif dagger.gif (if nonzero) throws away the first delay = N seconds of data from the constellation plot. It is also used to interpolate between simulation time points, which is necessary if the optimal symbol-sampling instant is not exactly at a simulation time point. Usually this parameter must be nonzero to generate a constellation diagram with the smallest grouping of sample points.
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: const_evm()
NOTES: Used in Constellation diagram generation. 

The I and Q data do not need to be baseband waveforms. For example, they could be the in-phase (real or I) and quadrature-phase (imaginary or Q) part of a modulated carrier. The user must supply the I and Q waveforms versus time, as well as the symbol rate. 

The i_data and q_data must be of the same dimension, and upto 5-dimensional data is supported. 

The result of a constellation calculation using the constellation() function may be plotted directly on a rectangular plot.  For example, you may add Const directly to a rectangular plot, where Const=constellation(Vreal,Vimag,sym_rate,delay).  If you want to plot Const on a polar plot, then add to the plot indep(Const)+j*Const. 

EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/
//*************************************************************************************
defun constellation(i_data, q_data, symbol_rate, delay)
{
  decl constell;
  decl i_sweep_dim = sweep_dim(i_data);
  decl q_sweep_dim = sweep_dim(q_data);

  if ( i_sweep_dim != q_sweep_dim )
    print_function_error("constellation","I and Q must have the same dimensionality");

  decl iCount=0;
  if ( i_sweep_dim == 1 )
    constell = __single_constellation(i_data, q_data, symbol_rate, delay);
  else if ( i_sweep_dim == 2 ) {
    constell = __constellation_2D(i_data, q_data, symbol_rate, delay);
  }
  else if (i_sweep_dim == 3) {
    decl iCount2=0;
    decl sSz = sweep_size(i_data);
    decl iSz1 = sSz(1);
    decl iSz2 = sSz(2);
    decl temp = __single_constellation(i_data[0,0,::], q_data[0,0,::], symbol_rate, delay);
    constell=i_data[::,::,0::1/(sweep_size(temp)-1)::1];
    decl indep_constell = indep(constell);

    for (iCount = 0; iCount < iSz1; iCount++)
      for (iCount2 = 0; iCount2 < iSz2; iCount2++) {
	decl const1D = __single_constellation(i_data[iCount,iCount2,::], q_data[iCount,iCount2,::], symbol_rate, delay);
        constell[iCount,iCount2,::] = const1D;
        indep_constell[iCount,iCount2,::] = indep(const1D);
      }
  }
  else if (i_sweep_dim == 4) {
    decl iCount2=0, iCount3=0;
    decl sSz = sweep_size(i_data);
    decl iSz1 = sSz(1);
    decl iSz2 = sSz(2);
    decl iSz3 = sSz(3);
    decl temp = __single_constellation(i_data[0,0,0,::], q_data[0,0,0,::], symbol_rate, delay);
    constell=i_data[::,::,::,0::1/(sweep_size(temp)-1)::1];
    decl indep_constell = indep(constell);

    for (iCount = 0; iCount < iSz1; iCount++)
      for (iCount2 = 0; iCount2 < iSz2; iCount2++)
        for (iCount3 = 0; iCount3 < iSz3; iCount3++) {
  	  decl const1D = __single_constellation(i_data[iCount,iCount2,iCount3,::], q_data[iCount,iCount2,iCount3,::], symbol_rate, delay);
          constell[iCount,iCount2,iCount3,::] = const1D;
          indep_constell[iCount,iCount2,iCount3,::] = indep(const1D);
        }
  }
  else if (i_sweep_dim == 5) {
    decl iCount2=0, iCount3=0, iCount4=0;
    decl sSz = sweep_size(i_data);
    decl iSz1 = sSz(1);
    decl iSz2 = sSz(2);
    decl iSz3 = sSz(3);
    decl iSz4 = sSz(4);
    decl temp = __single_constellation(i_data[0,0,0,0,::], q_data[0,0,0,0,::], symbol_rate, delay);
    constell=i_data[::,::,::,::,0::1/(sweep_size(temp)-1)::1];
    decl indep_constell = indep(constell);

    for (iCount = 0; iCount < iSz1; iCount++)
      for (iCount2 = 0; iCount2 < iSz2; iCount2++)
        for (iCount3 = 0; iCount3 < iSz3; iCount3++)
          for (iCount4 = 0; iCount4 < iSz4; iCount4++) {
  	    decl const1D = __single_constellation(i_data[iCount,iCount2,iCount3,iCount4,::], q_data[iCount,iCount2,iCount3,iCount4,::], symbol_rate, delay);
            constell[iCount,iCount2,iCount3,iCount4,::] = const1D;
            indep_constell[iCount,iCount2,iCount3,iCount4,::] = indep(const1D);
          }
  }
  else
    print_function_error("constellation","This function can only operate on upto 5-dimensional data.");

  set_attr(constell,"TraceType","Scatter");
  return constell;
} //fun - constellation


//*************************************************************************************
/*BEGIN_DOC
FUN_NAME: trajectory()
FUN_DESCRIPTION: Generates the trajectory diagram from I and Q data, which are usually produced by a Circuit Envelope simulation. 
RETURNED_VALUE: Complex
CATEGORY: Envelope
SYNTAX: Traj = trajectory(i_data, q_data)
EXAMPLE:
Rotation = -0.21 
Vfund=vOut[1] *exp(j * Rotation) 
Vimag = imag(Vfund) 
Vreal = real(Vfund) 
Traj = trajectory(Vreal, Vimag) 

where Rotation is a user-selectable parameter that rotates the trajectory diagram by that many radians and vOut is the named connection at a node. 

Note    vOut is a named connection on the schematic. Assuming that a Circuit Envelope
simulation was run, vOut is output to the dataset as a two-dimensional matrix. The first dimension is time, and there is a value for each time point in the simulation. The second dimension is frequency, and there is a value for each fundamental frequency, each harmonic, and each mixing term in the analysis, as well as the baseband term.

vOut[1] is the equivalent of vOut[::, 1], and specifies all time points at the lowest non-baseband frequency (the fundamental analysis frequency, unless a multitone analysis has been run and there are mixing products). For former MDS users, the notation "vOut[*, 2]" in MDS corresponds to the notation of "vOut[1]".
ARGUMENT
  ARG_NAME: i_data
  ARG_DESCRIPTION: in-phase component of data versus time of a single complex voltage spectral component (for example, the fundamental) dagger.gif
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: q_data
  ARG_DESCRIPTION: quadrature-phase component of data versus time of a single complex voltage spectral component (for example, the fundamental) dagger.gif
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
FOOTNOTES: dagger.gif This could be a baseband signal instead, but in either case it must be real valued versus time.
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: constellation(), const_evm()
NOTES:
Used in Trajectory diagram generation 

The I and Q data do not need to be baseband waveforms. For example, they could be the
in-phase (real or I) and quadrature-phase (imaginary or Q) part of a modulated carrier. The user must supply the I and Q waveforms versus time. 
EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/

defun trajectory(i_data, q_data)
{
    return vs(q_data, i_data);
}


defun eye_t(data, symbol_rate, Cycles, delay)
{
    return eye(data, symbol_rate, Cycles, delay);
}
   
//*************************************************************************************
/*BEGIN_DOC
FUN_NAME: relative_noise_bw()
FUN_DESCRIPTION: Computes the relative noise bandwidth of the smoothing windows used by the fs() function
RETURNED_VALUE: Real
CATEGORY: Envelope
SYNTAX: y = relative_noise_bw(winType, winConst)
EXAMPLE:
winType = "Kaiser"
winConst = 8
relNoiseBW = relative_noise_bw("Kaiser", 8) = 1.666
Vfund=vOut[1]
VoltageSpectralDensity = fs(Vfund, , , , , winType, winConst)
PowerSpectralDensity = 0.5 * mag(VoltageSpectralDensity**2)/50/relNoiseBW 

where vOut is the named connection at a 50-ohm load, and it is an output from a Circuit Envelope simulation. 

Note    vOut is a named connection on the schematic. Assuming that a Circuit Envelope simulation was run, vOut is output to the dataset as a two-dimensional matrix. The first dimension is time, and there is a value for each time point in the simulation. The second dimension is frequency, and there is a value for each fundamental frequency, each harmonic, and each mixing term in the analysis, as well as the baseband term.

vOut[1] is the equivalent of vOut[::, 1], and specifies all time points at the lowest non-baseband frequency (the fundamental analysis frequency, unless a multitone analysis has been run and there are mixing products). For former MDS users, the notation "vOut[*, 2]" in MDS corresponds to the notation of "vOut[1]".
ARGUMENT
  ARG_NAME: winType
  ARG_DESCRIPTION: window type
  ARG_DEFAULT: None
  ARG_RANGE: dagger.gif
  ARG_TYPE: string
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: winConst
  ARG_DESCRIPTION: window constant that affects the shape of the applied window.
  ARG_DEFAULT: 0.75
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: NO
FOOTNOTES: dagger.gif winType can be: "none", "hamming", "hanning", "gaussian", "kaiser", "8510", "blackman","blackman-harris"
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: acpr_vi(), acpr_vr(), channel_power_vi(), channel_power_vr(), fs()
NOTES:
Used in The following functions: acpr_vi, acpr_vr, channel_power_vi, channel_power_vr. 

The relative noise bandwidth function is used to account for the fact that as windows are applied, the effective noise bandwidth increases with respect to the normal resolution bandwidth. The resolution bandwidth is determined by the time span and not by the displayed frequency resolution. 
EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/

defun relative_noise_bw(u_window, window_constant)
{
    // Window names should track the WindowList in time_to_freq.cxx
    decl NoWinName             ="none";
    decl HammingWinName        ="hamming";
    decl HanningWinName        ="hanning";
    decl GaussianWinName       ="gaussian";
    decl KaiserWinName         ="kaiser";
    decl NA8510WinName         ="8510";
    decl BlackmanWinName       ="blackman";
    decl BlackmanHarrisWinName ="blackman-harris";

    decl window = tolower(u_window);
    decl correction = 1.0;
   
    decl kaiser_correction_value =
 vs([1.0,1.004,1.047,1.137,1.247,1.359,1.467,1.569,1.666,1.758,1.845,1.929,2.009,2.086,2.161,2.233,2.303,2.371,2.437,2.502,2.564,2.857,3.123],
    [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,25,30.0]);
    
				  
    decl gaussian_correction_value = vs([1.0,1.32,1.527,1.761,1.883,2.007,2.256,2.507,5.013],
					[0,  0.5, 0.6,  0.7,  0.75, 0.8,  0.9,  1.0,  2.0  ]);
    
    if ( window == NULL || strcmp(window,NoWinName) == 0 )
	correction = 1.0;
    else if ( strcmp(window,HammingWinName) == 0)
   	correction = 1.363;
    else if ( strcmp(window,HanningWinName) == 0)
   	correction = 1.5;
    else if ( strcmp(window, GaussianWinName) == 0)
    {
	if ( window_constant == NULL) // not passed
	    correction = 1.883; // window_const = 0.75;
	else
	{
	    decl index = find_index(indep(gaussian_correction_value), window_constant);
	    correction = gaussian_correction_value[index];
	}
    }
    else if (strcmp(window, KaiserWinName) == 0)
    {
	if ( window_constant == NULL) // not passed
	    correction = 1.653; // window_const = 7.865;
	else
	{
	    decl index = find_index(indep(kaiser_correction_value), window_constant);
	    correction =  kaiser_correction_value[index];
	}
    }
    else if (strcmp(window, NA8510WinName) == 0)
	correction = 1.467; // Kaiser with const =6
    else if (strcmp(window, BlackmanWinName) == 0)
	correction = 1.727;
    else if (strcmp(window, BlackmanHarrisWinName) == 0)
	correction = 2.004;
    else
	print_function_error("relative_noise_bw","Parameter 1, 'window', is not recognized");
        
    return correction;
} //fun - relative_noise_bw

//***********************************************************************
/* calculate

     -- ideal constallation
     -- ideal trajectory
     -- distorted constellation
     -- evm vs time
     -- evm percent
*/

/*BEGIN_DOC
FUN_NAME: const_evm()
FUN_DESCRIPTION: Takes the results of a Circuit Envelope simulation and generates data for the ideal and distorted constellation and trajectory diagrams, 
as well as the error vector magnitude, in percent, and a plot of the error vector magnitude versus time. 

RETURNED_VALUE: Complex
CATEGORY: Envelope
SYNTAX: data = const_evm(vfund_ideal, vfund_dist, symbol_rate, sampling_delay, rotation, transient_duration, path_delay) 
EXAMPLE:
rotation = -0.21
sampling_delay = 1/sym_rate[0, 0] - 0.5 * tstep[0, 0]
vfund_ideal = vOut_ideal[1]
vfund_dist = vOut_dist[1]
symbol_rate = sym_rate[0, 0]
data = const_evm(vfund_ideal, vfund_dist, symbol_rate,,rotation) 

where the parameter sampling_delay can be a numeric value, or in this case an equation using sym_rate, the symbol rate of the modulated signal, and tstep, 
the time step of the simulation. If these equations are to be used in a Data Display window, sym_rate and tstep must be defined by means of a variable (VAR) component, 
and they must be passed into the dataset by the simulation controller. 

ARGUMENT
  ARG_NAME: vfund_ideal
  ARG_DESCRIPTION: single complex voltage spectral component (for example the fundamental) that is ideal (undistorted). This could be constructed from two baseband signals instead, by using the function cmplx().
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: vfund_dist
  ARG_DESCRIPTION: single complex voltage spectral component (for example, the fundamental) that has been distorted by the network being simulated. This could be constructed from two baseband signals instead, by using the function cmplx()
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: symbol_rate
  ARG_DESCRIPTION: symbol rate of the modulation signal
  ARG_DEFAULT: simulation time step
  ARG_RANGE: [0:inf)
  ARG_TYPE: Integer, real
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: sampling_delay
  ARG_DESCRIPTION: sampling delay dagger.gif
  ARG_DEFAULT: computed from within the function
  ARG_RANGE: [0:inf)
  ARG_TYPE: Integer, real
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: rotation
  ARG_DESCRIPTION: parameter that rotates the constellations by this many radians dbldagr.gif
  ARG_DEFAULT: 0
  ARG_RANGE: [0:inf)
  ARG_TYPE: Integer, real
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: transient_duration
  ARG_DESCRIPTION: time in seconds that causes a corresponding integer number of symbols to be eliminated from the error-vector-magnitude calculation dbldagr.gif dagger.gif
  ARG_DEFAULT: 0
  ARG_RANGE: [0:inf)
  ARG_TYPE: Integer, real
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: path_delay
  ARG_DESCRIPTION: time in seconds of the sum of all delays in the signal path dbldagr.gif dbldagr.gif
  ARG_DEFAULT: computed from delay_path(vfund_ideal,vfund_dist) dbldagr.gif dbldagr.gif
  ARG_RANGE: [0:inf)
  ARG_TYPE: Integer, real
  ARG_REQUIRED: NO
FOOTNOTES: dagger.gif sampling_delay - (if nonzero) throws away the first delay = N seconds of data from the constellation and trajectory plots. It is also used 
to interpolate between simulation time points, which is necessary if the optimal symbol-sampling instant is not exactly at a simulation time point. Leave this field
blank to have the function find the optimal sampling delay.
dbldagr.gif rotation does not need to be entered, and it will not affect the error-vector-magnitude calculation, because both the ideal and distorted constellations will be rotated by the same amount. 
dbldagr.gif dagger.gif Usually the filters in the simulation have transient responses, and the error-vector-magnitude calculation should not start until these transient responses have finished. 
dbldagr.gif dbldagr.gif If this field is left blank, the function will compute the path delay by using the function delay_path(). 
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: constellation(), delay_path(), sample_delay_pi4dqpsk(), sample_delay_qpsk(), evm()
NOTES:
Note that const_evm returns a list of data. So in the above example, 

data[0]= ideal constellation
data[1]= ideal trajectory
data[2]= distorted constellation
data[3]= distorted trajectory
data[4]= error vector magnitude versus time
data[5]= percent error vector magnitude 

Please refer to the RF_Board/NADC_PA_wrk example file to see how these data are plotted. 

Used in constellation and trajectory diagram generation and error-vector-magnitude calculation.

The user must supply a single complex voltage spectral component (for example, the fundamental) that is ideal (undistorted), as well as a single complex voltage spectral component 
(for example, the fundamental) that has been distorted by the network being simulated. These ideal and distorted complex voltage waveforms could be generated from baseband I and Q data.
If computing the "raw" EVM (the EVM using every time point), we recommend setting the sampling_delay parameter to 0.  

The error vector magnitude is computed after correcting for the average phase difference and RMS amplitude difference between the ideal and distorted constellations. 

EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/
//***********************************************************************
defun const_evm(vfund_ideal, vfund_dist, u_symbol_rate, 
		u_sample_delay, u_rotation, u_transient_duration, u_path_delay)
{

    if ( vfund_ideal == NULL || vfund_dist == NULL )
	 return;

	decl symbol_rate = u_symbol_rate == NULL ? 0 : u_symbol_rate;
    decl transient_duration = u_transient_duration == NULL ? 0 : u_transient_duration;
	decl tran_time = 0; 											
    if ( transient_duration ) 										// skip integer number of symbols
		tran_time = ceil(mag(transient_duration)*symbol_rate)/symbol_rate;
    decl sample_delay = u_sample_delay == NULL ? best_delay_1d(vfund_ideal,symbol_rate,tran_time) : u_sample_delay;

    decl rotation =  u_rotation == NULL ? 0 : u_rotation;
	decl Path_Delay_default = delay_path(vfund_ideal,vfund_dist);
    decl path_delay = u_path_delay == NULL ? Path_Delay_default[0] : u_path_delay;   // This is a better default than 0.
    
    vfund_ideal = vfund_ideal*exp(j*rotation);
	vfund_dist = vfund_dist*exp(j*rotation);
    decl vfund_ideal_real = real(vfund_ideal);
    decl vfund_ideal_imag = imag(vfund_ideal);
	decl vfund_dist_real = real(vfund_dist);
    decl vfund_dist_imag = imag(vfund_dist);
	decl time_values = indep(vfund_ideal);
	decl time_step = time_values[1]-time_values[0];	
	decl i;
	decl numPts_i=9;
	decl min_time_offset = -0.5*time_step;
	decl time_offset;
	decl best_evm_rms = 1000;  // initialized as an arbitrary large number
	decl evm_rms_this_trial;
	decl evm_percent;
	decl best_mean_phase_delta;
	decl best_vfund_C_dist;
	decl best_evm;

    // Ideal trajectory
    decl ideal_trajectory = vs(vfund_ideal_imag, vfund_ideal_real);

    // set interpolation points
    decl start_time = sample_delay;                                 // removed + tran_time;
    decl stop_time = max(indep(vfund_ideal));
    decl incr = NULL;
    if (symbol_rate)
		incr = 1/symbol_rate;

    // Ideal constellation
    decl vfund_C_ideal_real = interp(vfund_ideal_real, start_time, stop_time, incr);
    decl vfund_C_ideal_imag = interp(vfund_ideal_imag, start_time, stop_time, incr);
    decl vfund_C_ideal = vfund_C_ideal_real+j*vfund_C_ideal_imag;
	decl vfund_C_ideal_rms = sqrt(mean(mag(vfund_C_ideal)**2));
	vfund_C_ideal = vfund_C_ideal/vfund_C_ideal_rms;
    decl ideal_constellation = vs(imag(vfund_C_ideal), real(vfund_C_ideal));
    set_attr(ideal_constellation,"TraceType","Scatter");

    for (i=0; i<numPts_i; i++)	// Loop to find minimum EVM
	{
		time_offset = min_time_offset + i*time_step/8;
		decl vfund_C_dist_real = interp(vfund_dist_real, start_time+path_delay+time_offset, stop_time, incr);    // this length may change with i.
		decl vfund_C_dist_imag = interp(vfund_dist_imag, start_time+path_delay+time_offset, stop_time, incr);    // this length may change with i.
		decl vfund_C_dist = vfund_C_dist_real +j*vfund_C_dist_imag;

		decl sn = min([sweep_size(vfund_C_dist_real), sweep_size(vfund_C_ideal_real)]);
		
		// phase compensation
		decl mean_phase_delta = __phase_delta_calc(vfund_C_ideal[0::sn-1], vfund_C_dist[0::sn-1]);
		vfund_C_dist =  (vfund_C_dist)*exp(-j*mean_phase_delta);
    
		// scaling
		decl scaling = sqrt(mean(mag(vfund_C_dist[0::sn-1])**2));   // Previously divided this by RMS value of ideal constellation, but this is now 1.
		vfund_C_dist = vfund_C_dist/scaling;
    
		// EVM
		decl evm = mag(vfund_C_dist[0::sn-1]-vfund_C_ideal[0::sn-1]);

		// EVM_percent
		evm_rms_this_trial = sqrt(mean(evm**2));   // This could be divided by the RMS value of the ideal constellation, but this is now 1.
		if (evm_rms_this_trial < best_evm_rms)
		{
			best_evm = evm;
			best_evm_rms = evm_rms_this_trial;
			best_mean_phase_delta = mean_phase_delta;
			best_vfund_C_dist = vfund_C_dist*scaling; 					// undoing the scaling to generate the distorted constellation
		}
		evm_percent = 100*best_evm_rms; // has to be calculated inside the loop because sn could change from one iteration to the next.
	}
	
    // distorted compensated trajectory (phase compensation only)
	vfund_dist=vfund_dist*exp(-j*best_mean_phase_delta);
    decl dist_trajectory = vs(imag(vfund_dist),real(vfund_dist));

    decl distorted_constellation = vs(imag(best_vfund_C_dist), real(best_vfund_C_dist));
    set_attr(distorted_constellation,"TraceType","Scatter");
    
    return list(ideal_constellation, ideal_trajectory, distorted_constellation, dist_trajectory, best_evm, evm_percent);
} //fun - const_evm

/* calculate

     -- EVM percent or rms
*/

/*BEGIN_DOC
FUN_NAME: evm()
FUN_DESCRIPTION: Takes the results of a Circuit Envelope simulation and computes the error vector magnitude, in percent or rms. 

RETURNED_VALUE: Real
CATEGORY: Envelope
SYNTAX: evm_percent = evm(vfund_ideal, vfund_dist, symbol_rate, sampling_delay, data_type_flag, interpolation_factor, search_limit) 
EXAMPLE:
vfund_ideal = vOut_ideal[1]
vfund_dist = vOut_dist[1]
symbol_rate = sym_rate[0, 0]
EVM_percent = evm(vfund_ideal, vfund_dist, symbol_rate,,"Percent") 

where sym_rate is the symbol rate of the modulated signal, which can be defined in a variable (VAR) component on a schematic and passed into the dataset via the Output tab on 
the simulation controller. 

ARGUMENT
  ARG_NAME: vfund_ideal
  ARG_DESCRIPTION: single complex voltage spectral component (for example the fundamental) that is ideal (undistorted). This could be constructed from two baseband signals instead, by using the function cmplx().
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: vfund_dist
  ARG_DESCRIPTION: single complex voltage spectral component (for example, the fundamental) that has been distorted by the network being simulated. This could be constructed from two baseband signals instead, by using the function cmplx()
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: symbol_rate
  ARG_DESCRIPTION: symbol rate of the modulation signal
  ARG_DEFAULT: the simulation time step
  ARG_RANGE: [0:inf)
  ARG_TYPE: Integer, real
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: sampling_delay
  ARG_DESCRIPTION: sampling delay dagger.gif
  ARG_DEFAULT: computed from within the function
  ARG_RANGE: [0:inf)
  ARG_TYPE: Integer, real
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: data_type_flag
  ARG_DESCRIPTION: if 0, "Percent", or "percent", the EVM will be returned as a percent.  Otherwise, EVM will be returned as an rms value.
  ARG_DEFAULT: 0
  ARG_RANGE: [0:inf)
  ARG_TYPE: Integer, string
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: interpolation_factor
  ARG_DESCRIPTION: increments of the simulation time step divided by this value are taken when determining the optimal sampling delay. dagger.gif
  ARG_DEFAULT: 8
  ARG_RANGE: [0:inf)
  ARG_TYPE: Integer, real
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: search_limit
  ARG_DESCRIPTION: this value multiplied by the simulation time step is the maximum trial sampling delay used when determining the optimal sampling delay. dbldagr.gif
  ARG_DEFAULT: 10
  ARG_RANGE: [0:inf)
  ARG_TYPE: Integer, real
  ARG_REQUIRED: NO
FOOTNOTES: dagger.gif sampling_delay - leave this field blank to let the function attempt to find the optimal sampling delay.  
If nonzero, this sets when the first sampling point is taken for generating the constellation of the ideal signal.  
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: constellation(), delay_path(), sample_delay_pi4dqpsk(), sample_delay_qpsk(), const_evm()
NOTES:

Computes error vector magnitude.  This function differs from the const_evm() function in that it only computes the EVM, and it works on data with up to 3 independent variables.

The user must supply a single complex voltage spectral component (for example, the fundamental) that is ideal (undistorted), as well as a single complex voltage spectral 
component (for example, the fundamental) that has been distorted by the network being simulated. These ideal and distorted complex voltage waveforms could be generated 
from baseband I and Q data.  The user must also supply the symbol rate.  Other parameters are optional.  If computing the "raw" EVM (the EVM using every time point), we 
recommend setting the sampling_delay parameter to 0.

The error vector magnitude (either percent or rms) is computed after correcting for the average phase difference and RMS amplitude difference between the ideal and 
distorted constellations. 

EXTERNAL: yes
AUTHOR: Keysight Technologies (AEH)
DATE: updated May 29, 2013
		updated April 3, 2017.  Now behaves similar to const_evm().  Also removed phase_delta_flag and corresponding section of code.
VERSION_CREATED: post ADS 2012.08
END_DOC*/
//***********************************************************************

defun evm(vfund_ideal, vfund_dist, u_symbol_rate, u_sample_delay, u_data_type_flag, u_interpolation_factor, u_search_limit)
{

    if ( vfund_ideal == NULL || vfund_dist == NULL )
	{
		print_function_error( "evm", "vfund_ideal and/or vfund_dist parameters are missing");
		return;
    }
	
    decl symbol_rate = u_symbol_rate == NULL ? 0 : u_symbol_rate;
	decl data_type_flag = u_data_type_flag == NULL ? 0 : u_data_type_flag;
	if (u_data_type_flag == "percent" || u_data_type_flag == "Percent" || u_data_type_flag == 0)   // if this flag is NULL, "percent", "Percent", or 0 then EVM in percent will be returned.  
	{																  						 // otherwise EVM in rms will be returned.
		data_type_flag=0;
	}
	else 
	{
		data_type_flag=1;
	}
    decl sweepDim = sweep_dim(vfund_ideal);
    decl results = NULL; 
   
    switch (sweepDim) {
    case 0: print_function_error( "evm", " does not support single number data.");
	return;
	break;
    case 1: results = evm_1d(vfund_ideal, vfund_dist, symbol_rate, u_sample_delay, data_type_flag, u_interpolation_factor, u_search_limit);
	break;
    case 2: results = evm_2d(vfund_ideal, vfund_dist, symbol_rate, u_sample_delay, data_type_flag, u_interpolation_factor, u_search_limit);	 
	break;
    case 3: results = evm_3d(vfund_ideal, vfund_dist, symbol_rate, u_sample_delay, data_type_flag, u_interpolation_factor, u_search_limit);
	break;
    default: print_function_error( "evm", " does not support data with dimensions greater than three.");
	return;
	break;
    }

    return results;
} // fun - evm
	
defun evm_1d(vfund_ideal, vfund_dist, symbol_rate, u_sample_delay, data_type_flag, u_interpolation_factor, u_search_limit)
{
	decl interpolation_factor = u_interpolation_factor == NULL ? 8 : int(u_interpolation_factor);
    decl search_limit = u_search_limit == NULL ? 10 : u_search_limit;
    decl sample_delay = u_sample_delay == NULL ? best_delay_1d(vfund_ideal,symbol_rate,0, interpolation_factor, search_limit) : u_sample_delay;
    decl vfund_ideal_real = real(vfund_ideal);
    decl vfund_ideal_imag = imag(vfund_ideal);
	decl vfund_dist_real = real(vfund_dist);
    decl vfund_dist_imag = imag(vfund_dist);
	
	decl time_values = indep(vfund_ideal);
	decl time_step = time_values[1]-time_values[0];
	decl i;
	decl numPts_i=interpolation_factor;
	decl path_delay = delay_path(vfund_ideal,vfund_dist);
	decl min_time_offset = -0.5*time_step;

    // set interpolation points
    decl start_time = sample_delay;              // removed + tran_time from RHS.
    decl stop_time = max(indep(vfund_ideal));
    decl incr = NULL;
    if (symbol_rate)
	incr = 1/symbol_rate;

    // ideal constellation
	decl vfund_C_ideal_real = interp(vfund_ideal_real, start_time, stop_time, incr);  // the "C" notation means now this is part of a constellation
	decl vfund_C_ideal_imag = interp(vfund_ideal_imag, start_time, stop_time, incr);  // the "C" notation means now this is part of a constellation
	decl vfund_C_ideal = vfund_C_ideal_real+j*vfund_C_ideal_imag;
	decl vfund_C_ideal_rms = sqrt(mean(mag(vfund_C_ideal)**2));
	vfund_C_ideal = vfund_C_ideal/vfund_C_ideal_rms;	// Replace the ideal signal with its original values normalized to its RMS value.
	
	// calculate initial EVM
	decl evm_0 = _evm_core(vfund_C_ideal, vfund_dist_real, vfund_dist_imag, start_time, stop_time, incr);
	decl best_evm_rms = evm_0[0];
	decl best_evm_percent = evm_0[1];	
	
	// if interpolation factor is set to a value >= 2, then execute the interpolation loop to look for a better EVM.
	if (interpolation_factor>=2)
	{
		decl evm_1 = evm_0;				// Just initializing variable evm_1
		decl time_offset_step = time_step/interpolation_factor;
		start_time = start_time+path_delay[0]+min_time_offset;
		for (i=0; i<numPts_i+1; i++)	// Loop to find minimum EVM
		{
			evm_1 = _evm_core(vfund_C_ideal, vfund_dist_real, vfund_dist_imag, start_time+i*time_offset_step, stop_time, incr);
			if (evm_1[0] < best_evm_rms)
			{
				best_evm_rms = evm_1[0];
				best_evm_percent = evm_1[1];
			}
		}
	}

    if (data_type_flag == 0)
	{
		return best_evm_percent;
	}
	else 
	{
		return best_evm_rms;
	}
} //fun - evm_1d
	
defun _evm_core(vfund_C_ideal, vfund_dist_real, vfund_dist_imag, start_time, stop_time, incr)
{
	decl vfund_C_dist_real = interp(vfund_dist_real, start_time, stop_time, incr);    
	decl vfund_C_dist_imag = interp(vfund_dist_imag, start_time, stop_time, incr);    
	decl vfund_C_dist = vfund_C_dist_real +j*vfund_C_dist_imag;
	decl sn = min([sweep_size(vfund_C_dist), sweep_size(vfund_C_ideal)]);
	
	// phase compensation
	
//	decl phase_delta = phase_dist - phase_ideal;
//	decl phase_delta_unwrapped1= if (phase_delta < -pi) then (phase_delta+2*pi) else phase_delta;
//	decl phase_delta_unwrapped = if (phase_delta_unwrapped1>pi) then phase_delta_unwrapped1 -2*pi else phase_delta_unwrapped1;

	decl mean_phase_delta = __phase_delta_calc(vfund_C_ideal[0::sn-1], vfund_C_dist[0::sn-1]);
	vfund_C_dist =  (vfund_C_dist)*exp(-j*mean_phase_delta);
    
	// scaling
	decl scaling = sqrt(mean(mag(vfund_C_dist[0::sn-1])**2));	// Could divide by the RMS value of vfund_C_ideal, but this should be 1.
   
	vfund_C_dist = vfund_C_dist/scaling;
    
	// EVM
	decl evm = mag(vfund_C_dist[0::sn-1]-vfund_C_ideal[0::sn-1]);

	// EVM_percent
	decl best_evm_rms = sqrt(mean(evm**2));
	decl evm_percent = 100*best_evm_rms;         
	return list(best_evm_rms,evm_percent);
}

defun evm_2d(vfund_ideal, vfund_dist, symbol_rate, u_sample_delay, data_type_flag, u_interpolation_factor, u_search_limit)
{
	decl evm_array = real(vfund_dist[0]);		// Initialize output array
	decl numPts_i = sweep_size(evm_array);
    decl i;

    for (i=0; i<numPts_i; i++)                       
    {
		evm_array[i] = evm_1d(vfund_ideal[i,::],vfund_dist[i,::],symbol_rate, u_sample_delay, data_type_flag, u_interpolation_factor, u_search_limit);
    }
	return evm_array;   
} // fun - evm_2d

defun evm_3d(vfund_ideal, vfund_dist, symbol_rate, u_sample_delay, data_type_flag, u_interpolation_factor, u_search_limit)
{
	decl evm_array = real(vfund_dist[0]);		// Initialize output array
	decl numPts_i = sweep_size(evm_array[0]);
    decl i;

    for (i=0; i<numPts_i; i++)                       
    {
		evm_array[i,::] = evm_2d(vfund_ideal[i,::,::],vfund_dist[i,::,::],symbol_rate, u_sample_delay, data_type_flag, u_interpolation_factor, u_search_limit);
    }
	return evm_array;   
} // fun - evm_3d

/* calculate

     -- Optimal sampling delay
*/

/*BEGIN_DOC
FUN_NAME: best_delay_1d()
FUN_DESCRIPTION: Takes the results of a Circuit Envelope simulation and determines the optimal sampling delay for the tightest constellation points. 

RETURNED_VALUE: Real
CATEGORY: Envelope
SYNTAX: best_delay_1d(vfund_ideal, symbol_rate, sample_delay, interpolation_factor, search_limit) 
EXAMPLE:

vfund_ideal = vOut_ideal[1]
symbol_rate = sym_rate[0, 0]
Best_Delay = (vfund_ideal, symbol_rate) 

where sym_rate is the symbol rate of the modulated signal, which can be defined in a variable (VAR) component on a schematic and passed into the dataset via the Output tab on 
the simulation controller.

ARGUMENT
  ARG_NAME: vfund_ideal
  ARG_DESCRIPTION: single complex voltage spectral component (for example the fundamental) that is ideal (undistorted). This could be constructed from two baseband signals instead, by using the function cmplx().
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: symbol_rate
  ARG_DESCRIPTION: symbol rate of the modulation signal
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Integer, real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: sampling_delay
  ARG_DESCRIPTION: sampling delay dagger.gif
  ARG_DEFAULT: 0
  ARG_RANGE: [0:inf)
  ARG_TYPE: Integer, real
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: interpolation_factor
  ARG_DESCRIPTION: increments of the simulation time step divided by this value are taken when determining the optimal sampling delay. dagger.gif
  ARG_DEFAULT: 8
  ARG_RANGE: [0:inf)
  ARG_TYPE: Integer, real
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: search_limit
  ARG_DESCRIPTION: this value multiplied by the simulation time step is the maximum trial sampling delay used when determining the optimal sampling delay. dbldagr.gif
  ARG_DEFAULT: 10
  ARG_RANGE: [0:inf)
  ARG_TYPE: Integer, real
  ARG_REQUIRED: NO
FOOTNOTES: dagger.gif sampling_delay - If nonzero, this sets when the first sampling point is taken for generating the constellation of the ideal signal.  
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: constellation(), delay_path(), sample_delay_pi4dqpsk(), sample_delay_qpsk(), evm()
NOTES:

Used in the const_evm() and evm() functions.
This function increases the sampling delay from 0 up to a maximum value (determined by the search_limit) variable to find the sampling delay that minimizes the 
standard deviation of the magnitude of the constellation points.  This should result in the "tightest" constellation points, in most cases.

EXTERNAL: yes
AUTHOR: Keysight Technologies (AEH)
DATE: Unknown
VERSION_CREATED: post ADS 2011.10
END_DOC*/
//***********************************************************************

defun best_delay_1d(vfund_ideal, symbol_rate, u_sample_delay, u_interpolation_factor, u_search_limit)
{
    if ( vfund_ideal == NULL )
	{
		print_function_error( "best_delay_1d", "vfund_ideal parameter is missing");
		return;
    }
	decl sample_delay = u_sample_delay == NULL ? 0 : u_sample_delay;
	decl interpolation_factor = u_interpolation_factor == NULL ? 8 : int(u_interpolation_factor);
    decl search_limit = u_search_limit == NULL ? 10 : u_search_limit;
	decl time_values = indep(vfund_ideal);
	decl time_step = time_values[1]-time_values[0];
	decl k;
	decl numPts_k=int(search_limit*interpolation_factor)+1;		// this value chosen for loop below that goes from 0 to search_limit*time_step in increments of time_step/interpolation_factor
	decl best_vfund_ideal_stddev = 1000;  				// initialized as an arbitrary large number
	decl best_delay = 0;
	decl vfund_ideal_stddev_this_trial = 1000;
	decl time_offset_ideal;

    decl start_time = sample_delay;              
    decl stop_time = max(indep(vfund_ideal));
    decl incr = NULL;
    if (symbol_rate)
	incr = 1/symbol_rate;

    // ideal constellation
	decl vfund_C_ideal_real_this_trial = interp(real(vfund_ideal), start_time, stop_time, incr);  // the "C" notation means now this is part of a constellation
	decl vfund_C_ideal_imag_this_trial = interp(imag(vfund_ideal), start_time, stop_time, incr);  // the "C" notation means now this is part of a constellation

	decl vfund_C_ideal_this_trial = vfund_C_ideal_real_this_trial+j*vfund_C_ideal_imag_this_trial;
	decl best_vfund_C_ideal_const = vfund_C_ideal_this_trial;   // initialize the result variable with the proper dimensions
	for (k=0; k<numPts_k; k++)  // Loop to find delay giving minimum stddev of magnitude of ideal constellation - the tightest constellation pts.
	{
		time_offset_ideal = k*time_step/8;
		vfund_C_ideal_real_this_trial = interp(real(vfund_ideal), start_time+time_offset_ideal, stop_time, incr);
		vfund_C_ideal_imag_this_trial = interp(imag(vfund_ideal), start_time+time_offset_ideal, stop_time, incr);
		vfund_C_ideal_this_trial = vfund_C_ideal_real_this_trial+j*vfund_C_ideal_imag_this_trial;
		vfund_ideal_stddev_this_trial = stddev(mag(vfund_C_ideal_this_trial));

		if (vfund_ideal_stddev_this_trial < best_vfund_ideal_stddev)
		{
			best_delay = time_offset_ideal;
			best_vfund_ideal_stddev = vfund_ideal_stddev_this_trial;
		} 
	}	
	return best_delay;     
}

//**************************************************************************************
// spur tracking functions
// spurious IF tone tracking
/*BEGIN_DOC
FUN_NAME: spur_track()
FUN_DESCRIPTION: Returns the maximum power of all signals appearing in a user-specifiable IF band, as a single RF input signal is stepped. If there is no IF signal appearing in the specified band, for a particular RF input frequency, then the function returns an IF signal power of -500 dBm. 
RETURNED_VALUE: Real
CATEGORY: Harmonic Balance
SYNTAX: IFspur = spur_track(vs(vout, freq), if_low, if_high, rout) 
EXAMPLE: IFspur = spur_track(vs(HB.VIF1, freq), Fiflow[0, 0], Fifhigh[0, 0], 50) 

where 

VIF1 is the named node at the IF output. 

Fiflow is the lowest frequency in the IF band. 

Fifhigh is the highest frequency in the IF band. 

50 is the IF load resistance. 

Fiflow and Fifhigh are passed parameters from the schematic page (although they can be defined on the data display page instead.) These parameters, although single-valued on the schematic, become matrices when passed to the dataset, where each element of the matrix has the same value. The [0, 0] syntax just selects one element from the matrix. 

ARGUMENT
  ARG_NAME: vout
  ARG_DESCRIPTION: IF output node name
  ARG_DEFAULT: None
  ARG_RANGE: None
  ARG_TYPE: String
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: if_low
  ARG_DESCRIPTION: lowest frequency in the IF band 
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: if_high
  ARG_DESCRIPTION: highest frequency in the IF band 
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: rout 
  ARG_DESCRIPTION: load resistance connected to the IF port, necessary for computing power delivered to the load
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: spur_track_with_if()
NOTES: Used in Receiver spurious response simulations 

IFspur computed above will be the power in dBm of the maximum signal appearing in the IF band, versus RF input frequency. Note that it would be easy to modify the function to compute dBV instead of dBm. 

This function is meant to aid in testing the response of a receiver to RF signals at various frequencies. This function shows the maximum power of all signals appearing in a user-specifiable IF band, as a single RF input signal is stepped. There could be fixed, interfering tones present at the RF input also, if desired. The maximum IF signal power may be plotted or listed versus the stepped RF input signal frequency. If there is no IF signal appearing in the specified band, for a particular RF input frequency, then the function returns an IF signal power of -500 dBm. 
EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/
//**************************************************************************************
defun spur_track(vout, if_low, if_high, rout)
{

    // power from voltage
    decl pout = dBm(vout,rout);
    decl harms = indep(vout,1);
    decl reduced_pout = if  ( !( harms < if_low || harms > if_high ) ) then pout else -500; 
 
    return vs(max(reduced_pout),indep(vout,2));

}

//**************************************************************************************
/*BEGIN_DOC
FUN_NAME: spur_track_with_if()
FUN_DESCRIPTION: Returns the maximum power of all signals appearing in a user-specifiable IF band, as a single RF input signal is stepped. In addition, it shows the IF frequencies and power levels of each signal that appears in the IF band, as well as the corresponding RF signal frequency. 
RETURNED_VALUE: Real
CATEGORY: Harmonic Balance
SYNTAX: IFspur = spur_track_with_if(vs(vout, freq), if_low, if_high, rout) 
EXAMPLE: IFspur=spur_track_with_if(vs(HB.VIF1, freq), Fiflow[0, 0], Fifhigh[0, 0], 50) 

where 

VIF1 is the named node at the IF output. 

Fiflow is the lowest frequency in the IF band. 

Fifhigh is the highest frequency in the IF band. 

50 is the IF load resistance. 

Fiflow and Fifhigh are passed parameters from the schematic page (although they can be defined on the data display page instead.) These parameters, although single-valued on the schematic, become matrices when passed to the dataset, where each element of the matrix has the same value. The [0, 0] syntax just selects one element from the matrix. 

ARGUMENT
  ARG_NAME: vout
  ARG_DESCRIPTION: IF output node name
  ARG_DEFAULT: None
  ARG_RANGE: None
  ARG_TYPE: String
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: if_low
  ARG_DESCRIPTION: lowest frequency in the IF band 
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: if_high
  ARG_DESCRIPTION: highest frequency in the IF band 
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: rout 
  ARG_DESCRIPTION: load resistance connected to the IF port, necessary for computing power delivered to the load
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: spur_track_with_if()
NOTES: Used in Receiver spurious response simulations 

IFspur computed above will be the power in dBm of the maximum signal appearing in the IF band, versus RF input frequency. Note that it would be easy to modify the function to compute dBV instead of dBm. 

This function is meant to aid in testing the response of a receiver to RF signals at various frequencies. This function, similar to the spur_track function, shows the maximum power of all signals appearing in a user-specifiable IF band, as a single RF input signal is stepped. In addition, it shows the IF frequencies and power levels of each signal that appears in the IF band, as well as the corresponding RF signal frequency. There could be fixed, interfering tones present at the RF input also, if desired. The maximum IF signal power may be plotted or listed versus the stepped RF input signal frequency. 

EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/
//**************************************************************************************
defun spur_track_with_if(vout, if_low, if_high, rout)
{

    // power from voltage
    //decl pout = 10*log(mag(pow(vout,2))/(2*rout))+30;
    decl pout = dBm(vout,rout);

    // RF freq is the outer independent
    decl rf_freq = indep(vout,2);
    decl n_rf_freq = sweep_size(rf_freq);
   
    // bracket the spectrum based on the IF band

    decl i,j,p;
    decl reduced_pout = create(2, "Real", {indep_name(vout,1),indep_name(vout)}, {"Real", "Real"}, 1,1);
    decl reduced_rf_freq = indep(reduced_pout,2);
    decl reduced_harms = indep(reduced_pout,1);

    for (i=0; i<n_rf_freq; i++)
    {
        decl pout_i=pout[i,::];
        decl harms = indep(pout_i);
        decl n_harms = sweep_size(harms);

        reduced_rf_freq[i] = rf_freq[i];
 
        for(j=0,p=0; j<n_harms; j++)
        {
            if  ( !( harms[j] < if_low || harms[j] > if_high ) ) 
            {
                reduced_pout[i,p] = pout_i[j];
                reduced_harms[i,p] = harms[j];  
                p++;
            } 

            if ( j == n_harms-1 && p == 0 )
            {
                reduced_pout[i,p] = -500;
                reduced_harms[i,p] = 0;
            }
        }
    } 

    return reduced_pout;
} //fun - spur_track_with_if

//***********************************************************************
/*BEGIN_DOC
FUN_NAME: cross_corr()
FUN_DESCRIPTION: Returns the cross-correlation
RETURNED_VALUE: Real
CATEGORY: Statistics
SYNTAX: y = cross_corr(v1, v2) 
EXAMPLE:
v1 = qpsk..videal[1]
v2 = qpsk..vout[1]
x_corr_v1v2 = cross_corr(v1, v2)
auto_corr_v1 = cross_corr(v1, v1) 
ARGUMENT
  ARG_NAME: v1
  ARG_DESCRIPTION: one-dimensional data
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: v2
  ARG_DESCRIPTION: one-dimensional data
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: None
NOTES: None
EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/
//***********************************************************************
defun cross_corr(s1, s2)
{ 
  if (sweep_dim(s1) > 1 || sweep_dim(s2) > 1)
  {
    print_function_error("cross_corr","This function is only valid for 1-Dimensional Data");
    return NULL;
  }

  // AELexpress.322, J. Yang
  s1 = s1 + j*0;
  s2 = s2 + j*0;

  decl len=min([sweep_size(s1),sweep_size(s2)]);
  decl i=0, slen=0;
  do
  {
    slen=2**i;
    i++;
  } while(slen<2*len);
  
  decl xcor=fft(fft(s1[0::len-1],slen)*conj(fft(s2[0::len-1],slen)));

  return xcor;
}

//***********************************************************************
/*BEGIN_DOC
FUN_NAME: delay_path()
FUN_DESCRIPTION: This function is used to determine the time delay and the constellation rotation angle between two nodal points along a signal path. 
RETURNED_VALUE: Real
CATEGORY: Envelope, Signal Processing
SYNTAX: y = delay_path(vin, vout) 
EXAMPLE:
x = delay_path(vin[1], vout[1]) 

where vin[1] and vout[1] are complex envelopes around the first carrier frequency in envelope simulation. In return, x[0] is the time delay (in seconds) between vin and vout. x[1] is the rotation angle (in radians) between vin and vout constellations. 

or 

x = delay_path(T1, T2) 

where T1 and T2 are instance names of two TimedSink components. 

ARGUMENT
  ARG_NAME: vin
  ARG_DESCRIPTION: envelope (I + j * Q) at the input node
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: vout
  ARG_DESCRIPTION: I + j * Q at the output node
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: ber_pi4dqpsk(), ber_qpsk(), const_evm(), cross_corr() 
NOTES:
Used in Circuit envelope simulation, Ptolemy simulation. 

This function outputs an array of two values. The first value, data[0], is the time delay between vin and vout. The second value, data[1], is the rotation angle between vin-constellation and vout-constellation. 

EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown, updated 17 April 2012
VERSION_CREATED: ADS 1.0
END_DOC*/

defun delay_path(src_data, sink_data)
{
    if (sweep_dim(src_data) != sweep_dim(sink_data))
    {
	print_function_error( "delay_path", "dimensionality of the src_data and sink_data parameters must be the same");
	return;
    }
    decl sweepDim = sweep_dim(src_data);
    decl results = NULL; 
   
    switch (sweepDim) {
    case 0: print_function_error( "delay_path", " does not support single number data.");
	return;
	break;
    case 1: results = delay_path_1d(src_data, sink_data);
	break;
    case 2: results = delay_path_2d(src_data, sink_data);	 
	break;
    case 3: results = delay_path_3d(src_data, sink_data);
	break;
    default: print_function_error( "delay_path", " does not support data with dimensions greater than three.");
	return;
	break;
    }

    return results;
} // fun - delay_path

defun delay_path_1d(src_data, sink_data)
{
  if (sweep_dim(src_data) > 1 || sweep_dim(sink_data) > 1)
  {
    print_function_error("delay_path","This function is only valid for 1-Dimensional Data");
    return NULL;
  }

  decl time_array = indep(src_data);
  decl tstep = time_array[1]-time_array[0];

  decl xcor = cross_corr(src_data, sink_data);
  decl h1 = max_index(mag(xcor));
  decl delay_p = h1*tstep;
  decl rot_rad = phaserad(xcor[h1]);
  return list(delay_p, rot_rad);
} // fun - delay_path_1d

defun delay_path_2d(src_data, sink_data)
{
	decl output_array=create(2,"Real",{"indepVar1","indepVar2"},{"Real","Real"}, 1, 1);  // this just initializes the result array.
	decl indepVar1=indep(output_array,"indepVar1");
    decl indepVar2=indep(output_array,"indepVar2");
	decl outerIndep=indep(src_data[::,0]);
	decl numPts_i = sweep_size(src_data[::,0]);
    decl i;

    for (i=0; i<numPts_i; i++)                       
    {
	decl temp = delay_path_1d(src_data[i,::],sink_data[i,::]);
	output_array[i,0] = temp[0];
	output_array[i,1] = temp[1];
	indepVar2[i,::] = 0;     // Any value would work here, as the delay_path_1d function just returns two values that are not a function of anything.
    }
	indepVar1[::]=outerIndep[::];
	return output_array;
} // fun - delay_path_2d

defun delay_path_3d(src_data, sink_data)
{
	decl output_array=create(3,"Real",{"indepVar1","indepVar2","indepVar3"},{"Real","Real","Real"}, 1, 1);  // this just initializes the result array.
	decl indepVar1=indep(output_array,"indepVar1");
    decl indepVar2=indep(output_array,"indepVar2");
	decl indepVar3=indep(output_array,"indepVar3");
    decl outerIndep=indep(src_data[::,0,0]);
	decl innerIndep=indep(src_data[0,::,0]);
    decl numPts_i = sweep_size(src_data[::,0,0]);
    decl i;      
	decl numPts_j = sweep_size(src_data[0,::,0]);
	decl j;
	
    for (i=0; i<numPts_i; i++)
    {
		decl temp=delay_path_2d(src_data[i,::,::], sink_data[i,::,::]);
		for (j=0; j<numPts_j; j++)
		{
			indepVar2[i,j]=innerIndep[j];
			output_array[i,j,0]=temp[j,0];
		    output_array[i,j,1]=temp[j,1];
			indepVar3[i,j,::] = 0; // Any value would work here, as the delay_path_1d function just returns two values that are not a function of anything.
		}
    }
	indepVar1[::]=outerIndep[::];
    return output_array;
} // fun - delay_path_3d

//******************************************************************************
/*BEGIN_DOC
FUN_NAME: ber_qpsk() 
FUN_DESCRIPTION: Returns the symbol probability of error versus signal-to-noise ratio per bit for QPSK modulation
RETURNED_VALUE: Complex
CATEGORY: Envelope, Signal Processing
SYNTAX: data = ber_qpsk(vIn, vOut, symRate, noise{, samplingDelay, rotation, tranDelay, pathDelay}) 
EXAMPLE:
y = ber_qpsk(videal[1], vout[1], 1e6, {0.15::-0.01::0.04}) 
ARGUMENT
  ARG_NAME: vIn
  ARG_DESCRIPTION: complex envelope voltage signals at the input node
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: vOut
  ARG_DESCRIPTION: complex envelope voltage signals at the output node
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: symRate
  ARG_DESCRIPTION: symbol rate (real) of the modulation signal
  ARG_DEFAULT: None
  ARG_RANGE: (0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: noise
  ARG_DESCRIPTION: RMS noise vector
  ARG_DEFAULT: None
  ARG_RANGE: (0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: samplingDelay
  ARG_DESCRIPTION: clock phase in seconds
  ARG_DEFAULT: calculated
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: rotation
  ARG_DESCRIPTION: carrier phase in radians
  ARG_DEFAULT: calculated
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: tranDelay
  ARG_DESCRIPTION: time in seconds that causes this time duration of symbols to be eliminated from the bit error rate calculation dagger.gif
  ARG_DEFAULT: calculated
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: pathDelay
  ARG_DESCRIPTION: delay from input to output in seconds
  ARG_DEFAULT: calculated
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
FOOTNOTES: dagger.gif Usually the filters in the simulation have transient responses, and the bit error rate calculation should not start until these transient responses have finished. 
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: ber_pi4dqpsk(), constellation() 
NOTES:
Used in Circuit Envelope simulation, Data Flow simulation 

The arguments vIn and vOut usually come from a circuit envelope simulation, while noise usually comes from a harmonic balance simulation, and is assumed to be additive white Gaussian. It can take a scalar or vector value. The function uses the quasi-analytic approach for estimating BER: for each symbol, Eb / N0 and BER are calculated analytically; then the overall BER is the average of the BER values for the symbols. 

Note that ber_qpsk returns a list of data: 

data[0]= symbol probability of error versus Eb / N0 
data[1]= path delay in seconds 
data[2]= carrier phase in radians 
data[3]= clock phase in seconds 
data[4]= complex(Isample, Qsample) 

EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/

defun ber_qpsk(src_data, sink_data, symbol_rate, noise, 
	       sample_delay, rotation_rad, tran_delay, path_delay)
{
  if (sweep_dim(src_data) > 1 || sweep_dim(sink_data) > 1)
  {
    print_function_error("ber_qpsk","This function is only valid for 1-Dimensional Data");
    return NULL;
  }
  
  decl incr;
  if (symbol_rate)
  {
    incr = 1/symbol_rate;
  }
  else
  {
    return NULL;
  }

  decl delay_p, rot_rad;
  if(path_delay == NULL || rotation_rad == NULL) //Calculate path delay and rotation
  {
    decl dpath = delay_path(src_data, sink_data);
    delay_p = dpath[0];
    rot_rad = dpath[1];
  }
  else
  {
    delay_p = path_delay;
    rot_rad = rotation_rad;
  }

  // rotate sink_data;
  sink_data = sink_data*exp(j*rot_rad);

  decl delay_t;
  if(tran_delay == NULL)
  {
    delay_t = 0;
  }
  else
  {
    decl delay_t = ceil(mag(tran_delay)*symbol_rate)/symbol_rate;
  }

  decl delay_s;
  if(sample_delay == NULL) //Calculate sample delay (clocking phase)
  {
    decl time_array = indep(sink_data);
    decl tstep = time_array[1]-time_array[0];
    //delay_s = sampling_delay(src_data, sink_data, symbol_rate, delay_p, delay_t, 0.5*tstep);
    delay_s = __sampling_time(__goal_qpsk, sink_data, symbol_rate, (delay_p+delay_t), 0.5*tstep);
  }
  else
  {
    delay_s = sample_delay;
  }
  
  decl i_data=real(sink_data);
  decl q_data=imag(sink_data);
  decl start_time = delay_p+delay_s+delay_t;
  decl stop_time = max(indep(sink_data));
   
  // take the sampling points of I and Q
  decl interp_i_data = interp(i_data,start_time,stop_time,incr);
  decl interp_q_data = interp(q_data,start_time,stop_time,incr);

  decl rms_i = mag(interp_i_data)/sqrt(2);
  decl rms_q = mag(interp_q_data)/sqrt(2);

  decl erfc_i = 0.5*erfc(rms_i./noise);
  decl erfc_q = 0.5*erfc(rms_q./noise);

  decl ber_i = mean(permute(expand(erfc_i)));
  decl ber_q = mean(permute(expand(erfc_q)));
  
  decl eb_over_n0 = (0.5*mean(rms_i**2+rms_q**2))./(noise.*noise);

  decl ber = vs(ber_i+ber_q-ber_i*ber_q, 10*log(expand(eb_over_n0)));

  return list(ber, delay_p, rot_rad, delay_s, (interp_i_data+j*interp_q_data));
} //fun - ber_qpsk

//******************************************************************************
/*BEGIN_DOC
FUN_NAME: ber_pi4dqpsk() 
FUN_DESCRIPTION: Returns the symbol probability of error versus signal-to-noise ratio per bit for pi/4 DQPSK modulation. 
RETURNED_VALUE: Complex
CATEGORY: Envelope, Signal Processing
SYNTAX: data = ber_pi4dqpsk(vIn, vOut, symRate, noise, samplingDelay, rotation, tranDelay, pathDelay) 
EXAMPLE:
y = ber_pi4dqpsk(videal[1], vout[1], 0.5e6, {0.1::-0.01::0.02}) 
ARGUMENT
  ARG_NAME: vIn
  ARG_DESCRIPTION: complex envelope voltage signals at the input node
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: vOut
  ARG_DESCRIPTION: complex envelope voltage signals at the output node
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: symRate
  ARG_DESCRIPTION: symbol rate (real) of the modulation signal
  ARG_DEFAULT: None
  ARG_RANGE: (0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: noise
  ARG_DESCRIPTION: RMS noise vector
  ARG_DEFAULT: None
  ARG_RANGE: (0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: samplingDelay
  ARG_DESCRIPTION: clock phase in seconds
  ARG_DEFAULT: calculated
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: rotation
  ARG_DESCRIPTION: carrier phase in radians
  ARG_DEFAULT: calculated
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: tranDelay
  ARG_DESCRIPTION: time in seconds that causes this time duration of symbols to be eliminated from the bit error rate calculation dagger.gif
  ARG_DEFAULT: calculated
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: pathDelay
  ARG_DESCRIPTION: delay from input to output in seconds
  ARG_DEFAULT: calculated
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
FOOTNOTES: dagger.gif Usually the filters in the simulation have transient responses, and the bit error rate calculation should not start until these transient responses have finished. 
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: ber_qpsk(), constellation() 
NOTES:
Used in Circuit Envelope simulation, Data Flow simulation 

The arguments vIn and vOut usually come from a circuit envelope simulation, while noise usually comes from a harmonic balance simulation, and is assumed to be additive white Gaussian. It can take a scalar or vector value. The function uses the quasi-analytic approach for estimating BER: for each symbol, Eb / N0 and BER are calculated analytically; then the overall BER is the average of the BER values for the symbols.

Note that ber_pi4dqpsk returns a list of data: 

data[0]= symbol probability of error versus Eb / N0 
data[1]= path delay in seconds 
data[2]= carrier phase in radians 
data[3]= clock phase in seconds 
data[4]= complex(Isample, Qsample) 

EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/

defun ber_pi4dqpsk(src_data, sink_data, symbol_rate, noise, 
		   sample_delay, rotation_rad, tran_delay, path_delay)
{
  if (sweep_dim(src_data) > 1 || sweep_dim(sink_data) > 1)
    {
      print_function_error("ber_pi4dqpsk","This function is only valid for 1-Dimensional Data");
      return NULL;
    }

  decl incr;
  
  if (symbol_rate)
  {
    incr = 1/symbol_rate;
  }
  else
  {
    return NULL;
  }

  decl delay_p, rot_rad;
  if(path_delay == NULL || rotation_rad == NULL) //Calculate path delay and rotation
  {
    decl dpath = delay_path(src_data, sink_data);
    delay_p = dpath[0];
    rot_rad = dpath[1];
  }
  else
  {
    delay_p = path_delay;
    rot_rad = rotation_rad;
  }

  // rotate sink_data;
  sink_data = sink_data*exp(j*rot_rad);

  decl delay_t;
  if(tran_delay == NULL)
  {
    delay_t = 0;
  }
  else
  {
    decl delay_t = ceil(mag(tran_delay)*symbol_rate)/symbol_rate;
  }

  decl delay_s;
  if(sample_delay == NULL) //Calculate sample delay (clocking phase)
  {
    decl time_array = indep(sink_data);
    decl tstep = time_array[1]-time_array[0];
    //delay_s = sampling_delay(src_data, sink_data, symbol_rate, delay_p, delay_t, 0.5*tstep);
    delay_s = __sampling_time(__goal_pi4dqpsk, sink_data, symbol_rate, (delay_p+delay_t), 0.5*tstep);
  }
  else
  {
    delay_s = sample_delay;
  }

  decl i_data=real(sink_data);
  decl q_data=imag(sink_data);
  decl start_time = delay_p+delay_s+delay_t;
  decl stop_time = max(indep(sink_data));
   
  // take the sampling points of I and Q
  decl interp_i_data = interp(i_data,start_time,stop_time,incr);
  decl interp_q_data = interp(q_data,start_time,stop_time,incr);

  // make an even mask and an odd mask
  decl n_samples = sweep_size(interp_i_data);
  decl junk_vector = [1::n_samples];
  decl odd_mask = junk_vector-2*int(junk_vector/2); //(1,0,1,0,...)
  decl even_mask = !odd_mask; //(0,1,0,1,...)

  decl new_i_data, new_q_data;
  if(mag(interp_i_data[0]) > mag(interp_i_data[1])) // rotate the even-numbered samples by pi/4
  {
    new_i_data = interp_i_data*odd_mask + (interp_q_data+interp_i_data)*even_mask/sqrt(2);
    new_q_data = interp_q_data*odd_mask + (interp_q_data-interp_i_data)*even_mask/sqrt(2);
  }
  else // rotate the odd-numbered samples by pi/4
  {
    new_i_data = interp_i_data*even_mask + (interp_q_data+interp_i_data)*odd_mask/sqrt(2);
    new_q_data = interp_q_data*even_mask + (interp_q_data-interp_i_data)*odd_mask/sqrt(2);
  }

  decl rms_i = mag(new_i_data)/sqrt(2);
  decl rms_q = mag(new_q_data)/sqrt(2);

  decl erfc_i = 0.5*erfc(sqrt(4*(sin(pi/8))**2)*rms_i./noise);
  decl erfc_q = 0.5*erfc(sqrt(4*(sin(pi/8))**2)*rms_q./noise);

  decl ber_i = mean(permute(expand(erfc_i)));
  decl ber_q = mean(permute(expand(erfc_q)));

  decl eb_over_n0 = (0.5*mean(rms_i**2+rms_q**2))./(noise.*noise);

  decl ber = vs(ber_i+ber_q-ber_i*ber_q, 10*log(expand(eb_over_n0)));

  return list(ber, delay_p, rot_rad, delay_s, (interp_i_data+j*interp_q_data));
}

defun __phase_delta_calc(vfund_ideal, vfund_dist)
{	
//	decl phase_delta = phaserad(vfund_C_dist[0::sn-1]) - phaserad(vfund_C_ideal[0::sn-1]);
//	decl phase_unwrapped1= if (phase_delta < -pi) then (phase_delta+2*pi) else phase_delta;
//	decl phase_unwrapped = if (phase_unwrapped1>pi) then phase_unwrapped1 -2*pi else phase_unwrapped1;
	decl phase_dist = phaserad(vfund_dist);
	decl phase_dist_unwrapped = unwrap(phase_dist, pi);
	decl phase_ideal = phaserad(vfund_ideal);
	decl phase_ideal_unwrapped = unwrap(phase_ideal, pi);
	decl phase_delta_unwrapped = unwrap(phase_dist_unwrapped - phase_ideal_unwrapped, pi);
	decl mean_phase_delta = mean(phase_delta_unwrapped);
	return mean_phase_delta;
}

defun __goal_evm(vfund_ideal, vfund_dist, symbol_rate, path_delay, sample_delay, tran_delay)
{
    decl tran_time = ceil(mag(tran_delay)*symbol_rate)/symbol_rate;
    decl stop_time = max(indep(vfund_ideal));
    decl incr = 1/symbol_rate;

    // ideal constellation
    decl start_time = sample_delay + tran_delay;
    decl vfund_ideal_real = real(vfund_ideal);
    decl vfund_ideal_imag = imag(vfund_ideal);
    vfund_ideal_real = interp(vfund_ideal_real, start_time, stop_time, incr);
    vfund_ideal_imag = interp(vfund_ideal_imag, start_time, stop_time, incr);
    vfund_ideal = vfund_ideal_real+j*vfund_ideal_imag;
	decl vfund_ideal_rms = sqrt(mean(mag(vfund_ideal)**2));
	vfund_ideal = vfund_ideal/vfund_ideal_rms; 	// Replace the ideal signal with its original values normalized to its RMS value.
    
     // distorted compensated constellation
    start_time += path_delay;
    decl vfund_dist_real = interp(real(vfund_dist), start_time, stop_time, incr);
    decl vfund_dist_imag = interp(imag(vfund_dist), start_time, stop_time, incr);

    decl sn = min([sweep_size(vfund_dist_real), sweep_size(vfund_ideal_real)]);

    // mean phase difference
    decl mean_phase_delta = __phase_delta_calc(vfund_ideal_real[0::sn-1]+j*vfund_ideal_imag[0::sn-1],vfund_dist_real[0::sn-1] +j*vfund_dist_imag[0::sn-1]);

    // rotate the constellation
    vfund_dist=vfund_dist*exp(-j*mean_phase_delta);
   
    vfund_dist_real = interp(real(vfund_dist), start_time, stop_time, incr);
    vfund_dist_imag = interp(imag(vfund_dist), start_time, stop_time, incr);
    vfund_dist =  vfund_dist_real+j*vfund_dist_imag;
    
    // scaling
    decl scaling = sqrt(mean(mag(vfund_dist[0::sn-1])**2));	// Could divide by the RMS value of the vfund_ideal, but this is now 1.
    vfund_dist = vfund_dist/scaling;

    // EVM
    decl evm = mag(vfund_dist[0::sn-1]-vfund_ideal[0::sn-1]);

    decl evm_rms = sqrt(mean(evm**2));
    decl evm_percent = 100*evm_rms;	
    
    return evm_percent;
}


defun sampling_delay(ideal_data, dist_data, symbol_rate, path_delay, tran_delay, search_step)
{
  if (sweep_dim(ideal_data) > 1 || sweep_dim(dist_data) > 1)
  {
    print_function_error("sampling_delay","This function is only valid for 1-Dimensional Data");
    return NULL;
  }

  decl incr = 1/symbol_rate;

  decl delay_search = [0::search_step::incr];

  decl i;
  decl init_value=1e50;
  decl delay_value=0;

  for(i=0; i<sweep_size(delay_search); i++)
  {
    decl opt_goal = __goal_evm(ideal_data, dist_data, symbol_rate, 
			       path_delay, delay_search[i], tran_delay);

    if(opt_goal<init_value)
    {
      init_value=opt_goal;
      delay_value=search_step*i;
    }
  }

  return (delay_value);
}


defun __goal_qpsk(i_data, q_data, tstart, tstop, incr)
{
  decl Isample=interp(i_data,tstart,tstop,incr);
  decl Qsample=interp(q_data,tstart,tstop,incr);
  
  decl rms_i=abs(Isample)/sqrt(2);
  decl rms_q=abs(Qsample)/sqrt(2);
  
  decl erfc_i=0.5*erfc(sqrt(4*(sin(pi/8))**2)*rms_i);
  decl erfc_q=0.5*erfc(sqrt(4*(sin(pi/8))**2)*rms_q);
  
  decl ber_q=mean(erfc_q);
  decl ber_i=mean(erfc_i);

  decl ber_tot = ber_i+ber_q-ber_i*ber_q;
  decl circle_err=mean(mag(Isample**2+Qsample**2-mean(Isample**2+Qsample**2)));
 
  return (ber_tot*circle_err);

}

defun __goal_pi4dqpsk(i_data, q_data, tstart, tstop, incr)
{
    decl interp_i_data = interp(i_data,tstart,tstop,incr);
    decl interp_q_data = interp(q_data,tstart,tstop,incr);

    // make an even mask and an odd mask
    decl n_samples = sweep_size(interp_i_data);
    decl junk_vector = [1::n_samples];
    decl odd_mask = junk_vector-2*int(junk_vector/2); //(1,0,1,0,...)
    decl even_mask = !odd_mask; //(0,1,0,1,...)

    decl new_i_data, new_q_data;
    if(mag(interp_i_data[0]) > mag(interp_i_data[1])) // rotate the even-numbered samples by pi/4
    {
      new_i_data = interp_i_data*odd_mask + (interp_q_data+interp_i_data)*even_mask/sqrt(2);
      new_q_data = interp_q_data*odd_mask + (interp_q_data-interp_i_data)*even_mask/sqrt(2);
    }
    else // rotate the odd-numbered samples by pi/4
    {
      new_i_data = interp_i_data*even_mask + (interp_q_data+interp_i_data)*odd_mask/sqrt(2);
      new_q_data = interp_q_data*even_mask + (interp_q_data-interp_i_data)*odd_mask/sqrt(2);
    }

    decl rms_i = mag(new_i_data)/sqrt(2);
    decl rms_q = mag(new_q_data)/sqrt(2);

    decl erfc_i = 0.5*erfc(sqrt(4*(sin(pi/8))**2)*rms_i);
    decl erfc_q = 0.5*erfc(sqrt(4*(sin(pi/8))**2)*rms_q);

    decl ber_i = mean(erfc_i);
    decl ber_q = mean(erfc_q);

    decl ber_tot = ber_i+ber_q-ber_i*ber_q;
    decl circle_err=mean(mag(new_i_data**2+new_q_data**2-mean(new_i_data**2+new_q_data**2)));

    return (ber_tot*circle_err);

}

defun __sampling_time(goal_func, data, symbol_rate, search_start, search_step)
{
  if (sweep_dim(data) > 1)
  {
    print_function_error("sampling_time","This function is only valid for 1-Dimensional Data");
    return NULL;
  }
  decl i_data=real(data);
  decl q_data=imag(data);

  decl incr;
  if (symbol_rate)
  {
    incr = 1/symbol_rate;
  }
  else
  {
    return NULL;
  }

  decl delay_search = [search_start::search_step::search_start+incr];
  decl tstop = max(indep(i_data));

  decl i;
  decl init_value=1e50;
  decl delay_value=0;

  for(i=0; i<sweep_size(delay_search); i++)
  {
    decl opt_goal = goal_func(i_data, q_data, delay_search[i], tstop, incr);

    if(opt_goal<init_value)
    {
      init_value=opt_goal;
      delay_value=search_step*i;
    }
  }

  return (delay_value);
} //fun - __sampling_time

//*******************************************************************************
/*BEGIN_DOC
FUN_NAME: sample_delay_qpsk()
FUN_DESCRIPTION: This function calculates the optimal sampling point within a symbol for a given QPSK waveform."Optimal" is defined as the sampling point that provides the lowest bit error rate. 
RETURNED_VALUE: Real
CATEGORY: Envelope, Signal Processing
SYNTAX: y = sample_delay_qpsk(vlQ, symbolRate, path_delay, timeResolution)
EXAMPLE:
a = sample_delay_qpsk(vout[1], 25e3, 1.5e-6, 0.15e-6)
ARGUMENT
  ARG_NAME: vlQ
  ARG_DESCRIPTION: complex envelope (I + j * Q) of a QPSK signal
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: symbolRate
  ARG_DESCRIPTION: symbol rate of the QPSK signal
  ARG_DEFAULT: None
  ARG_RANGE: (0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: path_delay
  ARG_DESCRIPTION: time delay on the waveform before the sampling starts dagger.gif
  ARG_DEFAULT: None
  ARG_RANGE: (0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: timeResolution
  ARG_DESCRIPTION: time step (typically one-tenth of a symbol time or less) used to search for the best sampling point in a given symbol period
  ARG_DEFAULT: None
  ARG_RANGE: (0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
FOOTNOTES: dagger.gif If the delay is 0, this parameter may be omitted. If it is non-zero, enter the delay value. This can be calculated using the function delay_path(). 
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: ber_pi4dqpsk(), ber_qpsk(), const_evm()
NOTES:
This function can be used only with 1-dimensional data.
EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS
END_DOC*/

defun sample_delay_qpsk(sink_data, symbol_rate, path_delay, tstep)
{
  decl delay_s = __sampling_time(__goal_qpsk, sink_data, symbol_rate, path_delay, tstep);
  return delay_s;
}

//*******************************************************************************
/*BEGIN_DOC
FUN_NAME: sample_delay_pi4dqpsk()
FUN_DESCRIPTION: This function calculates the optimal sampling point within a symbol for a given pi4dqpsk waveform. "Optimal" is defined as the sampling point that provides the lowest bit error rate. 
RETURNED_VALUE: Real
CATEGORY: Envelope, Signal Processing
SYNTAX: y = sample_delay_pi4dqpsk(vlQ, symbolRate, path_delay, timeResolution)
EXAMPLE:
a = sample_delay_pi4dqpsk(vout[1], 25e3, 1.5e-6, 0.15e-6)
ARGUMENT
  ARG_NAME: vlQ
  ARG_DESCRIPTION: complex envelope (I + j * Q) of a pi/4 DQPSK signal
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: symbolRate
  ARG_DESCRIPTION: symbol rate of the pi/4 DQPSK signal
  ARG_DEFAULT: None
  ARG_RANGE: (0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: path_delay
  ARG_DESCRIPTION: time delay on the waveform before the sampling starts dagger.gif
  ARG_DEFAULT: None
  ARG_RANGE: (0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: timeResolution
  ARG_DESCRIPTION: time step (typically one-tenth of a symbol time or less) used to search for the best sampling point in a given symbol period
  ARG_DEFAULT: None
  ARG_RANGE: (0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
FOOTNOTES: dagger.gif If the delay is 0, this parameter may be omitted. If it is non-zero, enter the delay value. This can be calculated using the function delay_path(). 
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: ber_pi4dqpsk(), ber_qpsk(), const_evm()
NOTES:
This function can be used only with 1-dimensional data.
EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS
END_DOC*/
defun sample_delay_pi4dqpsk(sink_data, symbol_rate, path_delay, tstep)
{
  decl delay_s = __sampling_time(__goal_pi4dqpsk, sink_data, symbol_rate, path_delay, tstep);
  return delay_s;
}

//********************************************************************
/*BEGIN_DOC
FUN_NAME: power_ccdf()
FUN_DESCRIPTION: Returns the power CCDF (Complementary Cumulative Distribution Function) curve for the input voltage/current data. 
RETURNED_VALUE: Real
CATEGORY: Envelope, Signal Processing
SYNTAX: pCCDF = power_ccdf(data, numBins) 
EXAMPLE:
pCCDF = power_ccdf(Vout[1]) 

where Vout is a named node in a Circuit Envelope simulation, will return the power CCDF curve for the voltage at the fundamental frequency. The returned power CCDF curve will have the default number of points. 

pCCDF = power_ccdf(T1, 10)

where T1 is the name of a TimedSink component (in a DSP schematic), will return the power CCDF curve for the voltage signal recorded in the TimedSink. The returned curve will have 10 points. 

ARGUMENT
  ARG_NAME: data
  ARG_DESCRIPTION: baseband or complex envelope voltage/current signal
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Integer, Real, Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: numBins
  ARG_DESCRIPTION: number of points in the returned power CCDF curve
  ARG_DEFAULT: log2(numDataPoints)
  ARG_RANGE: [1:inf)
  ARG_TYPE: Integer
  ARG_REQUIRED: NO
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: peak_pwr(), peak_to_avg_pwr(), power_ccdf_ref(), pwr_vs_t(), total_pwr()
NOTES:
Used in Circuit Envelope simulation, Data Flow simulation. 

This expression can be used with input data of up to two dimensions. It can handle both baseband as well as complex envelope data. 

The power CCDF (typically called just CCDF) measurement is a very common measurement performed on 2G and 3G wireless signals. The CCDF curve shows the probability that the instantaneous signal power will be higher than the average signal power by a certain amount of dB. The independent axis of the CCDF curve shows power levels in dB with respect to the signal average power level (0 dB corresponds to the signal average power level). The dependent axis of the CCDF curve shows the probability that the instantaneous signal power will exceed the corresponding power level on the independent axis. Figure 4-1 shows the CCDF curve for a WLAN 802.11a 54 Mbps signal. 

				  
Figure 4-1. CCDF Curve for WLAN 802.11a 54 Mbps Signal 

In Figure 4-1, you can see that the instantaneous signal power exceeds the average signal power (0 dB) for 20% of the time. You can also see that the instantaneous signal power exceeds the average signal power by 5 dB for only 0.3% of the time. 
EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/
//********************************************************************
defun power_ccdf( data, numBins )
{
	if ( data == NULL ) {
		print_function_error( "power_ccdf", " first argument (data) is a required argument." );
		return;
	}

	decl dataType = type( data );

	if ( strcmp( dataType, "Integer" ) && strcmp( dataType, "Real" ) && strcmp( dataType, "Complex" ) ) {
		print_function_error( "power_ccdf", " first argument (data) can only be of type Integer, Real, or Complex." );
		return;
	}

	if ( numBins != NULL && numBins < 2 ) {
		print_function_error( "power_ccdf", " second argument (numBins) must be greater than or equal to 2." );
		return;
	}

	decl result;
	decl sweepDim = sweep_dim( data );

        //dwf_pptokens(list("Data: ",data));
        //dwf_pptokens(list("sweepDim: ",sweepDim));
        //dwf_pptokens(list("numBins: ",numBins));
	switch ( sweepDim ) {
		case 0:  print_function_error( "power_ccdf", " does not support single number data.");
		         return;
		         break;
		case 1:  result = power_ccdf_1d( data, numBins );
		         break;
		case 2:  result = power_ccdf_2d( data, numBins );
		         break;
		default: print_function_error( "power_ccdf", " does not support data with dimensions greater than two.");
		         return;
		         break;
	}

	return result;
} //fun - power_ccdf

defun power_ccdf_1d( data, numBins ) {
// No need to do error checking here.
// The wrapper function power_ccdf() has done all the error checking.

    decl p_vs_t = mag( data**2 );
    decl meanP = mean( p_vs_t );
    p_vs_t = 10*log10( p_vs_t / meanP );

//  All the following code (until set_attr) can be replaced by 
//  decl ccdf = 1 - cdf( p_vs_t, numBins );
//  if we do not care about the name of the independent variable.

    decl ccdf = create( 1, "Real", { "dB" }, { "Real" }, 1, 1 );
    decl ccdfIndep = indep( ccdf );
    decl result = 1 - cdf( p_vs_t, numBins );
    decl resultIndep = indep( result );

// When the input data has a few values close to 0.0 the x-axis range
// for the result returned by the cdf function is very big and the 
// final ccdf curve looks very weird. The following while loop tries 
// to replace these almost 0.0 values with something more reasonable  
// so that the x-axis range for cdf is reduced to a reasonable value. 
// The condition used (to exit the loop) is that two consecutive 
// points in the ccdf curve should differ more than 1%.
 
    decl numPts = sweep_size( result );
    //dwf_pptokens(list("result: ", result));
    //dwf_pptokens(list("numPts: ", numPts));
    if ( numPts > 1 ) 
    {
        decl cur  = result[0] ;
        decl prev;

        decl maxIters = numPts;

        //dwf_pptokens(list("cur: ", cur));
        //dwf_pptokens(list("result[1]: ", result[1]));
        //dwf_pptokens(list("p_vs_t: ", p_vs_t));
        while ( ( cur  - result[1] < cur  / 100 ) ) 
        {

            decl i;
            decl minIndep = resultIndep[0];
  
            for ( i = 1; i < numPts; i++ )
            {
                prev = cur ;
                cur  = result[i] ;
    
                if ( prev  - cur < 1.0e-1 * prev  )
                    minIndep = ( resultIndep[i] + resultIndep[i-1] ) / 2;
                else
                    break;
            }


            p_vs_t=(p_vs_t < minIndep) ? minIndep:p_vs_t ;

/*
            for ( i = 0; i < sweep_size( p_vs_t ); i++ ) {
                if ( p_vs_t[i] < minIndep )
                    p_vs_t[i] = minIndep;
            }
*/

            result = 1 - cdf( p_vs_t, numBins );
            resultIndep = indep( result );
            cur = result[0] ;

            //dwf_pptokens(list("cur: ", cur));
            //dwf_pptokens(list("result[1]: ", result[1]));
            if (--maxIters < 0)
            {
                // If we hit maxIters, go back to the ORIGINAL data
                p_vs_t = mag( data**2 );
                result = 1 - cdf( p_vs_t, numBins );
                break;
            }
        }
    }

// See next comment block for the reason why loop ends at 
// sweep_size( result ) - 1 instead of sweep_size( result ).
    decl i;
    for ( i = 0; i < numPts -1 ; i++ ) {
        ccdf[i] = result[i];
        ccdfIndep[i] = resultIndep[i];
    }

//ram instead of the above loop
// ccdf = result ;
// ccdfIndep = resultIndep ;
// i = numPts -1 ;
//ram

// Sometimes the last point retuned by cdf is almost 1, so 1 minus 
// this point is almost 0.0 (e.g. 1.0e-30). This results in weird 
// looking ccdf curves. This last point can be safely ignored. The  
// condition used to ignore the last point is if it is 3 orders of
// magnitude smaller that the previous point.

    if ( result[i] > 1.0e-3 * result[i-1] ) {
        ccdf[i] = result[i];
        ccdfIndep[i] = resultIndep[i];
    }

    set_attr( ccdf, "TraceType", "Linear" );
// fprintf(stderr,"DEBUG power_ccdf_1d ends   at  : %s ", date_time() );
    return ccdf;

}



defun power_ccdf_2d( data, numBins ) {

// No need to do error checking here.
// The wrapper function power_ccdf() has done all the error checking.

	decl numOuterPts = sweep_size( data[::,0] );

	decl outerIndepName = indep_name( data, 1 );
	decl innerIndepName = "dB";

	decl ccdf = create( 2, "Real", { outerIndepName, innerIndepName }, { "Real", "Real" }, 1, 1 );
	decl outerIndep = indep( ccdf, outerIndepName );
	decl innerIndep = indep( ccdf, innerIndepName );

	decl dataOuterIndep = indep( data, 2 );

	decl i;
	for ( i = 0; i < numOuterPts; i++ ) {
		decl ccdf_1d = power_ccdf_1d( data[i,::], numBins );
		ccdf[i,::] = ccdf_1d;
		innerIndep[i,::] = indep( ccdf_1d );
		outerIndep[i] = dataOuterIndep[i];
	}

	set_attr( ccdf, "TraceType", "Linear" );
	return ccdf;
}

//****************************************************************************
/*BEGIN_DOC
FUN_NAME: power_ccdf_ref
FUN_DESCRIPTION: Returns the power CCDF (Complementary Cumulative Distribution Function) curve for white gaussian noise.
RETURNED_VALUE: Real
CATEGORY: Envelope, Signal Processing
SYNTAX: ccdfRef = power_ccdf_ref(indepPowerRatioValues)
EXAMPLE:
pCCDF = power_ccdf(T1) 

ccdfRef = power_ccdf_ref( indep( pCCDF) ) 

where T1 is the name of a TimedSink component (in a DSP schematic), will return the power CCDF curve for white gaussian noise evaluated at the same power levels as the pCCDF curve. 

ccdfRef = power_ccdf_ref( [-10::2::8] ) 

will return the power CCDF curve for white gaussian noise evaluated at the power levels -10, -8, -6, -4, -2, 0, 2, 4, 6, 8 (in dB with respect to the average power level of a white gaussian noise signal).
ARGUMENT
  ARG_NAME: indepPowerRatioValues
  ARG_DESCRIPTION:  power levels (in dB with respect to the average power level of a white gaussian noise signal) at which the power CCDF for white gaussian noise will be calculated
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Integer, Real
  ARG_REQUIRED: YES
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: power_ccdf()
NOTES:
This expression can be used with input data of up to two dimensions. 

The input data must be sorted in increasing or decreasing order. In addition, it is recommended that the input vector argument has uniformly spaced values. The vector "indep( X )", where X is the value returned by the power_ccdf() expression, is guaranteed to have uniformly spaced values sorted in increasing order. This would be the most typical value for the input argument of power_ccdf_ref(). 

A typical power CCDF measurement (see Notes/Equations for power_ccdf()) provides a reference CCDF curve along with the measured CCDF curve. This reference curve is typically the power CCDF curve for a white gaussian noise signal. This expression can generate this reference curve. Figure 4-2 shows the CCDF curve for a WLAN 802.11a signal along with the reference curve. 

EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS
END_DOC*/

//****************************************************************************
defun power_ccdf_ref( indepPowerRatioValues)
{
	if ( indepPowerRatioValues == NULL ) {
		print_function_error( "power_ccdf_ref", " first argument (indepPowerRatioValues) is a required argument." );
		return;
	}

	decl dataType = type( indepPowerRatioValues );

	if ( strcmp( dataType, "Integer" ) && strcmp( dataType, "Real" ) ) {
		print_function_error( "power_ccdf_ref", " first argument (indepPowerRatioValues) can only be of type Integer or Real." );
		return;
	}

	decl result;
	decl sweepDim = sweep_dim( indepPowerRatioValues );

	switch ( sweepDim ) {
		case 0:  print_function_error( "power_ccdf_ref", " does not support single number input data." );
		         return;
		         break;
		case 1:  result = power_ccdf_ref_1d( indepPowerRatioValues );
		         break;
		case 2:  result = power_ccdf_ref_2d( indepPowerRatioValues );
		         break;
		default: print_function_error( "power_ccdf_ref", " does not support data with dimensions greater than two." );
		         return;
		         break;
	}

	return result;
} //fun - power_ccdf_ref


defun power_ccdf_ref_1d( indepPowerRatioValues )
{
	decl numPts = sweep_size( indepPowerRatioValues );
	if ( numPts < 2 ) {
		print_function_error( "power_ccdf_ref", " inner dimension of input data must have at least 2 points." );
		return;
	}

// Check that values are sorted in increasing or decreasing order.
	decl i;
	decl binWidth = indepPowerRatioValues[1] - indepPowerRatioValues[0];

// if all bin widths have the same sign (positive or negative) then the product 
// of each bin width with binWidth must be positive
  /*
    for ( i = 1; i < numPts; i++ ) {
      if ( ( indepPowerRatioValues[i] - indepPowerRatioValues[i-1] ) * binWidth < 0 ) {
        print_function_error( "power_ccdf_ref", " inner dimension of input data must be sorted in increasing or decreasing order." );
        return;
      }
    }
  */
  
    decl prev_iprv   ;
    decl cur_iprv   = indepPowerRatioValues[0] ;
  
    for ( i = 1; i < numPts; i++ ) 
    {
                  prev_iprv = cur_iprv ;
                  cur_iprv  = indepPowerRatioValues[i] ;
         
      if ( ( cur_iprv - prev_iprv ) * binWidth < 0 ) 
      {
        print_function_error( "power_ccdf_ref", " inner dimension of input data must be sorted in increasing or decreasing order." );
        return;
      }
    }

	decl ccdfRef = create( 1, "Real", { "dB" }, { "Real" }, 1, 1 );
	decl ccdfRefIndep = indep( ccdfRef );

	decl j;
	decl binUpperLimit;

  /*
    for ( j = 0; j < numPts - 1; j++ ) {
      binUpperLimit = ( indepPowerRatioValues[j] + indepPowerRatioValues[j+1] ) / 2;
      ccdfRef[j] = exp( -10**( binUpperLimit / 10 ) );
      ccdfRefIndep[j] = indepPowerRatioValues[j];
    }
  
  */  
    decl prev ;
    decl cur = indepPowerRatioValues[0]  ;
  
    for ( j = 0; j < numPts - 1; j++ ) 
    {
      prev = cur ;
      cur  =  indepPowerRatioValues[j+1]  ;
      binUpperLimit = ( prev + cur  ) / 2;
      ccdfRef[j] = exp( -10**( binUpperLimit / 10 ) );
      ccdfRefIndep[j] = prev ;
    }

	binUpperLimit = indepPowerRatioValues[ numPts - 1 ] + ( indepPowerRatioValues[ numPts - 1 ] - indepPowerRatioValues[ numPts - 2 ] ) / 2;
	ccdfRef[ numPts - 1 ] = exp( -10**( binUpperLimit / 10 ) );
	ccdfRefIndep[ numPts - 1 ] = indepPowerRatioValues[ numPts - 1 ];

	return ccdfRef;
} //fun - power_ccdf_ref_1d

defun power_ccdf_ref_2d( indepPowerRatioValues ) {

	decl numOuterPts = sweep_size( indepPowerRatioValues[::,0] );

	decl outerIndepName = indep_name( indepPowerRatioValues, 1 );
	decl innerIndepName = "dB";

	decl ccdfRef = create( 2, "Real", { outerIndepName, innerIndepName }, { "Real", "Real" }, 1, 1 );
	decl outerIndep = indep( ccdfRef, outerIndepName );
	decl innerIndep = indep( ccdfRef, innerIndepName );

//	For some reason
//	decl inputOuterIndep = indep( indepPowerRatioValues, 2 );
//	does not work so I had to find this dummy workaround.

	decl dummy = -indepPowerRatioValues;
	decl inputOuterIndep = indep( dummy, 2 );

	decl i;
	for ( i = 0; i < numOuterPts; i++ ) {
		decl ccdfRef_1d = power_ccdf_ref_1d( indepPowerRatioValues[i,::] );
		ccdfRef[i,::] = ccdfRef_1d;
		innerIndep[i,::] = indep( ccdfRef_1d );
		outerIndep[i] = inputOuterIndep[i];
	}

	return ccdfRef;
}


//**********************************************************************
/*BEGIN_DOC
FUN_NAME: pwr_vs_t()
FUN_DESCRIPTION: Returns the power vs. time waveform for the input voltage data
RETURNED_VALUE: Real
CATEGORY: Envelope, Signal Processing
SYNTAX: p_vs_t = pwr_vs_t(voltage, refR, unit)
EXAMPLE:
p_vs_t = pwr_vs_t(Vout[1], 100, "dBm") 

where Vout is a named node in a Circuit Envelope simulation, will return the power (in dBm) vs. time waveform for the voltage at the fundamental frequency using 100 Ohms as reference resistance. 

p_vs_t = pwr_vs_t(T1)

where T1 is the name of a TimedSink component (in a DSP schematic), will return the power (in W) vs. time waveform for the voltage signal recorded in the TimedSink using 50 Ohms as reference resistance. 

ARGUMENT
  ARG_NAME: voltage
  ARG_DESCRIPTION: baseband or complex envelope voltage signal
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Integer, Real, Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: refR
  ARG_DESCRIPTION: reference resistance in Ohms
  ARG_DEFAULT: 50.0
  ARG_RANGE: (0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: unit
  ARG_DESCRIPTION: power unit to be used
  ARG_DEFAULT: "W"
  ARG_RANGE: "W"|"dBm"|"dBW"
  ARG_TYPE: string
  ARG_REQUIRED: NO
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: peak_pwr(), peak_to_avg_pwr(), power_ccdf(), total_pwr()
NOTES:
Used in Circuit Envelope simulation, Data Flow simulation. 

This expression can be used with input data (voltage) of any dimensions. It can handle both baseband as well as complex envelope data. 
EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/

defun pwr_vs_t( voltage, refR, unit )
{
	if ( voltage == NULL ) {
		print_function_error( "pwr_vs_t", " first argument (voltage) is a required argument." );
		return;
	}

	decl dataType = type( voltage );

	if ( strcmp( dataType, "Integer" ) && strcmp( dataType, "Real" ) && strcmp( dataType, "Complex" ) ) {
		print_function_error( "pwr_vs_t", " first argument (voltage) can only be of type Integer, Real, or Complex." );
		return;
	}

	decl refRes = ( refR == NULL ) ? ( 50.0 ) : ( refR );

	if ( refRes <= 0.0 ) {
		print_function_error( "pwr_vs_t", " second argument (refR) must be greater than 0." );
		return;
	}

	decl powerUnit = ( unit == NULL ) ? ( "W" ) : ( unit );

	if ( strcmp( powerUnit, "dBm" ) && strcmp( powerUnit, "W" ) && strcmp( powerUnit, "dBW" ) ) {
		print_function_error( "pwr_vs_t", " third argument (unit) must be \"dBm\", \"W\", or \"dBW\"." );
		return;
	}

	decl p_vs_t = mag( voltage )**2 / refRes;

	if ( ! strcmp( dataType, "Complex" ) ) {
		p_vs_t = 0.5 * p_vs_t;
	}

	if ( ! strcmp( powerUnit, "dBm" ) ) {
		p_vs_t = 10.0 * log10( p_vs_t ) + 30;
	}

	if ( ! strcmp( powerUnit, "dBW" ) ) {
		p_vs_t = 10.0 * log10( p_vs_t );
	}

	return p_vs_t;
} //fun - pwr_vs_t

//**********************************************************************
/*BEGIN_DOC
FUN_NAME: total_pwr()
FUN_DESCRIPTION: Returns the total (average) power of the input voltage data
RETURNED_VALUE: Real
CATEGORY: Envelope, Signal Processing
SYNTAX: totalP = total_pwr(voltage, refR, unit)
EXAMPLE:
totalP = total_pwr(Vout[1], 100, "dBm") 

where Vout is a named node in a Circuit Envelope simulation, will return the total power (in dBm) at the fundamental frequency using 100 Ohms as reference resistance. 

totalP = total_pwr(T1)

where T1 is the name of a TimedSink component (in a DSP schematic), will return the total power (in W) for the voltage signal recorded in the TimedSink using 50 Ohms as reference resistance. If the signal recorded by the TimedSink is baseband Gaussian noise with a standard deviation of 30 mV, then totalP will be very close to 1.8e-5 W ( 0.032 / 50 ). 

ARGUMENT
  ARG_NAME: voltage
  ARG_DESCRIPTION: baseband or complex envelope voltage signal
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Integer, Real, Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: refR
  ARG_DESCRIPTION: reference resistance in Ohms
  ARG_DEFAULT: 50.0
  ARG_RANGE: (0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: unit
  ARG_DESCRIPTION: power unit to be used
  ARG_DEFAULT: "W"
  ARG_RANGE: "W"|"dBm"|"dBW"
  ARG_TYPE: string
  ARG_REQUIRED: NO
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: peak_pwr(), peak_to_avg_pwr(), power_ccdf(), pwr_vs_t()
NOTES:
Used in Circuit Envelope simulation, Data Flow simulation. 

This expression can be used with input data (voltage) of any dimensions. It can handle both baseband as well as complex envelope data. 
EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/
defun total_pwr( voltage, refR, unit )
{
	if ( voltage == NULL ) {
		print_function_error( "total_pwr", " first argument (voltage) is a required argument." );
		return;
	}

	decl dataType = type( voltage );

	if ( strcmp( dataType, "Integer" ) && strcmp( dataType, "Real" ) && strcmp( dataType, "Complex" ) ) {
		print_function_error( "total_pwr", " first argument (voltage) can only be of type Integer, Real, or Complex." );
		return;
	}

	decl refRes = ( refR == NULL ) ? ( 50.0 ) : ( refR );

	if ( refRes <= 0.0 ) {
		print_function_error( "total_pwr", " second argument (refR) must be greater than 0." );
		return;
	}

	decl powerUnit = ( unit == NULL ) ? ( "W" ) : ( unit );

	if ( strcmp( powerUnit, "dBm" ) && strcmp( powerUnit, "W" ) && strcmp( powerUnit, "dBW" ) ) {
		print_function_error( "total_pwr", " third argument (unit) must be \"dBm\", \"W\", or \"dBW\"." );
		return;
	}

	decl totalP = mean( pwr_vs_t( voltage, refRes, "W" ) );

	if ( ! strcmp( powerUnit, "dBm" ) ) {
		totalP = 10.0 * log10( totalP ) + 30;
	}

	if ( ! strcmp( powerUnit, "dBW" ) ) {
		totalP = 10.0 * log10( totalP );
	}

	return totalP;
} //fun - total_pwr

//************************************************************************
/*BEGIN_DOC
FUN_NAME: peak_pwr()
FUN_DESCRIPTION: Returns the peak power of the input voltage data
RETURNED_VALUE: Real
CATEGORY: Envelope, Signal Processing
SYNTAX: peakP = peak_pwr(voltage, refR, percent, unit)
EXAMPLE:
peakP = peak_pwr(Vout[1], 100, , "dBW") 

where Vout is a named node in a Circuit Envelope simulation, will return the peak power (in dBW) at the fundamental frequency using 100 Ohms as reference resistance. 

peakP = peak_pwr(T1, , 5) 

where T1 is the name of a TimedSink component (in a DSP schematic), will return the power level (in W) that is exceeded 5% of the time for the voltage signal recorded in the TimedSink using 50 Ohms as reference resistance. If the signal recorded by the TimedSink is complex envelope Gaussian noise with a standard deviation of 30 mV for each of the I and Q envelopes, then peakP will be very close to 5.39e-5 W ( -ln(0.05) / 0.032 / 50 ). 

ARGUMENT
  ARG_NAME: voltage
  ARG_DESCRIPTION: baseband or complex envelope voltage signal
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Integer, Real, Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: refR
  ARG_DESCRIPTION: reference resistance in Ohms
  ARG_DEFAULT: 50.0
  ARG_RANGE: (0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: percent
  ARG_DESCRIPTION: percentage of time the returned power value is exceeded
  ARG_DEFAULT: 0.0
  ARG_RANGE: [0:100]
  ARG_TYPE: Real
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: unit
  ARG_DESCRIPTION: power unit to be used
  ARG_DEFAULT: "W"
  ARG_RANGE: "W"|"dBm"|"dBW"
  ARG_TYPE: string
  ARG_REQUIRED: NO
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: peak_to_avg_pwr(), power_ccdf(), pwr_vs_t(), total_pwr() 
NOTES:
Used in Circuit Envelope simulation, Data Flow simulation.

This expression can be used with input data (voltage) of any dimensions when the percent argument is 0 and up to three dimensions when the percent argument is greater than 0. It can handle both baseband as well as complex envelope data.

When the percent argument is set to 0, the returned value is the maximum instantaneous power of the input voltage signal. When the percent argument is set to a value greater than 0, the returned value is the power level that is exceeded for percent amount of time. This argument is useful since some wireless standards specify the peak power not as the absolute maximum instantaneous power but as the power level that is exceeded for some percentage of time. For example, the 3GPP standard defines the maximum power as the power level that is exceeded for 1% of the time. 

EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/
//************************************************************************
defun peak_pwr(voltage, refR, percent, unit)
{
	if ( voltage == NULL ) {
		print_function_error( "peak_pwr", " first argument (voltage) is a required argument." );
		return;
	}

	decl dataType = type( voltage );

	if ( strcmp( dataType, "Integer" ) && strcmp( dataType, "Real" ) && strcmp( dataType, "Complex" ) ) {
		print_function_error( "peak_pwr", " first argument (voltage) can only be of type Integer, Real, or Complex." );
		return;
	}

	decl refRes = ( refR == NULL ) ? ( 50.0 ) : ( refR );

	if ( refRes <= 0.0 ) {
		print_function_error( "peak_pwr", " second argument (refR) must be greater than 0." );
		return;
	}

	decl pct = ( percent == NULL ) ? ( 0.0 ) : ( percent );

	if ( pct < 0.0 || pct > 100.0 ) {
		print_function_error( "peak_pwr", " third argument (percent) must be 0 <= percent <= 100." );
		return;
	}

	decl powerUnit = ( unit == NULL ) ? ( "W" ) : ( unit );

	if ( strcmp( powerUnit, "dBm" ) && strcmp( powerUnit, "W" ) && strcmp( powerUnit, "dBW" ) ) {
		print_function_error( "peak_pwr", " fourth argument (unit) must be \"dBm\", \"W\", or \"dBW\"." );
		return;
	}

	if ( ( pct > 0.0 ) && ( sweep_dim( voltage ) > 3 ) ) {
		print_function_error( "peak_pwr", " when third argument (percent) is greater than 0.0 only up to 3 dimensional data is supported." );
		return;
	}

	decl p_vs_t = pwr_vs_t( voltage, refRes, powerUnit );

	if ( pct > 0.0 ) {
		return nth_percentile( p_vs_t, pct );
	}
	else {
		return max( p_vs_t );
	}
} //fun - peak_pwr

defun nth_percentile( data, percent ) {

	if ( data == NULL ) {
		print_function_error( "nth_percentile", " first argument (data) is a required argument." );
		return;
	}

	decl dataType = type( data );

	if ( strcmp( dataType, "Integer" ) && strcmp( dataType, "Real" ) ) {
		print_function_error( "nth_percentile", " first argument (data) can only be of type Integer or Real." );
		return;
	}

	decl pct = ( percent == NULL ) ? ( 0.0 ) : ( percent );

	if ( pct < 0.0 || pct > 100.0 ) {
		print_function_error( "nth_percentile", " second argument (percent) must be 0 <= percent <= 100." );
		return;
	}

	decl sweepDim = sweep_dim( data );
	decl result;

	switch ( sweepDim ) {
		case 0:  result = data;
		         break;
		case 1:  result = nth_percentile_1d( data, pct );
		         break;
		case 2:  result = nth_percentile_2d( data, pct );
		         break;
		case 3:  result = nth_percentile_3d( data, pct );
		         break;
		default: print_function_error( "nth_percentile", " does not support data with dimensions greater than three.");
		         return;
		         break;
	}

	return result;
}



defun nth_percentile_1d( data, percent ) {

// No need to do error checking here.
// The wrapper function nth_percentile() has done all the error checking.

	decl sorted_data = sort( data );
	decl idx = int( ( sweep_size( sorted_data ) - 1 ) * ( 1 - percent / 100 ) );
	return sorted_data[idx];
}



defun nth_percentile_2d( data, percent ) {

// No need to do error checking here.
// The wrapper function nth_percentile() has done all the error checking.

	decl result = data[::,0];
	decl numPts = sweep_size( result );
	decl i;

	for ( i = 0; i < numPts; i++ ) {
		result[i] = nth_percentile_1d( data[i,::], percent );
	}

	return result;
}



defun nth_percentile_3d( data, percent ) {

// No need to do error checking here.
// The wrapper function nth_percentile() has done all the error checking.

	decl result = data[::,::,0];
	decl numPts = sweep_size( result[::,0] );
	decl i;

	for ( i = 0; i < numPts; i++ ) {
		result[i,::] = nth_percentile_2d( data[i,::,::], percent );
	}

	return result;
}

//************************************************************************
/*BEGIN_DOC
FUN_NAME: peak_to_avg_pwr()
FUN_DESCRIPTION: Returns the peak to average power ratio of the input voltage data
RETURNED_VALUE: Real
CATEGORY: Envelope, Signal Processing
SYNTAX: peak_avg_ratio = peak_to_avg_pwr(voltage, percent, unit) 
EXAMPLE:
peak_avg_ratio = peak_to_avg_pwr(Vout[1], , "ratio") 

where Vout is a named node in a Circuit Envelope simulation, will return the peak to average power ratio (as a ratio) at the fundamental frequency. 

peak_avg_ratio = peak_to_avg_pwr(T1, 5, "ratio")

where T1 is the name of a TimedSink component (in a DSP schematic), will return the ratio of the power level that is exceeded 5% of the time to the average power level for the voltage signal recorded in the TimedSink. If the signal recorded by the TimedSink is complex envelope Gaussian noise with the same standard deviation for both the I and Q envelopes, then peak_avg_ratio will be very close to 2.99 ( -ln(0.05) ). 

peak_avg_ratio = peak_to_avg_pwr(T1)

where T1 is the name of a TimedSink component (in a DSP schematic), will return the peak to average power ratio (in dB) for the voltage signal recorded in the TimedSink. If the signal recorded by the TimedSink is an ideal QPSK signal (filtered using a raised cosine filter of ExcessBW 0.5), then peak_avg_ratio will be very close to 3.95 dB. If the signal recorded by the TimedSink is an ideal /4-DQPSK signal (filtered using a raised cosine filter of ExcessBW 0.5), then peak_avg_ratio will be very close to 3.3 dB. 
ARGUMENT
  ARG_NAME: voltage
  ARG_DESCRIPTION: baseband or complex envelope voltage signal
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Integer, Real, Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: percent
  ARG_DESCRIPTION: percentage of time the returned power value is exceeded
  ARG_DEFAULT: 0.0
  ARG_RANGE: [0:100]
  ARG_TYPE: Real
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: unit
  ARG_DESCRIPTION: unit to be used
  ARG_DEFAULT: "dB"
  ARG_RANGE: "dB"|"ratio"
  ARG_TYPE: string
  ARG_REQUIRED: NO
DEFINED_IN: $HPEESOF_DIR/expressions/ael/digital_wireless_fun.ael
SEE ALSO: peak_pwr(), power_ccdf(), pwr_vs_t(), total_pwr() 
NOTES:
Used in Circuit Envelope simulation, Data Flow simulation. 

This expression can be used with input data (voltage) of any dimensions when the percent argument is 0 and up to three dimensions when the percent argument is greater than 0. It can handle both baseband as well as complex envelope data. 

The peak to average ratio is computed by calling the peak_pwr() and total_pwr() expressions and then taking the ratio of the two values returned by these expressions. The percent argument is used for the calculation of the peak power value. For the use and meaning of the percent argument see Notes/Equations of peak_power() expression. 

Since a ratio of power values is calculated a reference resistance is not needed for this measurement. 
EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/
//************************************************************************
defun peak_to_avg_pwr( voltage, percent, unit )
{
	if ( voltage == NULL ) {
		print_function_error( "peak_to_avg_pwr", " first argument (voltage) is a required argument." );
		return;
	}

	decl dataType = type( voltage );

	if ( strcmp( dataType, "Integer" ) && strcmp( dataType, "Real" ) && strcmp( dataType, "Complex" ) ) {
		print_function_error( "peak_to_avg_pwr", " first argument (voltage) can only be of type Integer, Real, or Complex." );
		return;
	}

	decl pct = ( percent == NULL ) ? ( 0.0 ) : ( percent );

	if ( pct < 0.0 || pct > 100.0 ) {
		print_function_error( "peak_to_avg_pwr", " third argument (percent) must be 0 <= percent <= 100." );
		return;
	}

	decl myUnit = ( unit == NULL ) ? ( "dB" ) : ( unit );

	if ( strcmp( myUnit, "dB" ) && strcmp( myUnit, "ratio" ) ) {
		print_function_error( "peak_to_avg_pwr", " fourth argument (unit) must be \"dB\" or \"ratio\"." );
		return;
	}

	if ( ( pct > 0.0 ) && ( sweep_dim( voltage ) > 3 ) ) {
		print_function_error( "peak_to_avg_pwr", " when third argument (percent) is greater than 0.0 only up to 3 dimensional data is supported." );
		return;
	}

	decl totalP = total_pwr( voltage, , "dBm" );
	decl peakP = peak_pwr( voltage, , pct, "dBm" );

	decl p_to_a = peakP - totalP;

	if ( ! strcmp( myUnit, "ratio" ) ) {
		p_to_a = 10**( 0.1 * p_to_a );
	}

	return p_to_a;
} //fun - peak_to_avg_pwr


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// fputs(stderr," Defining function calculate_scalefactors");
// This function is intended to only be called by the ACPR_ChPwr_or_EVM_from_1tone_swp() or Mod_Data_from_1tone_swpUNI() functions.
defun calculate_scalefactors( allowextrap, charPower, inputSig, sourceZ, debugFlag)
{
    decl sweepDim = sweep_dim(charPower);
    decl scaleFactors = NULL;
   
    switch (sweepDim) {
    case 0: print_function_error( "calculate_scalefactors", " does not support single number data.");
	return;
	break;
    case 1: scaleFactors = calculate_scalefactors_1d(allowextrap, charPower, inputSig, sourceZ, debugFlag);
	break;
    case 2: scaleFactors = calculate_scalefactors_2d(allowextrap, charPower, inputSig, sourceZ, debugFlag);		 
	break;
    default: print_function_error( "calculate_scalefactors", " does not support data with dimensions greater than two.");
	return;
	break;
    }

    return scaleFactors;
} // fun - calculate_scalefactors

// fputs(stderr," Defining function calculate_scalefactors_2d");
defun calculate_scalefactors_2d(allowextrap, charPower, inputSig, sourceZ, debugFlag)
{
   
    decl numPts=sweep_size(charPower[::,0]);
    decl scalefactors_array=create(2,"Real",{"indepVar1","InputPower_Index"},{"Real","Real"}, 1, 1);  // this just initializes the result variable.
    decl indepVar1=indep(scalefactors_array,"indepVar1");
    decl InputPower_Index=indep(scalefactors_array,"InputPower_Index");
    decl outerIndep=indep(charPower[0]);
    decl temp;
    decl sourceZparam;
    decl i;
    for (i=0; i<numPts; i++)
    {
	sourceZparam=if (sweep_dim(sourceZ)==1) then sourceZ[i] else sourceZ endif; // this handles the case where sourceZ is the swept parameter
	temp=calculate_scalefactors_1d(allowextrap, charPower[i,::], inputSig, sourceZparam, debugFlag);
	scalefactors_array[i,::]=temp;
	InputPower_Index[i,::]=[0::sweep_size(temp)-1];
    }
    indepVar1[::]=outerIndep[::];
    return scalefactors_array;
} //fun - calculate_scalefactors_2d

// fputs(stderr," Defining function calculate_scalefactors_1d");
defun calculate_scalefactors_1d( allowextrap, charPower, inputSig, sourceZ, debugFlag)
{
/* *********************************************************************************
   Function:	calculate_scalefactors_1d
   --------------------------------
   Returns:	An array of scale factors for creating an array of scaled waveforms.
   The array of scaled waveforms is used as pseudo power-swept waveforms
   for doing ACPR and Channel Power analysis
   --------------------------------
   Arguments: 
   1) allowextrap	-flag for allowing extrapolation.  If set to 1, the scalefactors
   used to create the pseudo-power-swept modulated data will be 
   created from -30 dB to the the max input signal power (from the harmonic balance sweep.)
   If set to 0, extrapolation is not allowed and scale factors that
   cause the modulated signal power to exceed the power of the HB
   sweep are omitted.
   2) charPower	-Power of the HB sweep used to characterize the DUT
   3) inputSig	-The input modulated signal
   4) sourceZ	-Source impedance
   5) debugFlag	-if set to 0, do not print debug messages.  Otherwise print them
   --------------------------------
   Usage:		This function is called from functions Mod_Data_from_1tone_swpUNI and 
   ACPR_ChPwr_or_EVM_from_1tone_swp.
   --------------------------------
   History:
   12/12/2006	Created based upon the script that AEH generated
   ********************************************************************************* */

    if(debugFlag)
    {
	fprintf(stderr,"    IN FUNCTION calculate_scaleFactors\n");
    }

/**************************************************************************
   CALCULATE SCALE FACTORS.  
   THIS IS USED TO CONVERT THE INPUT MODULATED SIGNAL INTO AN ARRAY OF SCALED SIGNALS.  
   THIS CREATES A "PSEUDO" POWER SWEEP WHICH IS REQUIRED FOR THE BUILT-IN ACPR FUNCTION.
   THIS OPERATION IS WHERE WE LOSE ANY REAL WORLD AFFECTS AS THIS DOES NOT ACCOUNT FOR ANY
   FREQUENCY DEPENDANCIES, MEMORY AFFECTS, ETC.
   THE RANGE WILL BE 17 VALUES FROM 30 dB BELOW THE MAX INPUT HB SIGNAL POWER TO THE MAX 
   INPUT HB SIGNAL POWER. THESE VALUES ARE NOT EQUALLY SPACED.  THE SPACING IS LARGER AT
   LOWER INPUT POWER LEVELS AND SMALLER AT HIGHER INPUT POWER LEVELS.  THIS ALSO ASSUMES 
   THE INPUT MODULATED SIGNAL POWER LEVEL IS 0 dBm, SO WE MUST CALCULATE THE SIGNAL POWER 
   AND USE THIS TO OFFSET THE  POWER LEVEL TO MAKE SURE THAT IT IS ZERO 
****************************************************************************/
    decl minPwr=min(charPower);
    decl maxPwr=max(charPower);
    decl inputSig_W=mean(0.5*real(inputSig*conj(inputSig/sourceZ)));
    decl inputSig_dBm=10*log(inputSig_W)+30;
    // decl dB_range=[maxPwr-30-inputSig_dBm::2::maxPwr-inputSig_dBm]; // dB_range was defined this way, originally
    decl dB_range1=[maxPwr-30-inputSig_dBm::2.5::maxPwr-inputSig_dBm-7.5];  // use a larger step size at lower input power levels
    decl dB_range2=[maxPwr-inputSig_dBm-6::1::maxPwr-inputSig_dBm];  // use a smaller step size at higher input power levels
    decl dB_range=[dB_range1,dB_range2];
    decl dB_rangefinal;

/**************************************************************************
   BEFORE RETURNING THE SCALE FACTORS, CHECK TO SEE IF THE USER WILL ALLOW EXTRAPOLATION.  
   THIS OCCURS WHEN THE POWER OF THE SCALED MODULATED SIGNAL IS LARGER THAN THE POWER
   OF THE HB SIGNAL USED TO CHARACTERIZE THE DUT.  IF EXTRAPOLATION IS NOT ALLOWED, THE 
   SCALE FACTORS THAT CAUSE EXTRAPOLATION WILL BE THROWN OUT.
   THE POWER OF THE MODULATED SIGNAL IS CALCULATED USING THE COMMAND "dBm" WHICH 
   WORKS AS FOLLOWS:

	Po = (Vo)2/(2*Zo) 
 
	Using the above, Po in dBm is then: 

	Po_dBm = 10*log(mag(Po/(1 W))) + 30 
 	       = 10*log(mag((Vo/(1 V))2/(2*Zo/(1 Ohm)))) + 30 
 	       = 10*log(mag((Vo/(1 V))2)) - 10*log(mag(2*Zo/(1 Ohm))) + 30 
 	       = 20*log(mag(Vo/(1 V))) - 10*log(mag(Zo/(50 Ohm))) + 10 
 
   NOTE THAT IF Vo=0, THIS CAUSES AN ERROR AS log(0) IS NOT VALID.  
   FOR THIS REASON, A SMALL OFFSET OF 1E-10 IS ADDED 
****************************************************************************/
   
    if(!allowextrap)
    {
	if(debugFlag)
	{
	    fputs(stderr, "    EXTRAPOLATION IS NOT ALLOWED");
	}

	decl InputSigPwr=dBm(inputSig+1e-10,conj(sourceZ));
	decl maxInputSigPwr=max(InputSigPwr); 
	decl dB_rangeSwpSize=sweep_size(dB_range);
	decl n=0;
	decl h=0;
	for (h=0; h<dB_rangeSwpSize; h++)
	{
	    n= if ((dB_range[h]+maxInputSigPwr) > maxPwr) then n+1 else n;
	}
	decl maxIndex=if ((dB_rangeSwpSize-1-n) >0) then (dB_rangeSwpSize-1-n) else 0;
	dB_rangefinal=dB_range[0::maxIndex];
    }
    else
    {
	if(debugFlag)
	{
	    fputs(stderr, "    EXTRAPOLATION IS ALLOWED");
	}
	dB_rangefinal=dB_range;
    }
    decl scaleFactors=10**(dB_rangefinal/20);
    return( scaleFactors );
}

// fputs(stderr," Defining function calculate_scalefactors_1d_r1");
defun calculate_scalefactors_1d_r1( allowextrap, charPower, inputSig, inputSigPowers, sourceZ, debugFlag)
{
/* *********************************************************************************
   Function:	calculate_scalefactors_1d_r1
   --------------------------------
   Returns:	An array of scale factors for creating an array of scaled waveforms.
   The array of scaled waveforms is used as pseudo power-swept waveforms
   for doing ACPR and Channel Power analysis
   --------------------------------
   Arguments: 
   1) allowextrap	-flag for allowing extrapolation.  If set to 1, the scalefactors
   used to create the pseudo-power-swept modulated data will be 
   created from the inputSigPowers (units of dBm) passed into the function.
   If set to 0, extrapolation is not allowed and scale factors that
   cause the modulated signal power to exceed the power of the HB
   sweep are omitted.
   2) charPower	-Power of the HB sweep used to characterize the DUT
   3) inputSig	-The input modulated signal
   4) inputSigPowers  -An array of desired input signal powers
   5) sourceZ	-Source impedance
   6) debugFlag	-if set to 0, do not print debug messages.  Otherwise print them
   --------------------------------
   Usage:		This function is called from functions Mod_Data_from_1tone_swpUNI_r1 and 
   ACPR_ChPwr_or_EVM_from_1tone_swp_r1.
   --------------------------------
   History:
   12/12/2006	Created based upon the script that AEH generated
   05/2013		Updated by AEH
   ********************************************************************************* */

    if(debugFlag)
    {
		fprintf(stderr,"    IN FUNCTION calculate_scaleFactors_1d_r1\n");
    }

/**************************************************************************
   CALCULATE SCALE FACTORS.  
   THIS IS USED TO CONVERT THE INPUT MODULATED SIGNAL INTO AN ARRAY OF SCALED SIGNALS.  
   THIS CREATES A "PSEUDO" POWER SWEEP WHICH IS REQUIRED FOR THE BUILT-IN ACPR FUNCTION.
   THIS OPERATION IS WHERE WE LOSE ANY REAL WORLD AFFECTS AS THIS DOES NOT ACCOUNT FOR ANY
   FREQUENCY DEPENDANCIES, MEMORY EFFECTS, ETC.
****************************************************************************/
    decl maxPwr=max(charPower);  
	decl sourceZ_checked=if (sweep_dim(sourceZ)==1) then sourceZ[0] else sourceZ;
	decl Pavail_W=0.5*real(inputSig*conj(inputSig/conj(sourceZ_checked)));
    decl Pavail_W_mean=mean(Pavail_W);
	decl Pavail_W_mean_checked = if (Pavail_W_mean==0) then 1e-10 else Pavail_W_mean;
    decl Pavail_dBm_mean=10*log(Pavail_W_mean_checked)+30;
	decl ScaleFactors=10**((inputSigPowers-Pavail_dBm_mean)/20);
	decl ScaleFactorsFinal=ScaleFactors;

/**************************************************************************
   BEFORE RETURNING THE SCALE FACTORS, CHECK TO SEE IF THE USER WILL ALLOW EXTRAPOLATION.  
   THIS OCCURS WHEN THE INSTANTANEOUS POWER OF THE SCALED MODULATED SIGNAL IS LARGER THAN THE POWER
   OF THE HB SIGNAL USED TO CHARACTERIZE THE DUT.  IF EXTRAPOLATION IS NOT ALLOWED, THE 
   SCALE FACTORS THAT CAUSE EXTRAPOLATION WILL BE THROWN OUT.
****************************************************************************/
   
    if(!allowextrap)
    {
		if(debugFlag)
		{
			fputs(stderr, "    EXTRAPOLATION IS NOT ALLOWED");
		}
		decl extrapErrorFlag = 0;
		decl maxIndex;
		decl Pavail_W_checked = if (Pavail_W==0) then 1e-10 else Pavail_W;
		decl Pavail_dBm_unscaled=10*log(Pavail_W_checked)+30;
		decl maxPavail_dBm_unscaled=max(Pavail_dBm_unscaled); 
		decl inputSigPowersSwpSize=sweep_size(inputSigPowers);
		decl scaledInputSig=expand(ScaleFactors)*inputSig;
		decl Pavail_W_scaled=0.5*real(scaledInputSig*conj(scaledInputSig/conj(sourceZ_checked)));
		decl Pavail_W_scaled_checked = if (Pavail_W_scaled==0) then 1e-10 else Pavail_W_scaled;
		decl Pavail_dBm_scaled=10*log(Pavail_W_scaled_checked)+30;
		decl n=0;
		decl h=0;
		for (h=0; h<inputSigPowersSwpSize; h++)
		{
		    n= if (max(Pavail_dBm_scaled[h,::]) > maxPwr) then n+1 else n;
		}
		if ((inputSigPowersSwpSize-1-n) >= 0)  // This was originally just >0.
		{
			maxIndex = inputSigPowersSwpSize-1-n;
		} else 
		{
			print_function_error( "calculate_scalefactors_1d_r1", "Extrapolation will occur for all specified inputSigPowers.  Try specifying lower values for inputSigPowers parameter. ");
			return;		
		}
		ScaleFactorsFinal=ScaleFactors[0::maxIndex];  
		return ScaleFactorsFinal;
    }
    else
    {
		if(debugFlag)
		{
			fputs(stderr, "    EXTRAPOLATION IS ALLOWED");
		}
		return ScaleFactorsFinal;
    }
}

// fputs(stderr, " Defining function approxVoutVin");
// This function is intended to only be called by the ACPR_ChPwr_or_EVM_from_1tone_swp() or Mod_Data_from_1tone_swpUNI() functions.
defun approxVoutVin(algorithm,charVoltage,sourceZ,modulatedInput,scaleFactors,debugFlag)
{
    decl sweepDim = sweep_dim(charVoltage);
    decl resultList = NULL; 
   
    switch (sweepDim) {
    case 0: print_function_error( "approxVoutVin", " does not support single number data.");
	return;
	break;
    case 1: resultList = approxVoutVin_1d(algorithm,charVoltage,sourceZ,modulatedInput,scaleFactors,debugFlag);
	break;
    case 2: resultList = approxVoutVin_2d(algorithm,charVoltage,sourceZ,modulatedInput,scaleFactors,debugFlag);	 
	break;
    default: print_function_error( "approxVoutVin", " does not support data with dimensions greater than two.");
	return;
	break;
    }

    return resultList;
} // fun - approxVoutVin

// fputs(stderr, " Defining function approxVoutVin_2d");
defun approxVoutVin_2d(algorithm,charVoltage,sourceZ,modulatedInput,scaleFactors,debugFlag)
{
    decl numPts_i=sweep_size(charVoltage[::,0]);
    decl numPts_j=sweep_size(scaleFactors[0,::]);
    decl vout_array=create(3,"Complex",{"indepVar1","InputPower_Index","time"},{"Real","Real","Real"}, 1, 1);  // this just initializes the first result variable.
    // decl magFit_array=create(2,"Real",{"indepVar1","RFpower"},{"Real","Real"}, 1, 1);  // this just initializes the second result variable. To save time, this and the phaseFit_array are not ouput.
    // decl phaseFit_array=create(2,"Real",{"indepVar1","RFpower"},{"Real","Real"}, 1, 1);  // this just initializes the third result variable.
    decl scaledInputSig_array=create(3,"Complex",{"indepVar1","InputPower_Index","time"},{"Real","Real","Real"}, 1, 1);  // this just initializes the fourth result variable.
    decl pointerX1=indep(vout_array,"indepVar1");
    // decl pointerX2=indep(magFit_array,"indepVar1");
    // decl pointerX3=indep(phaseFit_array,"indepVar1");
    decl pointerX4=indep(scaledInputSig_array,"indepVar1");
    decl Power_IndexPointer1=indep(vout_array,"InputPower_Index");
    decl Power_IndexPointer2=indep(scaledInputSig_array,"InputPower_Index");
    decl time=indep(modulatedInput,"time");  
    // decl pointerY1=indep(magFit_array,"RFpower");
    // decl pointerY2=indep(phaseFit_array,"RFpower");
    decl pointerT1=indep(vout_array,"time");
    pointerT1=time;                           
   
    decl outerIndep=indep(charVoltage[0]);
    decl secondIndep=indep(scaleFactors[0,::]);
    // decl temp=list(vout_array[0,::,::], magFit_array[0,::], phaseFit_array[0,::], scaledInputSig_array[0,::,::]);
    decl temp=list(vout_array[0,::,::], scaledInputSig_array[0,::,::]);
    decl sourceZparam;
    decl i;
    decl j;
    for (i=0; i<numPts_i; i++)
    {
	sourceZparam=if (sweep_dim(sourceZ)==1) then sourceZ[i] else sourceZ endif; // this handles the case where sourceZ is the swept parameter
	temp=approxVoutVin_1d(algorithm, charVoltage[i,::], sourceZparam, modulatedInput, scaleFactors[i,::], debugFlag);
	for (j=0; j<numPts_j; j++)
	{
	    vout_array[i,j,::]=temp(0)[j,::];
	    scaledInputSig_array[i,j,::]=temp(1)[j,::];
	}
	Power_IndexPointer1[::]=secondIndep[::];
	Power_IndexPointer2[::]=secondIndep[::];
	
	// if (algorithm=="CF")
	// {
	//  pointerY1[i,::]=indep(charVoltage[i,::]);
	//  pointerY2[i,::]=indep(charVoltage[i,::]);
	// } else if (algorithm=="LI")
	// {
	//  pointerY1[i,::]=indep(temp(1));
	//  pointerY2[i,::]=indep(temp(2));
	// }
	// magFit_array[i,::]=temp(1);
	// phaseFit_array[i,::]=temp(2);
    }
    pointerX1[::]=outerIndep[::];
    // pointerX2[::]=outerIndep[::];
    // pointerX3[::]=outerIndep[::];
    pointerX4[::]=outerIndep[::];
    // return list(vs(vout_array,time), magFit_array, phaseFit_array, vs(scaledInputSig_array,time));
    return list(vs(vout_array,time), vs(scaledInputSig_array,time));
} //fun - approxVoutVin_2d

// fputs(stderr, " Defining function approxVoutVin_1d");
defun approxVoutVin_1d(algorithm,charVoltage,sourceZ,modulatedInput,scaleFactors,debugFlag)
{
/* *********************************************************************************
   Function: approxVoutVin_1d
   --------------------------------
   Returns:	An array that contains the following:
   element 0: output voltage from applying the scaled input modulated signal
   to the modeled output curve.  The output curve is modeled either
   as a curve fit or a linear interpolation
   element 1: the scaled modulated signal
   *** The outputs below have been turned off to save time and memory. ***
   the modeled magnitude response
   the modeled phase response
   --------------------------------
   Arguments: 
   1) algorithm	-flag for approximating transfer function (vout/vin).  Set to
   "CF" to use curve fit, "LI" to use Linear Interpolation
   2) charVoltage	-output voltage from the HB sweep
   3) sourceZ	-Source impedance
   4) modulatedInput	-The input modulated signal
   5) scaleFactors -array of scaling factors
   6) debugFlag	-if set to 0, do not print debug messages.  Otherwise print them
   --------------------------------
   Usage:		This function is called from functions Mod_Data_from_1tone_swpUNI and 
   ACPR_ChPwr_or_EVM_from_1tone_swp.
   --------------------------------
   History:
   12/12/2006	Created based upon the script that AEH generated
   ********************************************************************************* */
    if(debugFlag)
    {
	fputs(stderr,"  CALCULATING SCALED INPUT SIGNAL AND RESULTING OUTPUT SIGNAL.....");
    }
    // decl magFit;
    // decl phaseFit;
    decl charPower=indep(charVoltage);
    decl minPwr=min(charPower);
    decl maxPwr=max(charPower);
    decl vin_fromHBswp=sqrt((1/real(1/sourceZ))*2*10**((charPower-30)/10));

    if (algorithm=="CF")
    {
	if(debugFlag)
	{
	    fputs(stderr,"    USING CURVE FIT ALGORITHM TO APPROXIMATE TRANSFER FUNCTION");
	}

/**************************************************************************
   SCALE THE INPUT MODULATED SIGNAL.  DOING THIS LOSES THE TIME FACTOR AS THE 
   INDEPENDANT ELEMENT SO WE NEED TO ADD TIME BACK AS THE INDEPENDANT VARIABLE.
****************************************************************************/

	decl scaledInputSig=expand(scaleFactors)*modulatedInput;
	decl maxInputSig=max(max(mag(scaledInputSig)));
	decl time=indep(modulatedInput);
	decl vin=vs(scaledInputSig,time);

/**************************************************************************
   CALCULATE THE CURVE FIT TO APPROXIMATE THE TRANSFER FUNCTION OF THE DUT
****************************************************************************/
	decl minVin=sqrt(2*(1/real(1/sourceZ))*10**((minPwr-30)/10));
	decl maxVin=sqrt(2*(1/real(1/sourceZ))*10**((maxPwr-30)/10));  
	decl h1=if(minVin !=NULL) then find_index(vin_fromHBswp,minVin) else 0;
	decl h2=if(maxVin !=NULL) then find_index(vin_fromHBswp,maxVin) else sweep_size(charVoltage)-1;
	decl x=vin_fromHBswp[h1::1::h2];
	//decl maxvin_fromHBswp=max(x);
	//decl fullScaleFraction=maxInputSig/maxvin_fromHBswp;
	decl magData=mag(charVoltage);
	decl phaseData=unwrap(phaserad(charVoltage),pi);
	decl y1=magData[h1::1::h2];
	decl y2=phaseData[h1::1::h2];
	decl meanx=mean(x);
	decl meanx2=mean(x**2);
	decl meanx3=mean(x**3);
	decl meanx4=mean(x**4);
	decl meanx5=mean(x**5);
	decl meanx6=mean(x**6);
	decl meanx7=mean(x**7);
	decl meanx8=mean(x**8);
	decl meanx9=mean(x**9);
	decl meanx10=mean(x**10);

	decl row1={1,meanx,meanx2,meanx3,meanx4,meanx5};
	decl row2={meanx,meanx2,meanx3,meanx4,meanx5,meanx6};
	decl row3={meanx2,meanx3,meanx4,meanx5,meanx6,meanx7};
	decl row4={meanx3,meanx4,meanx5,meanx6,meanx7,meanx8};
	decl row5={meanx4,meanx5,meanx6,meanx7,meanx8,meanx9};
	decl row6={meanx5,meanx6,meanx7,meanx8,meanx9,meanx10};

	decl mat_a={row1,row2,row3,row4,row5,{meanx5,meanx6,meanx7,meanx8,meanx9,meanx10}};
	decl v1={mean(y1),mean(x*y1),mean(x**2*y1),mean(x**3*y1),mean(x**4*y1),mean(x**5*y1)};
	decl v2={mean(y2),mean(x*y2),mean(x**2*y2),mean(x**3*y2),mean(x**4*y2),mean(x**5*y2)};
	decl bm=v1/mat_a;
	decl bp=v2/mat_a;
	// magFit=bm(1)+vin_fromHBswp*bm(2)+vin_fromHBswp**2*bm(3)+vin_fromHBswp**3*bm(4)+vin_fromHBswp**4*bm(5)+vin_fromHBswp**5*bm(6);
	// phaseFit=bp(1)+vin_fromHBswp*bp(2)+vin_fromHBswp**2*bp(3)+vin_fromHBswp**3*bp(4)+vin_fromHBswp**4*bp(5)+vin_fromHBswp**5*bp(6);
 
/**************************************************************************
   APPLY THE CURVE FIT TO THE SCALED INPUT SIGNAL ARRAY TO APPROXIMATE THE OUTPUT OF
   THE DUT WHEN THE MODULATED SIGNAL IS APPLIED
****************************************************************************/
	decl mag_vin=mag(vin);
	decl magVout=bm(1)+mag_vin*bm(2)+mag_vin**2*bm(3)+mag_vin**3*bm(4)+mag_vin**4*bm(5)+mag_vin**5*bm(6);
	decl phaseRadVout=bp(1)+mag_vin*bp(2)+mag_vin**2*bp(3)+mag_vin**3*bp(4)+mag_vin**4*bp(5)+mag_vin**5*bp(6);
	decl voutCF=magVout*exp(j*(phaserad(scaledInputSig)+phaseRadVout));
	if(debugFlag)
	{
	    fputs(stderr, "    CF APPROXIMATION DONE");
	}
	// return list(voutCF,magFit,phaseFit,scaledInputSig);
	return list(voutCF, scaledInputSig);
    } else if (algorithm=="LI")
    {
	if(debugFlag)
	{
	    fputs(stderr,"    USING LINEAR INTERPOLATION ALGORITHM TO APPROXIMATE TRANSFER FUNCTION");
	}

/**************************************************************************
   SCALE THE INPUT MODULATED SIGNAL.  DOING THIS LOSES THE TIME FACTOR AS THE 
   INDEPENDANT ELEMENT SO WE NEED TO ADD TIME BACK AS THE INDEPENDANT VARIABLE.
****************************************************************************/

	decl time=indep(modulatedInput);
	decl timeSwpSize=sweep_size(time);
	decl scaledInputSig=expand(scaleFactors)*modulatedInput;
	decl vin=vs(scaledInputSig,time);

/**************************************************************************
   WITH LINEAR INTERPOLATION, THE INDEX VALUES OF THE OUTPUT VOLTAGE ARE DETERMINED
   BY THE INDICES OF THE INPUT POWER LEVELS.  WE WILL THEREFORE CALCULATE THE SCALED INPUT POWER. 
   CONVERT THE SCALEFACTOR ARRAY TO POWER LEVELS AND SIMPLY ADD THE POWER LEVELS OF THE 
   INPUT SIGNAL WITH THE POWER SCALING FACTORS.  ONCE CALULATED, ADD TIME BACK AS THE
   INDEPENDANT VARIABLE.
****************************************************************************/

	decl powerScale = 20*log(scaleFactors);
	decl dB_rangeSwpSize=sweep_size(powerScale);
	decl InputSigPwr=dBm(modulatedInput+1e-10,conj(sourceZ));

	// This equation is only used to give scaledInputSigPwr the correct dimensionality
	decl scaledInputSigPwr=expand(powerScale)*InputSigPwr;

	decl j=0;
	for (j=0; j<dB_rangeSwpSize; j++)
	{
	    scaledInputSigPwr[j,::]=InputSigPwr+powerScale[j];
	}
	decl Pin=vs(scaledInputSigPwr,time);

	decl voutLI=vin;
	decl magVout=mag(voutLI);
	decl phaseRadVout=phaserad(voutLI);
	decl i=0;
	decl k=0;
	decl minGain=mag(charVoltage[0]/vin_fromHBswp[0]);
	decl indexVal=0;
	decl magData=mag(charVoltage);
	decl phaseData=unwrap(phaserad(charVoltage),pi);

	decl magDataInterp=interp(magData,,,0.01);              // This value affects the minimum ACPR that can be calculated
	decl phaseDataInterp=interp(phaseData,,,0.01);          // This value affects the minimum ACPR that can be calculated
	decl interpSwpSize=sweep_size(magDataInterp);
	decl interpSwpSize_m1=interpSwpSize-1;
	decl temp_product=1/(maxPwr-minPwr)*interpSwpSize_m1;
	decl temp_vin_ik = 0;
	decl temp_magVout_ik = 0;
	decl temp_phaseRadVout_ik = 0;

	for (i=0; i<dB_rangeSwpSize; i++)
	{
	    for (k=0; k<timeSwpSize; k++)
	    {
		temp_vin_ik = vin[i,k];
		
		if (mag(temp_vin_ik)<mag(vin_fromHBswp[0]))
		{ 
		    temp_magVout_ik=minGain*mag(temp_vin_ik);
		    temp_phaseRadVout_ik=phaserad(charVoltage[0])+phaserad(temp_vin_ik);  
		}
		else
		{
		    indexVal=int((Pin[i,k]-minPwr)*temp_product);
		    indexVal=if (indexVal > interpSwpSize_m1) then interpSwpSize_m1 else indexVal;
		    temp_magVout_ik=magDataInterp[indexVal];
		    temp_phaseRadVout_ik=phaseDataInterp[indexVal]+phaserad(temp_vin_ik);
		}  
		voutLI[i,k]=polar(temp_magVout_ik,temp_phaseRadVout_ik*180/pi);

	    }
	} //CLOSE OUTER FOR LOOP

	if(debugFlag)
	{
	    fputs(stderr, "    LI APPROXIMATION DONE");
	}

	// return list(voutLI,magDataInterp,phaseDataInterp,scaledInputSig);
	return list(voutLI, scaledInputSig);
    } //CLOSE ALGORITHM IF BLOCK 
}  

// fputs(stderr, " Defining function approxVoutVin_1d_r1");
defun approxVoutVin_1d_r1(algorithm,allowextrap,charVoltage,sourceZ,modulatedInput,scaleFactors,debugFlag)
{
/* *********************************************************************************
   Function: approxVoutVin_1d_r1
   --------------------------------
   Returns:	An array that contains the following:
   element 0: output voltage from applying the scaled input modulated signal
   to the modeled output curve.  The output curve is modeled either
   as a curve fit or a linear interpolation
   element 1: the scaled modulated signal											
   *** The outputs below have been turned off to save time and memory. ***
   the modeled magnitude response
   the modeled phase response
   --------------------------------
   Arguments: 
   1) algorithm	-flag for approximating transfer function (vout/vin).  Set to
   "CF" to use curve fit, "LI" to use Linear Interpolation
   2) allowextrap  - a flag to indicate whether extrapolation will be allowed or not.
   3) charVoltage	-output voltage from the HB sweep
   4) sourceZ	-Source impedance
   5) modulatedInput	-The input modulated signal
   6) scaleFactors -array of scaling factors
   7) debugFlag	-if set to 0, do not print debug messages.  Otherwise print them
   --------------------------------
   Usage:		This function is called from functions Mod_Data_from_1tone_swpUNI_r1 and 
   ACPR_ChPwr_or_EVM_from_1tone_swp_r1.
   --------------------------------
   History:
   12/12/2006	Created based upon the script that AEH generated
   05/2013		Modified slightly by AEH to handle case where scaleFactors is just a single value.
   12/2013		Modified by AEH to handle extrapolation based on setting of boolean "allowextrap" variable
   ********************************************************************************* */
    if(debugFlag)
    {
		fputs(stderr,"  CALCULATING SCALED INPUT SIGNAL AND RESULTING OUTPUT SIGNAL.....");
    }

    decl charPower=indep(charVoltage);
    decl minPwr=min(charPower);
    decl maxPwr=max(charPower);
    decl vin_fromHBswp=sqrt((1/real(1/sourceZ))*2*10**((charPower-30)/10));

    if (algorithm=="CF")
    {
		if(debugFlag)
		{
			fputs(stderr,"    USING CURVE FIT ALGORITHM TO APPROXIMATE TRANSFER FUNCTION");
		}

		/**************************************************************************
		SCALE THE INPUT MODULATED SIGNAL.  DOING THIS LOSES THE TIME FACTOR AS THE 
		INDEPENDANT ELEMENT SO WE NEED TO ADD TIME BACK AS THE INDEPENDANT VARIABLE.
		****************************************************************************/
		decl scaledInputSig=expand(scaleFactors)*modulatedInput;
		decl maxInputSig=max(max(mag(scaledInputSig)));
		decl time=indep(modulatedInput);
		decl vin=vs(scaledInputSig,time);

		/**************************************************************************
		CALCULATE THE CURVE FIT TO APPROXIMATE THE TRANSFER FUNCTION OF THE DUT
		****************************************************************************/
		decl minVin=sqrt(2*(1/real(1/sourceZ))*10**((minPwr-30)/10));
		decl maxVin=sqrt(2*(1/real(1/sourceZ))*10**((maxPwr-30)/10));  
		decl h1=if(minVin !=NULL) then find_index(vin_fromHBswp,minVin) else 0;
		decl h2=if(maxVin !=NULL) then find_index(vin_fromHBswp,maxVin) else sweep_size(charVoltage)-1;
		decl x=vin_fromHBswp[h1::1::h2];
		//decl maxvin_fromHBswp=max(x);
		//decl fullScaleFraction=maxInputSig/maxvin_fromHBswp;
		decl magData=mag(charVoltage);
		decl phaseData=unwrap(phaserad(charVoltage),pi);
		decl y1=magData[h1::1::h2];
		decl y2=phaseData[h1::1::h2];
		decl meanx=mean(x);
		decl meanx2=mean(x**2);
		decl meanx3=mean(x**3);
		decl meanx4=mean(x**4);
		decl meanx5=mean(x**5);
		decl meanx6=mean(x**6);
		decl meanx7=mean(x**7);
		decl meanx8=mean(x**8);
		decl meanx9=mean(x**9);
		decl meanx10=mean(x**10);

		decl row1={1,meanx,meanx2,meanx3,meanx4,meanx5};
		decl row2={meanx,meanx2,meanx3,meanx4,meanx5,meanx6};
		decl row3={meanx2,meanx3,meanx4,meanx5,meanx6,meanx7};
		decl row4={meanx3,meanx4,meanx5,meanx6,meanx7,meanx8};
		decl row5={meanx4,meanx5,meanx6,meanx7,meanx8,meanx9};
		decl row6={meanx5,meanx6,meanx7,meanx8,meanx9,meanx10};

		decl mat_a={row1,row2,row3,row4,row5,{meanx5,meanx6,meanx7,meanx8,meanx9,meanx10}};
		decl v1={mean(y1),mean(x*y1),mean(x**2*y1),mean(x**3*y1),mean(x**4*y1),mean(x**5*y1)};
		decl v2={mean(y2),mean(x*y2),mean(x**2*y2),mean(x**3*y2),mean(x**4*y2),mean(x**5*y2)};
		decl bm=v1/mat_a;
		decl bp=v2/mat_a;
		// magFit=bm(1)+vin_fromHBswp*bm(2)+vin_fromHBswp**2*bm(3)+vin_fromHBswp**3*bm(4)+vin_fromHBswp**4*bm(5)+vin_fromHBswp**5*bm(6);
		// phaseFit=bp(1)+vin_fromHBswp*bp(2)+vin_fromHBswp**2*bp(3)+vin_fromHBswp**3*bp(4)+vin_fromHBswp**4*bp(5)+vin_fromHBswp**5*bp(6);
 
		/**************************************************************************
		APPLY THE CURVE FIT TO THE SCALED INPUT SIGNAL ARRAY TO APPROXIMATE THE OUTPUT OF
		THE DUT WHEN THE MODULATED SIGNAL IS APPLIED
		****************************************************************************/
		decl mag_vin=mag(vin);
		mag_vin=if ((mag_vin>maxVin) && (!allowextrap)) then maxVin else mag_vin;
		decl magVout=bm(1)+mag_vin*bm(2)+mag_vin**2*bm(3)+mag_vin**3*bm(4)+mag_vin**4*bm(5)+mag_vin**5*bm(6);
		decl phaseRadVout=bp(1)+mag_vin*bp(2)+mag_vin**2*bp(3)+mag_vin**3*bp(4)+mag_vin**4*bp(5)+mag_vin**5*bp(6);
		decl voutCF=magVout*exp(j*(phaserad(scaledInputSig)+phaseRadVout));
		if(debugFlag)
		{
			fputs(stderr, "    CF APPROXIMATION DONE");
		}	
		return list(voutCF, scaledInputSig);
    } else if (algorithm=="LI")
    {
		if(debugFlag)
		{
			fputs(stderr,"    USING LINEAR INTERPOLATION ALGORITHM TO APPROXIMATE TRANSFER FUNCTION");
		}
		/**************************************************************************
		SCALE THE INPUT MODULATED SIGNAL.  DOING THIS LOSES THE TIME FACTOR AS THE 
		INDEPENDANT ELEMENT SO WE NEED TO ADD TIME BACK AS THE INDEPENDANT VARIABLE.
		****************************************************************************/
		decl time=indep(modulatedInput);
		decl timeSwpSize=sweep_size(time);
		decl scaledInputSig=expand(scaleFactors)*modulatedInput;
		decl vin=vs(scaledInputSig,time);

		/**************************************************************************
		WITH LINEAR INTERPOLATION, THE INDEX VALUES OF THE OUTPUT VOLTAGE ARE DETERMINED
		BY THE INDICES OF THE INPUT POWER LEVELS.  WE WILL THEREFORE CALCULATE THE SCALED INPUT POWER, 
		CONVERT THE SCALEFACTOR ARRAY TO POWER LEVELS AND SIMPLY ADD THE POWER LEVELS OF THE 
		INPUT SIGNAL WITH THE POWER SCALING FACTORS.  ONCE CALULATED, ADD TIME BACK AS THE
		INDEPENDANT VARIABLE.
		****************************************************************************/

		decl powerScale = 20*log(scaleFactors);
		decl dB_rangeSwpSize=sweep_size(powerScale);
		decl InputSigPwr=dBm(modulatedInput+1e-10,conj(sourceZ));

		// This equation is only used to give scaledInputSigPwr the correct dimensionality
		decl scaledInputSigPwr=expand(powerScale)*InputSigPwr;

		decl j=0;
		if (sweep_dim(powerScale)<1)
		{
			scaledInputSigPwr[0,::]=InputSigPwr+powerScale;
		} else
		{
			for (j=0; j<dB_rangeSwpSize; j++)
			{	
				scaledInputSigPwr[j,::]=InputSigPwr+powerScale[j];
			}		
		}
		decl Pin=vs(scaledInputSigPwr,time);

		decl voutLI=vin;
		decl magVout=mag(voutLI);
		decl phaseRadVout=phaserad(voutLI);
		decl i=0;
		decl k=0;
		decl minGain=mag(charVoltage[0]/vin_fromHBswp[0]);
		decl indexVal=0;
		decl mag_charVoltage=mag(charVoltage);
		decl phase_charVoltage=unwrap(phaserad(charVoltage),pi);
		decl indep_charVoltage=indep(charVoltage);					// This should be the available source power from the HB sweep.
		decl charVoltageLastIndex=sweep_size(charVoltage)-1;
		decl charVoltageLastIndex_m1=charVoltageLastIndex-1;
		decl mag_charVoltageSlope=(mag_charVoltage[charVoltageLastIndex]-mag_charVoltage[charVoltageLastIndex_m1])/(indep_charVoltage[charVoltageLastIndex]-indep_charVoltage[charVoltageLastIndex_m1]);
		decl phase_charVoltageSlope=(phase_charVoltage[charVoltageLastIndex]-phase_charVoltage[charVoltageLastIndex_m1])/(indep_charVoltage[charVoltageLastIndex]-indep_charVoltage[charVoltageLastIndex_m1]);

		decl magDataInterp=interp(mag_charVoltage,,,0.01);              // This value affects the minimum ACPR that can be calculated
		decl phaseDataInterp=interp(phase_charVoltage,,,0.01);          // This value affects the minimum ACPR that can be calculated
		decl interpSwpSize=sweep_size(magDataInterp);
		decl interpSwpSize_m1=interpSwpSize-1;
		decl temp_product=1/(maxPwr-minPwr)*interpSwpSize_m1;
		decl temp_vin_ik = 0;
		decl temp_magVout_ik = 0;
		decl temp_phaseRadVout_ik = 0;

		for (i=0; i<dB_rangeSwpSize; i++)
		{	
			for (k=0; k<timeSwpSize; k++)
			{
				temp_vin_ik = vin[i,k];
				if (mag(temp_vin_ik)<mag(vin_fromHBswp[0]))
				{ 
					temp_magVout_ik=minGain*mag(temp_vin_ik);
					temp_phaseRadVout_ik=phaserad(charVoltage[0])+phaserad(temp_vin_ik);  
				}
				else
				{
					indexVal=int((Pin[i,k]-minPwr)*temp_product);   // No extrapolation required
					if (indexVal <= interpSwpSize_m1)
					{
						temp_magVout_ik=magDataInterp[indexVal];
						temp_phaseRadVout_ik=phaseDataInterp[indexVal]+phaserad(temp_vin_ik);					
					} else if (!allowextrap)						// Extrapolation needed, but not allowed due to allowextrap flag setting
					{
						temp_magVout_ik=magDataInterp[interpSwpSize_m1];
						temp_phaseRadVout_ik=phaseDataInterp[interpSwpSize_m1]+phaserad(temp_vin_ik);
					} else
					{												// Perform linear extrapolation
						temp_magVout_ik=magDataInterp[interpSwpSize_m1]+mag_charVoltageSlope*(Pin[i,k]-maxPwr);
						temp_phaseRadVout_ik=phaseDataInterp[interpSwpSize_m1]+phaserad(temp_vin_ik)+phase_charVoltageSlope*(Pin[i,k]-maxPwr);
					}
				}  
				voutLI[i,k]=polar(temp_magVout_ik,temp_phaseRadVout_ik*180/pi);
			}
		} //CLOSE OUTER FOR LOOP
		if(debugFlag)
		{
			fputs(stderr, "    LI APPROXIMATION DONE");
		}
		// return list(voutLI,magDataInterp,phaseDataInterp,scaledInputSig);
		return list(voutLI, scaledInputSig);
    } //CLOSE ALGORITHM IF BLOCK 
}  

// fputs(stderr, " Defining function approxData_1d");
defun approxData_1d(algorithm,allowextrap,charData,sourceZ,modulatedInput,scaleFactors,debugFlag)
{
/* *********************************************************************************
   Function: approxData_1d
   --------------------------------
   Returns:	An array that contains the following:
   element 0: output data from applying the scaled input modulated signal
   to the modeled output data curve (which comes from a harmonic balance simulation.)  
   The output curve is modeled either as a curve fit or a linear interpolation
   element 1: the scaled modulated signal											
   --------------------------------
   Arguments: 
   1) algorithm	-flag for approximating transfer function (Data/vin).  Set to
   "CF" to use curve fit, "LI" to use Linear Interpolation
   2) allowextrap  - a flag to indicate whether extrapolation will be allowed or not.
   3) charData	-data from the HB sweep, to be modeled
   4) sourceZ	-Source impedance
   5) modulatedInput	-The input modulated signal
   6) scaleFactors -array of scaling factors
   7) debugFlag	-if set to 0, do not print debug messages.  Otherwise print them
   --------------------------------
   Usage:		This function is called from Mod_Data_from_1tone_swp.
   --------------------------------
   History:
   12/12/2013	Created based upon approxVoutVin_1d_r1, by AEH
   ********************************************************************************* */
    if(debugFlag)
    {
		fputs(stderr,"  CALCULATING SCALED INPUT SIGNAL AND RESULTING DATA SIGNAL.....");
    }

    decl charPower=indep(charData);
    decl minPwr=min(charPower);
    decl maxPwr=max(charPower);
    decl vin_fromHBswp=sqrt((1/real(1/sourceZ))*2*10**((charPower-30)/10));

    if (algorithm=="CF")
    {
		if(debugFlag)
		{
			fputs(stderr,"    USING CURVE FIT ALGORITHM TO APPROXIMATE TRANSFER FUNCTION");
		}

		/**************************************************************************
		SCALE THE INPUT MODULATED SIGNAL.  DOING THIS LOSES THE TIME FACTOR AS THE 
		INDEPENDANT ELEMENT SO WE NEED TO ADD TIME BACK AS THE INDEPENDANT VARIABLE.
		****************************************************************************/
		decl scaledInputSig=expand(scaleFactors)*modulatedInput;
		decl maxInputSig=max(max(mag(scaledInputSig)));
		decl time=indep(modulatedInput);
		decl vin=vs(scaledInputSig,time);

		/**************************************************************************
		CALCULATE THE CURVE FIT TO APPROXIMATE THE TRANSFER FUNCTION OF THE DUT
		****************************************************************************/
		decl minVin=sqrt(2*(1/real(1/sourceZ))*10**((minPwr-30)/10));
		decl maxVin=sqrt(2*(1/real(1/sourceZ))*10**((maxPwr-30)/10));  
		decl h1=if(minVin !=NULL) then find_index(vin_fromHBswp,minVin) else 0;
		decl h2=if(maxVin !=NULL) then find_index(vin_fromHBswp,maxVin) else sweep_size(charData)-1;
		decl x=vin_fromHBswp[h1::1::h2];
		//decl maxvin_fromHBswp=max(x);
		//decl fullScaleFraction=maxInputSig/maxvin_fromHBswp;
		decl magData=mag(charData);
		decl phaseData=unwrap(phaserad(charData),pi);
		decl y1=magData[h1::1::h2];
		decl y2=phaseData[h1::1::h2];
		decl meanx=mean(x);
		decl meanx2=mean(x**2);
		decl meanx3=mean(x**3);
		decl meanx4=mean(x**4);
		decl meanx5=mean(x**5);
		decl meanx6=mean(x**6);
		decl meanx7=mean(x**7);
		decl meanx8=mean(x**8);
		decl meanx9=mean(x**9);
		decl meanx10=mean(x**10);

		decl row1={1,meanx,meanx2,meanx3,meanx4,meanx5};
		decl row2={meanx,meanx2,meanx3,meanx4,meanx5,meanx6};
		decl row3={meanx2,meanx3,meanx4,meanx5,meanx6,meanx7};
		decl row4={meanx3,meanx4,meanx5,meanx6,meanx7,meanx8};
		decl row5={meanx4,meanx5,meanx6,meanx7,meanx8,meanx9};
		decl row6={meanx5,meanx6,meanx7,meanx8,meanx9,meanx10};

		decl mat_a={row1,row2,row3,row4,row5,{meanx5,meanx6,meanx7,meanx8,meanx9,meanx10}};
		decl v1={mean(y1),mean(x*y1),mean(x**2*y1),mean(x**3*y1),mean(x**4*y1),mean(x**5*y1)};
		decl v2={mean(y2),mean(x*y2),mean(x**2*y2),mean(x**3*y2),mean(x**4*y2),mean(x**5*y2)};
		decl bm=v1/mat_a;
		decl bp=v2/mat_a;
		// magFit=bm(1)+vin_fromHBswp*bm(2)+vin_fromHBswp**2*bm(3)+vin_fromHBswp**3*bm(4)+vin_fromHBswp**4*bm(5)+vin_fromHBswp**5*bm(6);
		// phaseFit=bp(1)+vin_fromHBswp*bp(2)+vin_fromHBswp**2*bp(3)+vin_fromHBswp**3*bp(4)+vin_fromHBswp**4*bp(5)+vin_fromHBswp**5*bp(6);
 
		/**************************************************************************
		APPLY THE CURVE FIT TO THE SCALED INPUT SIGNAL ARRAY TO APPROXIMATE THE DATA FROM
		THE DUT WHEN THE MODULATED SIGNAL IS APPLIED
		****************************************************************************/
		decl mag_vin=mag(vin);
		mag_vin=if ((mag_vin>maxVin) && (!allowextrap)) then maxVin else mag_vin;
		decl mag_Data_CF=bm(1)+mag_vin*bm(2)+mag_vin**2*bm(3)+mag_vin**3*bm(4)+mag_vin**4*bm(5)+mag_vin**5*bm(6);
		decl phaseRad_Data_CF=bp(1)+mag_vin*bp(2)+mag_vin**2*bp(3)+mag_vin**3*bp(4)+mag_vin**4*bp(5)+mag_vin**5*bp(6);
		decl Data_CF=mag_Data_CF*exp(j*(phaseRad_Data_CF));
		if(debugFlag)
		{
			fputs(stderr, "    CF APPROXIMATION DONE");
		}	
		return list(Data_CF, scaledInputSig);
    } else if (algorithm=="LI")
    {
		if(debugFlag)
		{
			fputs(stderr,"    USING LINEAR INTERPOLATION ALGORITHM TO APPROXIMATE TRANSFER FUNCTION");
		}
		/**************************************************************************
		SCALE THE INPUT MODULATED SIGNAL.  DOING THIS LOSES THE TIME FACTOR AS THE 
		INDEPENDANT ELEMENT SO WE NEED TO ADD TIME BACK AS THE INDEPENDANT VARIABLE.
		****************************************************************************/
		decl time=indep(modulatedInput);
		decl timeSwpSize=sweep_size(time);
		decl scaledInputSig=expand(scaleFactors)*modulatedInput;
		decl vin=vs(scaledInputSig,time);

		/**************************************************************************
		WITH LINEAR INTERPOLATION, THE INDEX VALUES OF THE OUTPUT VOLTAGE ARE DETERMINED
		BY THE INDICES OF THE INPUT POWER LEVELS.  WE WILL THEREFORE CALCULATE THE SCALED INPUT POWER, 
		CONVERT THE SCALEFACTOR ARRAY TO POWER LEVELS AND SIMPLY ADD THE POWER LEVELS OF THE 
		INPUT SIGNAL WITH THE POWER SCALING FACTORS.  ONCE CALULATED, ADD TIME BACK AS THE
		INDEPENDANT VARIABLE.
		****************************************************************************/

		decl powerScale = 20*log(scaleFactors);
		decl dB_rangeSwpSize=sweep_size(powerScale);
		decl InputSigPwr=dBm(modulatedInput+1e-10,conj(sourceZ));

		// This equation is only used to give scaledInputSigPwr the correct dimensionality
		decl scaledInputSigPwr=expand(powerScale)*InputSigPwr;

		decl j=0;
		if (sweep_dim(powerScale)<1)
		{
			scaledInputSigPwr[0,::]=InputSigPwr+powerScale;
		} else
		{
			for (j=0; j<dB_rangeSwpSize; j++)
			{	
				scaledInputSigPwr[j,::]=InputSigPwr+powerScale[j];
			}		
		}
		decl Pin=vs(scaledInputSigPwr,time);
		decl Data_LI=vin;
		decl mag_Data_LI=mag(Data_LI);
		decl phaseRad_Data_LI=phaserad(Data_LI);
		decl i=0;
		decl k=0;
		decl indexVal=0;
		decl magData=mag(charData);
		decl phaseData=unwrap(phaserad(charData),pi);
		decl indep_charData=indep(charData);					// This should be the available source power from the HB sweep.
		decl charDataLastIndex=sweep_size(charData)-1;
		decl charDataLastIndex_m1=charDataLastIndex-1;
		decl magDataSlope=(magData[charDataLastIndex]-magData[charDataLastIndex_m1])/(indep_charData[charDataLastIndex]-indep_charData[charDataLastIndex_m1]);
		decl phaseDataSlope=(phaseData[charDataLastIndex]-phaseData[charDataLastIndex_m1])/(indep_charData[charDataLastIndex]-indep_charData[charDataLastIndex_m1]);
		
		decl magDataInterp=interp(magData,,,0.01);              // Using a larger step size for interpolation could speed this up
		decl phaseDataInterp=interp(phaseData,,,0.01);          // 
		decl interpSwpSize=sweep_size(magDataInterp);
		decl interpSwpSize_m1=interpSwpSize-1;
		decl temp_product=1/(maxPwr-minPwr)*interpSwpSize_m1;
		decl temp_vin_ik = 0;
		decl temp_magData_ik = 0;
		decl temp_phaseRadData_ik = 0;

		for (i=0; i<dB_rangeSwpSize; i++)
		{	
			for (k=0; k<timeSwpSize; k++)
			{
				temp_vin_ik = vin[i,k];						// If the input voltage is below the minimum from the HB sweep, 
				if (mag(temp_vin_ik)<mag(vin_fromHBswp[0])) //     there is no extrapolation and the lowest value of charData is used               
				{ 
					temp_magData_ik=mag(charData[0]);
					temp_phaseRadData_ik=phaserad(charData[0]);  
				}
				else
				{
					indexVal=int((Pin[i,k]-minPwr)*temp_product);		// No extrapolation required
					if (indexVal <= interpSwpSize_m1)
					{
						temp_magData_ik=magDataInterp[indexVal];
						temp_phaseRadData_ik=phaseDataInterp[indexVal];						
					} else if (!allowextrap)							// Extrapolation needed, but not allowed due to allowextrap flag setting
					{
						temp_magData_ik=magDataInterp[interpSwpSize_m1];
						temp_phaseRadData_ik=phaseDataInterp[interpSwpSize_m1];
					} else
					{													// Perform linear extrapolation
						temp_magData_ik=magDataInterp[interpSwpSize_m1]+magDataSlope*(Pin[i,k]-maxPwr);
						temp_phaseRadData_ik=phaseDataInterp[interpSwpSize_m1]+phaseDataSlope*(Pin[i,k]-maxPwr);						
					}
				}  
				Data_LI[i,k]=polar(temp_magData_ik,temp_phaseRadData_ik*180/pi);
			}
		} //CLOSE OUTER FOR LOOP
		if(debugFlag)
		{
			fputs(stderr, "    LI APPROXIMATION DONE");
		}
		return list(Data_LI, scaledInputSig);
    } //CLOSE ALGORITHM IF BLOCK 
}  

// fputs(stderr, " Defining function Mod_Data_from_1tone_swpUNI");
//***********************************************************************
  /*BEGIN_DOC
    FUN_NAME: Mod_Data_from_1tone_swpUNI()
    FUN_DESCRIPTION: Returns an amplifier's adjacent and alternate channel power ratios, main channel power, and error vector magnitude
    RETURNED_VALUE: Real
    CATEGORY: Harmonic Balance and Envelope
    SYNTAX: Mod_Data_from_1tone_swpUNI(algorithm, allowextrap, charVoltage, inputSig, sourceZ, loadZ, mainCh, mainChForPout, lowerAdjCh, upperAdjCh, lowerAltCh, upperAltCh, winType, winConst)
    EXAMPLE:
    Vload_fundHB=Vload[1]
    Vin_fund=_3GPPFDD_UE_Tx_12_2_SigGen..Vsource
    Zsource=50
    Zload=50
    MainLimits={-3.84 MHz/2,3.84 MHz/2}
    MainLimitsForPout=MainLimits
    LoChLimits=MainLimits-(5 MHz)
    UpChLimits=MainLimits+(5 MHz)
    LoChLimitsAlt=MainLimits-(10 MHz)
    UpChLimitsAlt=MainLimits+(10 MHz)
    Data_DDS=Mod_Data_from_1tone_swpUNI("LI", "Yes", Vload_fundHB, Vin_fund, Zsource, Zload, MainLimits, MainLimitsForPout, LoChLimits, UpChLimits, LoChLimitsAlt, UpChLimitsAlt, "Kaiser",)
    ACPR_dBc=Data_DDS(0)
    Pout_dBm=Data_DDS(2)
    ACPR_vs_Pout=vs(ACPR_dBc,Pout_dBm)
    AltCPR_dBc=Data_DDS(1)
    AltCPR_vs_Pout=vs(AltCPR_dBc,Pout_dBm)
    EVM_percent=Data_DDS(3)
    EVM_vs_Pout=vs(EVM_percent,Pout_dBm)
    ARGUMENT
    ARG_NAME: algorithm
    ARG_DESCRIPTION: Specifies the algorithm to be used to model the vout-versus-vin data from the HB sweep.  Use "CF" for Curve Fit or "LI" for Linear Interpolation.
    ARG_DEFAULT: None
    ARG_RANGE: "LI" or "CF"
    ARG_TYPE: String
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: allowextrap
    ARG_DESCRIPTION: Allow or disallow extrapolation when applying the scaled, modulated input signal to the vout-versus-vin model.
    ARG_DEFAULT: 1
    ARG_RANGE: 0, "No", "NO", "no", 1, "Yes", "YES", "yes"
    ARG_TYPE: String or Integer
    ARG_REQUIRED: NO
    ARGUMENT
    ARG_NAME: charVoltage
    ARG_DESCRIPTION: This is the characterization voltage (the fundamental output voltage from the harmonic balance sweep.)  Example: Vload_fund, where Vload_fund=Vload[1].
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: Complex
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: inputSig
    ARG_DESCRIPTION: This is the input modulated signal (the envelope.)  This signal should be a function of time, only.  
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: Complex
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: sourceZ
    ARG_DESCRIPTION: This is the source impedance.  This can be a swept parameter.
    ARG_DEFAULT: None
    ARG_RANGE: (0:inf)
    ARG_TYPE: Complex
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: loadZ
    ARG_DESCRIPTION: This is the load impedance.  This can be a swept parameter.
    ARG_DEFAULT: None
    ARG_RANGE: (0:inf)
    ARG_TYPE: Complex
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: mainCh
    ARG_DESCRIPTION: These are the main channel frequency limits, as an offset from the carrier frequency.  Example: {(-3.84 MHz/2),(3.84 MHz/2)}
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: 1X2 matrix, Real or Integer
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: mainChForPout
    ARG_DESCRIPTION: These are the frequency limits used for computing the modulated output power.  Normally these would be the same as the mainCh argument, but this allows you to specify a different bandwidth for computing the modulated output power.
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: 1X2 matrix, Real or Integer
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: lowerAdjCh
    ARG_DESCRIPTION: These are the lower adjacent channel frequency limits as an offset from the carrier frequency.  Example: MainLimits - (5 MHz)
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: 1X2 matrix, Real or Integer
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: upperAdjCh
    ARG_DESCRIPTION: These are the upper adjacent channel frequency limits as an offset from the carrier frequency.  Example: MainLimits + (5 MHz)
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: 1X2 matrix, Real or Integer
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: lowerAltCh
    ARG_DESCRIPTION: These are the lower alternate channel frequency limits as an offset from the carrier frequency.  Example: MainLimits - (10 MHz)
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: 1X2 matrix, Real or Integer
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: upperAltCh
    ARG_DESCRIPTION: These are the upper alternate channel frequency limits as an offset from the carrier frequency.  Example: MainLimits + (10 MHz)
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: 1X2 matrix, Real or Integer
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: winType
    ARG_DESCRIPTION: window type
    ARG_DEFAULT: "Kaiser"
    ARG_RANGE: dagger.gif
    ARG_TYPE: string
    ARG_REQUIRED: NO
    ARGUMENT
    ARG_NAME: winConst
    ARG_DESCRIPTION: window constant that affects the shape of the applied window.
    ARG_DEFAULT: depends on winType used
    ARG_RANGE: [0:inf)
    ARG_TYPE: Real
    ARG_REQUIRED: NO
    FOOTNOTES: dagger.gif winType can be: "none", "hamming", "hanning", "gaussian", "kaiser", "8510", "blackman","blackman-harris"
    DEFINED_IN: 
    SEE ALSO: ACPR_ChPwr_or_EVM_from_1toneSwp()
    NOTES: This function returns the adjacent and alternate channel power ratios, main channel power, and EVM.  Because it returns multiple results, 
    it cannot be used in a measurement expression on the schematic.  It can only be used in the data display.  The advantage of using this 
    function instead of ACPR_ChPwr_or_EVM_from_1tone_swp() is that it is more efficient for obtaining all these results.  
    When using ACPR_ChPwr_or_EVM_from_1tone_swp(), you have to call it once to get the adjacent channel power ratios, once again to get 
    the alternate channel power ratios, once again to get the main channel power, and once again to get the EVM.  The big disadvantage 
    of using the Mod_Data_from_1tone_swpUNI() is that this function will get executed each time you open a data display that contains it.  
    While it is slower to use the ACPR_ChPwr_or_EVM_from_1tone_swp() function on the schematic, the advantage is that the results are 
    written into the dataset, and data displays that show these results open instantly.  

    For EVM, the single-tone method is not specification-compliant.  It just measures the 'raw' EVM, computed at each time point.  
    The EVM is computed after correcting for the average phase difference and RMS amplitude difference between the output and input 
    modulated signals.  If the modulated signal at the output of the amplifier has only a constant phase shift and a constant gain 
    (meaning that neither vary with the amplitude of the input modulated signal), then the EVM will be zero.  With this method, the 
    EVM is computed at each time point, not at just the symbol times.  There is no demodulation or decoding of the signal, so you can't 
    calculate the EVM of each sub-carrier, say for an LTE signal.

    For ACPR, the single-tone method does not include any receive-side filtering.  It just generates the spectrum at the output of 
    the amplifier, integrates the power in the main, adjacent, and alternate channels, then computes the ratios.
    The single-tone method of computing EVM (and ACPR) will tend to become less accurate as the bandwidth of the signal gets larger.  
    This is because this method assumes the response of the amplifier is constant across the modulation bandwidth (we're modeling the 
    nonlinearity by injecting a single tone at the carrier frequency, after all.)
    EXTERNAL: yes
    AUTHOR: Keysight Technologies (AEH)
    DATE: May 10 2010
    VERSION_CREATED: ADS 2009 Update 1
    END_DOC*/
  //***********************************************************************
  defun Mod_Data_from_1tone_swpUNI(algorithm, allowextrap, charVoltage, inputSig, sourceZ, loadZ, mainCh, mainChForPout, lowerAdjCh, upperAdjCh, lowerAltCh, upperAltCh, winType, winConst)
{
   
    if ((algorithm != "CF") && (algorithm != "LI") && (algorithm != NULL))
    {
	print_function_error( "Mod_Data_from_1tone_swpUNI", "algorithm must be set to \"CF\" for Curve Fit or \"LI\" for Linear Interpolation");
	return;
    }
    decl algorithmChkd = if (algorithm == NULL) then "LI" else algorithm;  // use linear interpolation as the default algorithm
    if ((allowextrap != 0) && (allowextrap !="No") && (allowextrap !="NO") && (allowextrap !="no") && (allowextrap !=1) && (allowextrap !="Yes") && (allowextrap !="YES") && (allowextrap !="yes") && (allowextrap !=NULL))
    {
	print_function_error( "Mod_Data_from_1tone_swpUNI", "allowextrap must be set to 0, \"No\", \"NO\", \"no\", 1, \"Yes\", \"YES\", or \"yes\" ");
	return;
    }
    decl allowextrapChkd = if (allowextrap == NULL) then 1 else allowextrap; // allow extrapolation as the default if no parameter passed.
    if (sweep_dim(inputSig) !=1) 
    {
	print_function_error( "Mod_Data_from_1tone_swpUNI", "inputSig must be a 1-dimensional, complex voltage envelope versus time");
	return;
    }
    if (sourceZ == NULL)
    {
	print_function_error( "Mod_Data_from_1tone_swpUNI", "You must enter the source impedance(s) used during the harmonic balance sweep(s)");
	return;                         // The function does not use a default value for sourceZ because doing so would give erroneous results if the user swept sourceZ but did not enter
    }                                // the swept value into the function.
    decl sourceZ_Chkd = if (sweep_dim(sourceZ) == 2) then sourceZ[0] else sourceZ;
    if (loadZ == NULL)
    {
	print_function_error( "Mod_Data_from_1tone_swpUNI", "You must enter the load impedance(s) used during the harmonic balance sweep(s)");
	return;                         // The function does not use a default value for loadZ because doing so would give erroneous results if the user swept loadZ but did not enter
    }                                // the swept value into the function.
    decl loadZ_Chkd = if (sweep_dim(loadZ) == 2) then loadZ[0] else loadZ;
    if ((mainCh == NULL) || (size(mainCh) != 2) || (sweep_size(mainCh) !=1) || (sweep_dim(mainCh) !=0))
    {
	print_function_error( "Mod_Data_from_1tone_swpUNI", "There is something wrong with the mainCh parameter.  You must enter the main channel frequencies as an offset from the carrier.  Example: {-1.92 MHz, 1.92 MHz}");
	return;
    }
    if ((mainChForPout == NULL) || (size(mainChForPout) != 2) || (sweep_size(mainChForPout) !=1) || (sweep_dim(mainChForPout) !=0))
    {
	print_function_error( "Mod_Data_from_1tone_swpUNI", "There is something wrong with the mainChForPout parameter.  You must enter the main channel frequencies for modulated output power calculation as an offset from the carrier.  Example: {-1.92 MHz, 1.92 MHz}");
	return;
    }
    if ((lowerAdjCh == NULL) || (size(lowerAdjCh) != 2) || (sweep_size(lowerAdjCh) !=1) || (sweep_dim(lowerAdjCh) !=0))
    {
	print_function_error( "Mod_Data_from_1tone_swpUNI", "There is something wrong with the lowerAdjCh parameter.  You must enter the lower adjacent channel frequencies as an offset from the carrier.  Example: {-1.92 MHz, 1.92 MHz}-(5 MHz)");
	return;
    }
    if ((upperAdjCh == NULL) || (size(upperAdjCh) != 2) || (sweep_size(upperAdjCh) !=1) || (sweep_dim(upperAdjCh) !=0))
    {
	print_function_error( "Mod_Data_from_1tone_swpUNI", "There is something wrong with the upperAdjCh parameter.  You must enter the upper adjacent channel frequencies as an offset from the carrier.  Example: {-1.92 MHz, 1.92 MHz}+(5 MHz)");
	return;
    }
    if ((lowerAltCh == NULL) || (size(lowerAltCh) != 2) || (sweep_size(lowerAltCh) !=1) || (sweep_dim(lowerAltCh) !=0))
    {
	print_function_error( "Mod_Data_from_1tone_swpUNI", "There is something wrong with the lowerAltCh parameter.  You must enter the lower alternate channel frequencies as an offset from the carrier.  Example: {-1.92 MHz, 1.92 MHz}-(10 MHz)");
	return;
    }
    if ((upperAltCh == NULL) || (size(upperAltCh) != 2) || (sweep_size(upperAltCh) !=1) || (sweep_dim(upperAltCh) !=0))
    {
	print_function_error( "Mod_Data_from_1tone_swpUNI", "There is something wrong with the upperAltCh parameter.  You must enter the upper alternate channel frequencies as an offset from the carrier.  Example: {-1.92 MHz, 1.92 MHz}+(10 MHz)");
	return;
    }
    decl winTypeChkd = if (winType == NULL) then "Kaiser" else winType; // "Kaiser" is the default window type if no parameter passed.
    decl sweepDim = sweep_dim(charVoltage);
    decl resultList = NULL; 
   
    switch (sweepDim) {
    case 0: print_function_error( "Mod_Data_from_1tone_swpUNI", " does not support single number data.");
	return;
	break;
    case 1: resultList = Mod_Data_from_1tone_swpUNI_1d(algorithmChkd, allowextrapChkd, charVoltage, inputSig, sourceZ_Chkd, loadZ_Chkd, mainCh, mainChForPout, lowerAdjCh, upperAdjCh, lowerAltCh, upperAltCh, winTypeChkd, winConst);
	break;
    case 2: resultList = Mod_Data_from_1tone_swpUNI_2d(algorithmChkd, allowextrapChkd, charVoltage, inputSig, sourceZ_Chkd, loadZ_Chkd, mainCh, mainChForPout, lowerAdjCh, upperAdjCh, lowerAltCh, upperAltCh, winTypeChkd, winConst);	 
	break;
    default: print_function_error( "Mod_Data_from_1tone_swpUNI", " does not support data with dimensions greater than two.");
	return;
	break;
    }

    return resultList;
} // fun - Mod_Data_from_1tone_swpUNI

// fputs(stderr, " Defining function Mod_Data_from_1tone_swpUNI_2d");
defun Mod_Data_from_1tone_swpUNI_2d(algorithm, allowextrap, charVoltage, inputSig, sourceZ, loadZ, mainCh, mainChForPout, lowerAdjCh, upperAdjCh, lowerAltCh, upperAltCh, winType, winConst)
{
    decl numPts_i=sweep_size(charVoltage[::,0]);
    decl numPts_j;                     
    decl acpr_vs_inSigPower_array=create(2,"Real",{"indepVar1","InputPower_dBm"},{"Real","Real"}, 2, 1);
    decl altcpr_vs_inSigPower_array=create(2,"Real",{"indepVar1","InputPower_dBm"},{"Real","Real"}, 2, 1);
    decl main_channel_power_dBm_vs_Inpower_array=create(2,"Real",{"indepVar1","InputPower_dBm"},{"Real","Real"}, 1, 1);
    decl evm_vs_Inpower_array=create(2,"Real",{"indepVar1","InputPower_dBm"},{"Real","Real"}, 1, 1);
    // decl vout_array=create(3,"Complex",{"indepVar1","InputPower_Index","time"},{"Real","Real","Real"}, 1, 1);  
    // decl scaleFactors_array=create(2,"Real",{"indepVar1","InputPower_Index"},{"Real","Real"}, 1, 1);  
    // decl magFit_array=create(2,"Real",{"indepVar1","RFpower"},{"Real","Real"}, 1, 1); 
    // decl phaseFit_array=create(2,"Real",{"indepVar1","RFpower"},{"Real","Real"}, 1, 1); 
   
    decl pointerX1=indep(acpr_vs_inSigPower_array,"indepVar1");
    decl pointerX2=indep(altcpr_vs_inSigPower_array,"indepVar1");
    decl pointerX3=indep(main_channel_power_dBm_vs_Inpower_array,"indepVar1");
    decl pointerX4=indep(evm_vs_Inpower_array,"indepVar1");
    // decl pointerX5=indep(vout_array,"indepVar1");
    // decl pointerX6=indep(scaleFactors_array,"indepVar1");
    // decl pointerX7=indep(magFit_array,"indepVar1");
    // decl pointerX8=indep(phaseFit_array,"indepVar1");
 
    // decl pointerY1=indep(magFit_array,"RFpower");
    // decl pointerY2=indep(phaseFit_array,"RFpower");
    decl pointerZ1=indep(acpr_vs_inSigPower_array,"InputPower_dBm");
    decl pointerZ2=indep(altcpr_vs_inSigPower_array,"InputPower_dBm");
    decl pointerZ3=indep(main_channel_power_dBm_vs_Inpower_array,"InputPower_dBm");
    decl pointerZ4=indep(evm_vs_Inpower_array,"InputPower_dBm");
    // decl Power_IndexPointer1=indep(vout_array,"InputPower_Index");
    // decl Power_IndexPointer2=indep(scaleFactors_array,"InputPower_Index");
 
    // decl time=indep(inputSig,"time");  
    // decl pointerT1=indep(vout_array,"time");  
    // pointerT1=time;                           
   
    decl outerIndep=indep(charVoltage[0]);            
    // decl temp=list(acpr_vs_inSigPower_array[0,::], altcpr_vs_inSigPower_array[0,::], main_channel_power_dBm_vs_Inpower_array[0,::], vout_array[0,::,::], scaleFactors_array[0,::], magFit_array[0,::], phaseFit_array[0,::]);
    decl temp=list(acpr_vs_inSigPower_array[0,::], altcpr_vs_inSigPower_array[0,::], main_channel_power_dBm_vs_Inpower_array[0,::], evm_vs_Inpower_array[0,::]);
    decl sourceZparam;
    decl loadZparam;
    decl secondIndep;
    decl i;
    // decl j;
    for (i=0; i<numPts_i; i++)
    {
	sourceZparam=if (sweep_dim(sourceZ)==1) then sourceZ[i] else sourceZ endif; // this handles the case where sourceZ is the swept parameter
	loadZparam=if (sweep_dim(loadZ)==1) then loadZ[i] else loadZ endif;         // this handles the case where loadZ is the swept parameter
	temp=Mod_Data_from_1tone_swpUNI_1d(algorithm, allowextrap, charVoltage[i,::], inputSig, sourceZparam, loadZparam, mainCh, mainChForPout, lowerAdjCh, upperAdjCh, lowerAltCh, upperAltCh, winType, winConst);
	acpr_vs_inSigPower_array[i,::]=temp(0);
	altcpr_vs_inSigPower_array[i,::]=temp(1);
	main_channel_power_dBm_vs_Inpower_array[i,::]=temp(2);
	evm_vs_Inpower_array[i,::]=temp(3);

	// scaleFactors_array[i,::]=temp(5);
	// numPts_j=sweep_size(temp(5));
	// for (j=0; j<=(numPts_j-1); j++)
	// {
	//  vout_array[i,j,::]=temp(4)[j,::];
	// pointerT1[i,j,::]=indep(temp(4)[j,::]);    // The results don't change if I include this line and de-activate the pointerT1=time line above.
	//   Power_IndexPointer1[j]=j;
	//   Power_IndexPointer2[j]=j;
	// }
	pointerZ1[i,::]=indep(temp(0));
	pointerZ2[i,::]=indep(temp(1));
	pointerZ3[i,::]=indep(temp(2));
	pointerZ4[i,::]=indep(temp(3));
	 
	// if (algorithm=="CF")
	// {
	//  pointerY1[i,::]=indep(charVoltage[i,::]);
	//  pointerY2[i,::]=indep(charVoltage[i,::]);
	// } else if (algorithm=="LI")
	// {
	//  pointerY1[i,::]=indep(temp(6));
	//  pointerY2[i,::]=indep(temp(7));
	// }
	// magFit_array[i,::]=temp(6);  
	// phaseFit_array[i,::]=temp(7);
    }
    pointerX1[::]=outerIndep[::];
    pointerX2[::]=outerIndep[::];
    pointerX3[::]=outerIndep[::];
    pointerX4[::]=outerIndep[::];
    // pointerX5[i]=outerIndep[i];
    // pointerX6[i]=outerIndep[i];
    // pointerX7[i]=outerIndep[i];
    // pointerX8[i]=outerIndep[i];
    // return list(acpr_vs_inSigPower_array, altcpr_vs_inSigPower_array, main_channel_power_dBm_vs_Inpower_array,evm_vs_Inpower_array, vs(vout_array,time), scaleFactors_array, magFit_array, phaseFit_array);
    return list(acpr_vs_inSigPower_array, altcpr_vs_inSigPower_array, main_channel_power_dBm_vs_Inpower_array, evm_vs_Inpower_array);
} //fun - Mod_Data_from_1tone_swpUNI_2d

// fputs(stderr," Defining function Mod_Data_from_1tone_swpUNI_1d");
defun Mod_Data_from_1tone_swpUNI_1d(algorithm, allowextrap, charVoltage, inputSig, sourceZ, loadZ, mainCh, mainChForPout, lowerAdjCh, upperAdjCh, lowerAltCh, upperAltCh, winType, winConst)
{
/* *********************************************************************************
   Function: Mod_Data_from_1tone_swpUNI_1d
   --------------------------------
   Returns:	An array of that contains the following:
   element 0: ACPR
   element 1: Alternate Channel Power Ratio
   element 2: Main Channel Power
   element 3: EVM
   *** The outputs below have been turned off to save time and memory. ***
   element 4: output from applying scaled modulated input to transfer function
   of DUT (as modelled by curve fit or linear interpolation)
   element 5: array of scale factors
   element 6: the modeled magnitude response
   element 7: the modeled phase response
   --------------------------------
   Arguments: 
   1) algorithm	-flag for approximating transfer function (vout/vin).  Set to
   "CF" to use curve fit, "LI" to use Linear Interpolation
   2) allowextrap	-flag for allowing extrapolation.  If set to 1, the scalefactors
   used to create the pseudo-power-swept modulated data will be 
   created from -30dBm to the the max input signal power.
   If set to 0, extrapolation is not allowed and scale factors that
   cause the modulated signal power to exceed the power of the HB
   sweep are omitted.
   3) charVoltage	-output voltage from the HB sweep
   4) inputSig	-input modulated signal
   5) sourceZ	-Source impedance
   6) loadZ	-Load impledance
   7) mainCh	-main channel limits
   8) mainChForPout  -main channel limits used when computing the output power
   9) lowerAdjCh	-lower adjacent channel limits
   10) upperAdjCh	-upper adjacent channel limits
   11) lowerAltCh  -lower alternate channel limits
   12) upperAltCh  -upper alternate channel limits
   13) winType	-window type (ie, Kaiser)
   14) winConst	-
   --------------------------------
   Usage:		This function is called from the Data Display
   --------------------------------
   History:
   12/12/2006	Created based upon the script that AEH generated
   ********************************************************************************* */
    decl debug=0;
    if(debug)
    {
	fprintf(stderr,"DEBUG FLAG ON.\n  IN FUNCTION Mod_Data_from_1tone_swpUNI_1d\n");
    }

    decl RFpower=indep(charVoltage);       
    decl scaleFactors=calculate_scalefactors_1d( allowextrap, RFpower, inputSig, sourceZ,debug);  // The _1d version should work here.
    decl resultsArray=approxVoutVin_1d(algorithm,charVoltage,sourceZ,inputSig,scaleFactors,debug);       // The _1d version should work here.
    decl vout=resultsArray[0];
    // decl magFit=resultsArray[1];
    // decl phaseFit=resultsArray[2];
    decl scaledInputSig=resultsArray[1];
 
    if(debug)
    {
	fputs(stderr,"  CALC ACPR");
    }
  
    decl acpr = acpr_vr(vout,real(loadZ),mainCh,lowerAdjCh,upperAdjCh,winType,winConst);
    decl altcpr = acpr_vr(vout,real(loadZ),mainCh,lowerAltCh,upperAltCh,winType,winConst);
    decl main_channel_power = channel_power_vr(vout,real(loadZ),mainChForPout,winType,winConst);
    decl main_channel_power_dBm = 10*log(main_channel_power)+30;
    decl inSigPower=channel_power_vr(scaledInputSig,real(sourceZ),mainChForPout,winType,winConst);    // changed mainCh to mainChForPout.
    decl inSigPower_dBm=10*log(inSigPower)+30;	
    decl acpr_vs_inSigPower=vs(acpr,inSigPower_dBm);
    decl altcpr_vs_inSigPower=vs(altcpr,inSigPower_dBm);
    decl main_channel_power_dBm_vs_Inpower=vs(main_channel_power_dBm,inSigPower_dBm);

    decl time=indep(inputSig);                            // This line and subsequent ones down to the "return" line added for EVM
    decl timestep=time[1];
    decl temp;
    decl evm_vs_inSigPower=vs(scaleFactors,inSigPower_dBm);                
    decl i;
    decl numPts_i=sweep_size(scaleFactors);
    for (i=0; i<numPts_i; i++)
    {
	temp=evm(inputSig,vout[i,::],1/timestep,,0,,);  // This EVM calc uses symbol rate = 1/timestep, so it is a "raw" EVM.
	evm_vs_inSigPower[i]=temp;                           // This is the rms EVM in percent.
    }
    if(debug)
    {
	fputs(stderr,"  BOTTOM OF Mod_Data_from_1tone_swpUNI_1d FUNCTION");
    }

    // return list(acpr_vs_inSigPower, altcpr_vs_inSigPower, main_channel_power_dBm_vs_Inpower, evm_vs_inSigPower, vout, scaleFactors, magFit, phaseFit);
    return list(acpr_vs_inSigPower, altcpr_vs_inSigPower, main_channel_power_dBm_vs_Inpower, evm_vs_inSigPower);
}

// fputs(stderr, " Defining function Mod_Data_from_1tone_swpUNI_r1");
//***********************************************************************
  /*BEGIN_DOC
    FUN_NAME: Mod_Data_from_1tone_swpUNI_r1()
    FUN_DESCRIPTION: Returns an amplifier's adjacent and alternate channel power ratios, main channel power, and error vector magnitude
    RETURNED_VALUE: Real
    CATEGORY: Harmonic Balance and Envelope
    SYNTAX: Mod_Data_from_1tone_swpUNI_r1(algorithm, allowextrap, charVoltage, inputSig, inputSigPowers, sourceZ, loadZ, mainCh, mainChForPout, lowerAdjCh, upperAdjCh, lowerAltCh, upperAltCh, winType, winConst)
    EXAMPLE:
    Vload_fundHB=Vload[1]
    Vin_fund=_3GPPFDD_UE_Tx_12_2_SigGen..Vsource[0::2000]
	inputSigPowers1=[-10::5::0]
	inputSigPowers2=[2::2::10]
	inputSigPowers=[inputSigPowers1,inputSigPowers2]
    Zsource=50
    Zload=50
    MainLimits={-3.84 MHz/2,3.84 MHz/2}
    MainLimitsForPout=MainLimits
    LoChLimits=MainLimits-(5 MHz)
    UpChLimits=MainLimits+(5 MHz)
    LoChLimitsAlt=MainLimits-(10 MHz)
    UpChLimitsAlt=MainLimits+(10 MHz)
    Data_DDS=Mod_Data_from_1tone_swpUNI_r1("LI", "Yes", Vload_fundHB, Vin_fund, inputSigPowers, Zsource, Zload, MainLimits, MainLimitsForPout, LoChLimits, UpChLimits, LoChLimitsAlt, UpChLimitsAlt, "Kaiser",)
    ACPR_dBc=Data_DDS(0)
    Pout_dBm=Data_DDS(2)
    ACPR_vs_Pout=vs(ACPR_dBc,Pout_dBm)
    AltCPR_dBc=Data_DDS(1)
    AltCPR_vs_Pout=vs(AltCPR_dBc,Pout_dBm)
    EVM_percent=Data_DDS(3)
    EVM_vs_Pout=vs(EVM_percent,Pout_dBm)
    ARGUMENT
    ARG_NAME: algorithm
    ARG_DESCRIPTION: Specifies the algorithm to be used to model the vout-versus-vin data from the HB sweep.  Use "CF" for Curve Fit or "LI" for Linear Interpolation.
    ARG_DEFAULT: None
    ARG_RANGE: "LI" or "CF"
    ARG_TYPE: String
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: allowextrap
    ARG_DESCRIPTION: Allow or disallow extrapolation when applying the scaled, modulated input signal to the vout-versus-vin model.
    ARG_DEFAULT: 1
    ARG_RANGE: 0, "No", "NO", "no", 1, "Yes", "YES", "yes"
    ARG_TYPE: String or Integer
    ARG_REQUIRED: NO
    ARGUMENT
    ARG_NAME: charVoltage
    ARG_DESCRIPTION: This is the characterization voltage (the fundamental output voltage from the harmonic balance sweep.)  Example: Vload_fund, where Vload_fund=Vload[1].
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: Complex
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: inputSig
    ARG_DESCRIPTION: This is the input modulated signal (the envelope.)  This signal should be a function of time, only.  
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: Complex
    ARG_REQUIRED: YES
	ARGUMENT
    ARG_NAME: inputSigPowers
    ARG_DESCRIPTION: This is either a single number or an array of modulated available source power values (in dBm).  
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: Real
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: sourceZ
    ARG_DESCRIPTION: This is the source impedance.  This can be a swept parameter.
    ARG_DEFAULT: None
    ARG_RANGE: (0:inf)
    ARG_TYPE: Complex
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: loadZ
    ARG_DESCRIPTION: This is the load impedance.  This can be a swept parameter.
    ARG_DEFAULT: None
    ARG_RANGE: (0:inf)
    ARG_TYPE: Complex
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: mainCh
    ARG_DESCRIPTION: These are the main channel frequency limits, as an offset from the carrier frequency.  Example: {(-3.84 MHz/2),(3.84 MHz/2)}
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: 1X2 matrix, Real or Integer
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: mainChForPout
    ARG_DESCRIPTION: These are the frequency limits used for computing the modulated output power.  Normally these would be the same as the mainCh argument, but this allows you to specify a different bandwidth for computing the modulated output power.
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: 1X2 matrix, Real or Integer
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: lowerAdjCh
    ARG_DESCRIPTION: These are the lower adjacent channel frequency limits as an offset from the carrier frequency.  Example: MainLimits - (5 MHz)
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: 1X2 matrix, Real or Integer
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: upperAdjCh
    ARG_DESCRIPTION: These are the upper adjacent channel frequency limits as an offset from the carrier frequency.  Example: MainLimits + (5 MHz)
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: 1X2 matrix, Real or Integer
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: lowerAltCh
    ARG_DESCRIPTION: These are the lower alternate channel frequency limits as an offset from the carrier frequency.  Example: MainLimits - (10 MHz)
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: 1X2 matrix, Real or Integer
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: upperAltCh
    ARG_DESCRIPTION: These are the upper alternate channel frequency limits as an offset from the carrier frequency.  Example: MainLimits + (10 MHz)
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: 1X2 matrix, Real or Integer
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: winType
    ARG_DESCRIPTION: window type
    ARG_DEFAULT: "Kaiser"
    ARG_RANGE: dagger.gif
    ARG_TYPE: string
    ARG_REQUIRED: NO
    ARGUMENT
    ARG_NAME: winConst
    ARG_DESCRIPTION: window constant that affects the shape of the applied window.
    ARG_DEFAULT: depends on winType used
    ARG_RANGE: [0:inf)
    ARG_TYPE: Real
    ARG_REQUIRED: NO
    FOOTNOTES: dagger.gif winType can be: "none", "hamming", "hanning", "gaussian", "kaiser", "8510", "blackman","blackman-harris"
    DEFINED_IN: 
    SEE ALSO: ACPR_ChPwr_or_EVM_from_1toneSwp_r1()
    NOTES: This function is similar to Mod_Data_from_1tone_swpUNI() except that this revised version allows you to specify levels for the
	modulated input signal power, and it operates on data with up to 3 independent variables (one being the available source power from a 
	harmonic balance sweep.)
	
	This function returns the adjacent and alternate channel power ratios, main channel power, and EVM.  Because it returns multiple results, 
    it cannot be used in a measurement expression on the schematic.  It can only be used in the data display.  The advantage of using this 
    function instead of ACPR_ChPwr_or_EVM_from_1tone_swp_r1() is that it is more efficient for obtaining all these results.  
    When using ACPR_ChPwr_or_EVM_from_1tone_swp_r1(), you have to call it once to get the adjacent channel power ratios, once again to get 
    the alternate channel power ratios, once again to get the main channel power, and once again to get the EVM.  The big disadvantage 
    of using the Mod_Data_from_1tone_swpUNI_r1() is that this function will get executed each time you open a data display that contains it.  
    While it is slower to use the ACPR_ChPwr_or_EVM_from_1tone_swp_r1() function on the schematic, the advantage is that the results are 
    written into the dataset, and data displays that show these results open instantly.  

    For EVM, this single-tone method is not specification-compliant.  It just measures the 'raw' EVM, computed at each time point.  
    The EVM is computed after correcting for the average phase difference and RMS amplitude difference between the output and input 
    modulated signals.  If the modulated signal at the output of the amplifier has only a constant phase shift and a constant gain 
    (meaning that neither vary with the amplitude of the input modulated signal), then the EVM will be zero.  With this method, the 
    EVM is computed at each time point, not at just the symbol times.  There is no demodulation or decoding of the signal, so you can't 
    calculate the EVM of each sub-carrier, say for an LTE signal.

    For ACPR, the single-tone method does not include any receive-side filtering.  It just generates the spectrum at the output of 
    the amplifier, integrates the power in the main, adjacent, and alternate channels, then computes the ratios.
    This single-tone method of computing EVM (and ACPR) will tend to become less accurate as the bandwidth of the signal gets larger.  
    This is because this method assumes the response of the amplifier is constant across the modulation bandwidth (we're modeling the 
    nonlinearity by injecting a single tone at the carrier frequency, after all.)
	
	This function can be made faster by reducing the number of values in the inSigPowers array and/or by limiting the number of time points in the
	Vin_fund modulated signal.  Adding syntax like [0::1000] or [0::2000] to the end of the equation defining the modulated signal limits the 
	number of time points included in the simulation.
	
	If allowextrap is set to 1, the modulated input signal will be scaled once for each value of the inputSigPowers (units of dBm) parameter.
	If set to 0, extrapolation is not allowed and scale factors that cause the modulated signal power to exceed the power of the HB sweep are omitted.
	
    EXTERNAL: yes
    AUTHOR: Keysight Technologies (AEH)
    DATE: May 21, 2013
    VERSION_CREATED: ADS 2012.08
    END_DOC*/
  //***********************************************************************
  defun Mod_Data_from_1tone_swpUNI_r1(algorithm, allowextrap, charVoltage, inputSig, inputSigPowers, sourceZ, loadZ, mainCh, mainChForPout, lowerAdjCh, upperAdjCh, lowerAltCh, upperAltCh, winType, winConst)
{
    if ((algorithm != "CF") && (algorithm != "LI") && (algorithm != NULL))
    {
		print_function_error( "Mod_Data_from_1tone_swpUNI_r1", "algorithm must be set to \"CF\" for Curve Fit or \"LI\" for Linear Interpolation");
		return;
    }
    decl algorithmChkd = if (algorithm == NULL) then "LI" else algorithm;  // use linear interpolation as the default algorithm
    if ((allowextrap != 0) && (allowextrap !="No") && (allowextrap !="NO") && (allowextrap !="no") && (allowextrap !=1) && (allowextrap !="Yes") && (allowextrap !="YES") && (allowextrap !="yes") && (allowextrap !=NULL))
    {
		print_function_error( "Mod_Data_from_1tone_swpUNI_r1", "allowextrap must be set to 0, \"No\", \"NO\", \"no\", 1, \"Yes\", \"YES\", or \"yes\" ");
		return;
    }
    decl allowextrapChkd = if ((allowextrap == NULL) || (allowextrap == 1) || (allowextrap == "Yes") || (allowextrap == "YES") || (allowextrap == "yes")) then 1 else 0; // allow extrapolation as the default if no parameter passed.
    if (sweep_dim(inputSig) !=1) 
    {
		print_function_error( "Mod_Data_from_1tone_swpUNI_r1", "inputSig must be a 1-dimensional, complex voltage envelope versus time");
		return;
    }
    if (sourceZ == NULL)
    {
		print_function_error( "Mod_Data_from_1tone_swpUNI_r1", "You must enter the source impedance(s) used during the harmonic balance sweep(s)");
		return;                         // The function does not use a default value for sourceZ because doing so would give erroneous results if the user swept sourceZ but did not enter
    }                                // the swept value into the function.

    if (loadZ == NULL)
    {
		print_function_error( "Mod_Data_from_1tone_swpUNI_r1", "You must enter the load impedance(s) used during the harmonic balance sweep(s)");
		return;                         // The function does not use a default value for loadZ because doing so would give erroneous results if the user swept loadZ but did not enter
    }                                // the swept value into the function.

    if ((mainCh == NULL) || (size(mainCh) > 3) || (size(mainCh) != 2) || (sweep_size(mainCh) !=1) || (sweep_dim(mainCh) !=0))
    {
		print_function_error( "Mod_Data_from_1tone_swpUNI_r1", "There is something wrong with the mainCh parameter.  You must enter the main channel frequencies as an offset from the carrier.  Example: {-1.92 MHz, 1.92 MHz}");
		return;
    }
    if ((mainChForPout == NULL) || (size(mainChForPout) > 3) || (size(mainChForPout) != 2) || (sweep_size(mainChForPout) !=1) || (sweep_dim(mainChForPout) !=0))
    {
		print_function_error( "Mod_Data_from_1tone_swpUNI_r1", "There is something wrong with the mainChForPout parameter.  You must enter the main channel frequencies for modulated output power calculation as an offset from the carrier.  Example: {-1.92 MHz, 1.92 MHz}");
		return;
    }
    if ((lowerAdjCh == NULL) || (size(lowerAdjCh) > 3) || (size(lowerAdjCh) != 2) || (sweep_size(lowerAdjCh) !=1) || (sweep_dim(lowerAdjCh) !=0))
    {
		print_function_error( "Mod_Data_from_1tone_swpUNI_r1", "There is something wrong with the lowerAdjCh parameter.  You must enter the lower adjacent channel frequencies as an offset from the carrier.  Example: {-1.92 MHz, 1.92 MHz}-(5 MHz)");
		return;
    }
    if ((upperAdjCh == NULL) || (size(upperAdjCh) > 3) || (size(upperAdjCh) != 2) || (sweep_size(upperAdjCh) !=1) || (sweep_dim(upperAdjCh) !=0))
    {
		print_function_error( "Mod_Data_from_1tone_swpUNI_r1", "There is something wrong with the upperAdjCh parameter.  You must enter the upper adjacent channel frequencies as an offset from the carrier.  Example: {-1.92 MHz, 1.92 MHz}+(5 MHz)");
		return;
    }
    if ((lowerAltCh == NULL) || (size(lowerAltCh) > 3) || (size(lowerAltCh) != 2) || (sweep_size(lowerAltCh) !=1) || (sweep_dim(lowerAltCh) !=0))
    {
		print_function_error( "Mod_Data_from_1tone_swpUNI_r1", "There is something wrong with the lowerAltCh parameter.  You must enter the lower alternate channel frequencies as an offset from the carrier.  Example: {-1.92 MHz, 1.92 MHz}-(10 MHz)");
		return;
    }
    if ((upperAltCh == NULL) || (size(upperAltCh) > 3) || (size(upperAltCh) != 2) || (sweep_size(upperAltCh) !=1) || (sweep_dim(upperAltCh) !=0))
    {
		print_function_error( "Mod_Data_from_1tone_swpUNI_r1", "There is something wrong with the upperAltCh parameter.  You must enter the upper alternate channel frequencies as an offset from the carrier.  Example: {-1.92 MHz, 1.92 MHz}+(10 MHz)");
		return;
    }
    decl winTypeChkd = if (winType == NULL) then "Kaiser" else winType; // "Kaiser" is the default window type if no parameter passed.
    decl sweepDim = sweep_dim(charVoltage);
    decl resultList = NULL; 
   
    switch (sweepDim) {
    case 0: print_function_error( "Mod_Data_from_1tone_swpUNI_r1", " does not support single number data.");
	return;
	break;			
    case 1: 
	if (sweep_size(charVoltage)<sweep_size(inputSigPowers))
	{
		print_function_error( "Mod_Data_from_1tone_swpUNI_r1", "The number of modulated input signal power levels must be <= the number of input power values from the HB sweep.");
		return;
	}
	if (sweep_dim(loadZ)==1)
	{
		if (sweep_size(charVoltage) != sweep_size(loadZ))
		{
			print_function_error( "Mod_Data_from_1tone_swpUNI_r1", "The loadZ parameter should be a single number, or its independent variable should be the same as the charVoltage parameter's independent variable.");
			return;
		}
	}
	resultList = Mod_Data_from_1tone_swpUNI_1d_r1(algorithmChkd, allowextrapChkd, charVoltage, inputSig, inputSigPowers, sourceZ, loadZ, mainCh, mainChForPout, lowerAdjCh, upperAdjCh, lowerAltCh, upperAltCh, winTypeChkd, winConst);
	break;
    case 2: 
	if (sweep_size(charVoltage[0,::])<sweep_size(inputSigPowers))
	{
		print_function_error( "Mod_Data_from_1tone_swpUNI_r1", "The number of modulated input signal power levels must be <= the number of input power values from the HB sweep.");
		return;
	}
	if (sweep_dim(loadZ)==2)
	{
		if (sweep_size(charVoltage[0,::]) != sweep_size(loadZ[0,::]))
		{
			print_function_error( "Mod_Data_from_1tone_swpUNI_r1", "The loadZ parameter should be a single number, or its inner independent variable should be the same as the charVoltage parameter's inner independent variable.");
			return;
		}
	}
	if (sweep_dim(loadZ)==1)
	{
		if (sweep_size(charVoltage[0,::]) != sweep_size(loadZ))
		{
			print_function_error( "Mod_Data_from_1tone_swpUNI_r1", "The loadZ parameter should be a single number, or its inner independent variable should be the same as the charVoltage parameter's inner independent variable.");
			return;
		}
	}
	resultList = Mod_Data_from_1tone_swpUNI_2d_r1(algorithmChkd, allowextrapChkd, charVoltage, inputSig, inputSigPowers, sourceZ, loadZ, mainCh, mainChForPout, lowerAdjCh, upperAdjCh, lowerAltCh, upperAltCh, winTypeChkd, winConst);	 
	break;
	case 3: 
	if (sweep_size(charVoltage[0,0,::])<sweep_size(inputSigPowers))
	{
		print_function_error( "Mod_Data_from_1tone_swpUNI_r1", "The number of modulated input signal power levels must be <= the number of input power values from the HB sweep.");
		return;
	}
	if (sweep_dim(loadZ)==3)
	{
		if (sweep_size(charVoltage[0,0,::]) != sweep_size(loadZ[0,0,::]))
		{
			print_function_error( "Mod_Data_from_1tone_swpUNI_r1", "The loadZ parameter should be a single number, or its innermost independent variable should be the same as the charVoltage parameter's innermost independent variable.");
			return;
		}
	}
	if (sweep_dim(loadZ)==2)
	{
		if (sweep_size(charVoltage[0,0,::]) != sweep_size(loadZ[0,::]))
		{
			print_function_error( "Mod_Data_from_1tone_swpUNI_r1", "The loadZ parameter should be a single number, or its innermost independent variable should be the same as the charVoltage parameter's innermost independent variable.");
			return;
		}
	}
	if (sweep_dim(loadZ)==1)
	{
		if (sweep_size(charVoltage[0,0,::]) != sweep_size(loadZ))
		{
			print_function_error( "Mod_Data_from_1tone_swpUNI_r1", "The loadZ parameter should be a single number, or its innermost independent variable should be the same as the charVoltage parameter's innermost independent variable.");
			return;
		}
	}
	resultList = Mod_Data_from_1tone_swpUNI_3d(algorithmChkd, allowextrapChkd, charVoltage, inputSig, inputSigPowers, sourceZ, loadZ, mainCh, mainChForPout, lowerAdjCh, upperAdjCh, lowerAltCh, upperAltCh, winTypeChkd, winConst);	 
	break;
    default: print_function_error( "Mod_Data_from_1tone_swpUNI_r1", " does not support data with dimensions greater than three.");
	return;
	break;
    }

    return resultList;
} // fun - Mod_Data_from_1tone_swpUNI_r1

// fputs(stderr, " Defining function Mod_Data_from_1tone_swpUNI_3d");
defun Mod_Data_from_1tone_swpUNI_3d(algorithm, allowextrap, charVoltage, inputSig, inputSigPowers, sourceZ, loadZ, mainCh, mainChForPout, lowerAdjCh, upperAdjCh, lowerAltCh, upperAltCh, winType, winConst)
{
	decl debugFlag=0;
    decl numPts_i=sweep_size(charVoltage[::,0,0]);
	decl last_index_inputSigPowers=sweep_size(inputSigPowers)-1;
	decl charPower=indep(charVoltage[0,0,::]);
	decl sourceZparam;
    decl loadZparam;
	decl scaleFactorsTemp;
	decl temp;
    decl i;
	decl inputSigPowersReduced=inputSigPowers;
	if (!allowextrap)   	// If extrapolation is not allowed, the length of the result array will likely be shorter.
	{
		scaleFactorsTemp = calculate_scalefactors_1d_r1( allowextrap, charPower, inputSig, inputSigPowers, 50, debugFlag);  // This is just used to get the length of the result array.
		last_index_inputSigPowers=sweep_size(scaleFactorsTemp)-1;
	}
	if (last_index_inputSigPowers<1)
	{
		inputSigPowersReduced=min(inputSigPowers);
	} else
	{
		inputSigPowersReduced=inputSigPowers[0::last_index_inputSigPowers];
	}
    decl acpr_vs_inSigPower_array=vs({real(charVoltage[::,::,0::last_index_inputSigPowers]),real(charVoltage[::,::,0::last_index_inputSigPowers])},inputSigPowersReduced);
    decl altcpr_vs_inSigPower_array=vs({real(charVoltage[::,::,0::last_index_inputSigPowers]),real(charVoltage[::,::,0::last_index_inputSigPowers])},inputSigPowersReduced);
    decl main_channel_power_dBm_vs_Inpower_array=vs(real(charVoltage[::,::,0::last_index_inputSigPowers]),inputSigPowersReduced);
    decl evm_vs_Inpower_array=vs(real(charVoltage[::,::,0::last_index_inputSigPowers]),inputSigPowersReduced);
	decl acpr_array={real(charVoltage[::,::,0]),real(charVoltage[::,::,0])};
	decl altcpr_array={real(charVoltage[::,::,0]),real(charVoltage[::,::,0])};
	decl main_channel_power_dBm_array=real(charVoltage[::,::,0]);
	decl evm_array=real(charVoltage[::,::,0]);
    if ((sweep_dim(inputSigPowers)==0) || (last_index_inputSigPowers<1))  //  This is for the case where inputSigPowers is a single value.
	{
	    for (i=0; i<numPts_i; i++)
		{
			sourceZparam=if (sweep_dim(sourceZ)==3) then sourceZ[i,::,0] else if (sweep_dim(sourceZ)==2) then sourceZ[i,0] else if (sweep_dim(sourceZ)==1) then sourceZ[i] else sourceZ endif; // this handles the case where sourceZ is the swept parameter
			loadZparam=if (sweep_dim(loadZ)==3) then loadZ[i,::,0] else if (sweep_dim(loadZ)==2) then loadZ[i,0] else if (sweep_dim(loadZ)==1) then loadZ[i] else loadZ endif;         // this handles the case where loadZ is the swept parameter
			temp=Mod_Data_from_1tone_swpUNI_2d_r1(algorithm, allowextrap, charVoltage[i,::,::], inputSig, [inputSigPowersReduced::inputSigPowersReduced], sourceZparam, loadZparam, mainCh, mainChForPout, lowerAdjCh, upperAdjCh, lowerAltCh, upperAltCh, winType, winConst);
			acpr_array[i,::]=temp(0);
			altcpr_array[i,::]=temp(1);
			main_channel_power_dBm_array[i,::]=temp(2);
			evm_array[i,::]=temp(3);
		}
		return list(acpr_array, altcpr_array, main_channel_power_dBm_array, evm_array);		
	} else
	{
		for (i=0; i<numPts_i; i++)
		{
			sourceZparam=if (sweep_dim(sourceZ)==3) then sourceZ[i,::,0] else if (sweep_dim(sourceZ)==2) then sourceZ[i,0] else if (sweep_dim(sourceZ)==1) then sourceZ[i] else sourceZ endif; // this handles the case where sourceZ is the swept parameter
			loadZparam=if (sweep_dim(loadZ)==3) then loadZ[i,::,0] else if (sweep_dim(loadZ)==2) then loadZ[i,0] else if (sweep_dim(loadZ)==1) then loadZ[i] else loadZ endif;         // this handles the case where loadZ is the swept parameter
			temp=Mod_Data_from_1tone_swpUNI_2d_r1(algorithm, allowextrap, charVoltage[i,::,::], inputSig, inputSigPowersReduced, sourceZparam, loadZparam, mainCh, mainChForPout, lowerAdjCh, upperAdjCh, lowerAltCh, upperAltCh, winType, winConst);
			acpr_vs_inSigPower_array[i,::,::]=temp(0);
			altcpr_vs_inSigPower_array[i,::,::]=temp(1);
			main_channel_power_dBm_vs_Inpower_array[i,::,::]=temp(2);
			evm_vs_Inpower_array[i,::,::]=temp(3);
		}
		return list(acpr_vs_inSigPower_array, altcpr_vs_inSigPower_array, main_channel_power_dBm_vs_Inpower_array, evm_vs_Inpower_array);
	}
} //fun - Mod_Data_from_1tone_swpUNI_3d

// fputs(stderr, " Defining function Mod_Data_from_1tone_swpUNI_2d_r1");
defun Mod_Data_from_1tone_swpUNI_2d_r1(algorithm, allowextrap, charVoltage, inputSig, inputSigPowers, sourceZ, loadZ, mainCh, mainChForPout, lowerAdjCh, upperAdjCh, lowerAltCh, upperAltCh, winType, winConst)
{
	decl debugFlag=0;
    decl numPts_i=sweep_size(charVoltage[::,0]);
	decl last_index_inputSigPowers=sweep_size(inputSigPowers)-1;
	decl charPower=indep(charVoltage[0,::]);
	decl sourceZparam;
    decl loadZparam;
	decl scaleFactorsTemp;
	decl temp;
	decl i;
	decl inputSigPowersReduced=inputSigPowers;
	if (!allowextrap)   	// If extrapolation is not allowed, the length of the result array will likely be shorter.
	{
		scaleFactorsTemp = calculate_scalefactors_1d_r1( allowextrap, charPower, inputSig, inputSigPowers, 50, debugFlag);  // This is just used to get the length of the result array.
		last_index_inputSigPowers=sweep_size(scaleFactorsTemp)-1;
	}
	if (last_index_inputSigPowers<1)
	{
		inputSigPowersReduced=min(inputSigPowers);
	} else
	{
		inputSigPowersReduced=inputSigPowers[0::last_index_inputSigPowers];
	}
    decl acpr_vs_inSigPower_array=vs({real(charVoltage[::,0::last_index_inputSigPowers]),real(charVoltage[::,0::last_index_inputSigPowers])},inputSigPowersReduced); 
    decl altcpr_vs_inSigPower_array=vs({real(charVoltage[::,0::last_index_inputSigPowers]),real(charVoltage[::,0::last_index_inputSigPowers])},inputSigPowersReduced);
    decl main_channel_power_dBm_vs_Inpower_array=vs(real(charVoltage[::,0::last_index_inputSigPowers]),inputSigPowersReduced);
    decl evm_vs_Inpower_array=vs(real(charVoltage[::,0::last_index_inputSigPowers]),inputSigPowersReduced);
	decl acpr_array={real(charVoltage[::,0]),real(charVoltage[::,0])};
	decl altcpr_array={real(charVoltage[::,0]),real(charVoltage[::,0])};
	decl main_channel_power_dBm_array=real(charVoltage[::,0]);
	decl evm_array=real(charVoltage[::,0]);
    if ((sweep_dim(inputSigPowers)==0) || (last_index_inputSigPowers<1))   //  This is for the case where inputSigPowers is a single value.
	{
		for (i=0; i<numPts_i; i++)
		{
			sourceZparam=if (sweep_dim(sourceZ)==2) then sourceZ[i,0] else if (sweep_dim(sourceZ)==1) then sourceZ[i] else sourceZ endif; // this handles the case where sourceZ is the swept parameter
			loadZparam=if (sweep_dim(loadZ)==2) then loadZ[i,0] else if (sweep_dim(loadZ)==1) then loadZ[i] else loadZ endif;         // this handles the case where loadZ is the swept parameter
			temp=Mod_Data_from_1tone_swpUNI_1d_r1(algorithm, allowextrap, charVoltage[i,::], inputSig, [inputSigPowersReduced::inputSigPowersReduced], sourceZparam, loadZparam, mainCh, mainChForPout, lowerAdjCh, upperAdjCh, lowerAltCh, upperAltCh, winType, winConst);
			acpr_array[i]=temp[0];
			altcpr_array[i]=temp[1]; 
			main_channel_power_dBm_array[i]=temp[2];
			evm_array[i]=temp[3];
		}		
		return list(acpr_array, altcpr_array, main_channel_power_dBm_array, evm_array);		
	} else
	{
		for (i=0; i<numPts_i; i++)
		{
			sourceZparam=if (sweep_dim(sourceZ)==2) then sourceZ[i,0] else if (sweep_dim(sourceZ)==1) then sourceZ[i] else sourceZ endif; // this handles the case where sourceZ is the swept parameter
			loadZparam=if (sweep_dim(loadZ)==2) then loadZ[i,0] else if (sweep_dim(loadZ)==1) then loadZ[i] else loadZ endif;         // this handles the case where loadZ is the swept parameter
			temp=Mod_Data_from_1tone_swpUNI_1d_r1(algorithm, allowextrap, charVoltage[i,::], inputSig, inputSigPowersReduced, sourceZparam, loadZparam, mainCh, mainChForPout, lowerAdjCh, upperAdjCh, lowerAltCh, upperAltCh, winType, winConst);
			acpr_vs_inSigPower_array[i,::]=temp[0];
			altcpr_vs_inSigPower_array[i,::]=temp[1]; 
			main_channel_power_dBm_vs_Inpower_array[i,::]=temp[2];
			evm_vs_Inpower_array[i,::]=temp[3];
		}
		return list(acpr_vs_inSigPower_array, altcpr_vs_inSigPower_array, main_channel_power_dBm_vs_Inpower_array, evm_vs_Inpower_array);
	}
} //fun - Mod_Data_from_1tone_swpUNI_2d_r1

// fputs(stderr," Defining function Mod_Data_from_1tone_swpUNI_1d_r1");
defun Mod_Data_from_1tone_swpUNI_1d_r1(algorithm, allowextrap, charVoltage, inputSig, inputSigPowers, sourceZ, loadZ, mainCh, mainChForPout, lowerAdjCh, upperAdjCh, lowerAltCh, upperAltCh, winType, winConst)
{
/* *********************************************************************************
   Function: Mod_Data_from_1tone_swpUNI_1d_r1
   --------------------------------
   Returns:	An array of that contains the following:
   element 0: ACPR
   element 1: Alternate Channel Power Ratio
   element 2: Main Channel Power
   element 3: EVM
   *** The outputs below have been turned off to save time and memory. ***
   element 4: output from applying scaled modulated input to transfer function
   of DUT (as modelled by curve fit or linear interpolation)
   element 5: array of scale factors
   element 6: the modeled magnitude response
   element 7: the modeled phase response
   --------------------------------
   Arguments: 
   1) algorithm	-flag for approximating transfer function (vout/vin).  Set to
   "CF" to use curve fit, "LI" to use Linear Interpolation
   2) allowextrap	-flag for allowing extrapolation.  If set to 1, the scalefactors
   used to create the pseudo-power-swept modulated data will be 
   created from -30dBm to the the max input signal power.
   If allowextrap is set to 1, the scalefactors used to create the pseudo-power-swept 
   modulated data will be created from the inputSigPowers (units of dBm) passed into the function.
   If set to 0, extrapolation is not allowed and scale factors that
   cause the modulated signal power to exceed the power of the HB
   sweep are omitted.
   3) charVoltage	-output voltage from the HB sweep
   4) inputSig	-input modulated signal
   5) inputSigPowers -desired modulated signal input power levels
   6) sourceZ	-Source impedance
   7) loadZ	-Load impledance
   8) mainCh	-main channel limits
   9) mainChForPout  -main channel limits used when computing the output power
   10) lowerAdjCh	-lower adjacent channel limits
   11) upperAdjCh	-upper adjacent channel limits
   12) lowerAltCh  -lower alternate channel limits
   13) upperAltCh  -upper alternate channel limits
   14) winType	-window type (ie, Kaiser)
   15) winConst	-
   --------------------------------
   Usage:		This function must be called from the Data Display
   --------------------------------
   History:
   12/12/2006	Created based upon the script that AEH generated
   05/2013		Updated by AEH
   ********************************************************************************* */
	decl debugFlag=0;
    if(debugFlag)
    {
		fprintf(stderr,"DEBUG FLAG ON.\n  IN FUNCTION Mod_Data_from_1tone_swpUNI_1d_r1\n");
    }

    decl RFpower=indep(charVoltage);
    decl time=indep(inputSig);
	decl sourceZparam = if (sweep_dim(sourceZ)==1) then sourceZ[0] else sourceZ endif;
    decl loadZparam = if (sweep_dim(loadZ)==1) then loadZ[0] else loadZ endif;	
    decl scaleFactors=calculate_scalefactors_1d_r1( allowextrap, RFpower, inputSig, inputSigPowers, sourceZparam, debugFlag);  		// Calling 1d version of this function is sufficient.
	decl resultsArray=approxVoutVin_1d_r1(algorithm, allowextrap, charVoltage, sourceZparam, inputSig, scaleFactors, debugFlag);       // Calling 1d version of this function is sufficient.
    decl vout=resultsArray[0];
    decl scaledInputSig=vs(resultsArray[1],time);				// Added vs( ,time) so EVM calc would work.
    decl acpr = acpr_vi(vout,(vout/loadZparam),mainCh,lowerAdjCh,upperAdjCh,winType,winConst);
    decl altcpr = acpr_vi(vout,(vout/loadZparam),mainCh,lowerAltCh,upperAltCh,winType,winConst);
    decl main_channel_power = channel_power_vi(vout,(vout/loadZparam),mainChForPout,winType,winConst);
    decl main_channel_power_dBm = 10*log(main_channel_power)+30;
	
	decl inSigPower=mean(0.5*real(scaledInputSig*conj(scaledInputSig/(conj(sourceZparam)))));
    decl inSigPower_dBm=10*log(inSigPower)+30;	
    decl acpr_vs_inSigPower=vs(acpr,inSigPower_dBm);
    decl altcpr_vs_inSigPower=vs(altcpr,inSigPower_dBm);
    decl main_channel_power_dBm_vs_Inpower=vs(main_channel_power_dBm,inSigPower_dBm);
	decl timestep=time[1];  
	decl evm_vs_inSigPower;
	if (sweep_size(vout[0]) ==1)
	{
	 	evm_vs_inSigPower=vs(evm(scaledInputSig[0,::],vout[0,::],1/timestep,,0,,),inSigPower_dBm);  // 
	} else
	{
		evm_vs_inSigPower=vs(evm(scaledInputSig,vout,1/timestep,,0,,),inSigPower_dBm);  // 
	}
    if(debugFlag)
    {
		fputs(stderr,"  BOTTOM OF Mod_Data_from_1tone_swpUNI_1d FUNCTION");
    }
	return list(acpr_vs_inSigPower, altcpr_vs_inSigPower, main_channel_power_dBm_vs_Inpower, evm_vs_inSigPower);
}

// fputs(stderr, " Defining function ACPR_ChPwr_or_EVM_from_1tone_swp");
//***********************************************************************
  /*BEGIN_DOC
    FUN_NAME: ACPR_ChPwr_or_EVM_from_1tone_swp()
    FUN_DESCRIPTION: Returns an amplifier's adjacent or alternate channel power ratios, or main channel power, or error vector magnitude
    MAKE_PUBLIC: True
    RETURNED_VALUE: Real
    CATEGORY: Harmonic Balance and Envelope
    SYNTAX: ACPR_ChPwr_or_EVM_from_1tone_swp(returnVal, algorithm, allowextrap, charVoltage, inputSig, sourceZ, loadZ, mainCh, lowerAdjCh, upperAdjCh, winType, winConst)
    EXAMPLE:
    Vload_fundHB=Vload[1]
    Vin_fund=_3GPPFDD_UE_Tx_12_2_SigGen..Vsource
    Zsource=50
    Zload=50
    MainLimits={-3.84 MHz/2,3.84 MHz/2}
    LoChLimits=MainLimits-(5 MHz)
    UpChLimits=MainLimits+(5 MHz)
    LoChLimitsAlt=MainLimits-(10 MHz)
    UpChLimitsAlt=MainLimits+(10 MHz)
    ACPR_dBc=ACPR_ChPwr_or_EVM_from_1tone_swp("ACPR", "LI", "Yes", Vload_fundHB, Vin_fund, Zsource, Zload, MainLimits, LoChLimits, UpChLimits, "Kaiser",)
    AltCPR_dBc=ACPR_ChPwr_or_EVM_from_1tone_swp("ACPR", "LI", "Yes", Vload_fundHB, Vin_fund, Zsource, Zload, MainLimits, LoChLimitsAlt, UpChLimitsAlt, "Kaiser",)
    Pout_dBm=ACPR_ChPwr_or_EVM_from_1tone_swp("MAINCHP", "LI", "Yes", Vload_fundHB, Vin_fund, Zsource, Zload, MainLimits, LoChLimits, UpChLimits, "Kaiser",)
    ACPR_vs_Pout=vs(ACPR_dBc,Pout_dBm)
    AltCPR_vs_Pout=vs(AltCPR_dBc,Pout_dBm)
    EVM_percent=ACPR_ChPwr_or_EVM_from_1tone_swp("EVM", "LI", "Yes", Vload_fundHB, Vin_fund, Zsource, Zload, MainLimits, LoChLimits, UpChLimits, "Kaiser",)
    EVM_vs_Pout=vs(EVM_percent,Pout_dBm)
    ARGUMENT
    ARG_NAME: returnVal
    ARG_DESCRIPTION: Specifies what the function is to return.  Use "ACPR" for Adjacent (or Alternate) Channel Power Ratio (dBc), "MAINCHP" for Main Channel Power (dBm), or "EVM" for Error Vector Magnitude (%). 
    ARG_DEFAULT: None
    ARG_RANGE: "ACPR", "MAINCHP", or "EVM"
    ARG_TYPE: String
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: algorithm
    ARG_DESCRIPTION: Specifies the algorithm to be used to model the vout-versus-vin data from the HB sweep.  Use "CF" for Curve Fit or "LI" for Linear Interpolation.
    ARG_DEFAULT: None
    ARG_RANGE: "LI" or "CF"
    ARG_TYPE: String
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: allowextrap
    ARG_DESCRIPTION: Allow or disallow extrapolation when applying the scaled, modulated input signal to the vout-versus-vin model.
    ARG_DEFAULT: 1
    ARG_RANGE: 0, "No", "NO", "no", 1, "Yes", "YES", "yes"
    ARG_TYPE: String or Integer
    ARG_REQUIRED: NO
    ARGUMENT
    ARG_NAME: charVoltage
    ARG_DESCRIPTION: This is the characterization voltage (the fundamental output voltage from the harmonic balance sweep.)  Example: Vload_fund, where Vload_fund=Vload[1].
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: Complex
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: inputSig
    ARG_DESCRIPTION: This is the input modulated signal (the envelope.)  This signal should be a function of time, only.  
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: Complex
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: sourceZ
    ARG_DESCRIPTION: This is the source impedance.  This can be a swept parameter.
    ARG_DEFAULT: None
    ARG_RANGE: (0:inf)
    ARG_TYPE: Complex
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: loadZ
    ARG_DESCRIPTION: This is the load impedance.  This can be a swept parameter.
    ARG_DEFAULT: None
    ARG_RANGE: (0:inf)
    ARG_TYPE: Complex
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: mainCh
    ARG_DESCRIPTION: These are the main channel frequency limits, as an offset from the carrier frequency.  Example: {(-3.84 MHz/2),(3.84 MHz/2)}
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: 1X2 matrix, Real or Integer
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: lowerAdjCh
    ARG_DESCRIPTION: These are the lower adjacent (or alternate) channel frequency limits as an offset from the carrier frequency.  Example: MainLimits - (5 MHz)
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: 1X2 matrix, Real or Integer
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: upperAdjCh
    ARG_DESCRIPTION: These are the upper adjacent (or alternate) channel frequency limits as an offset from the carrier frequency.  Example: MainLimits + (5 MHz)
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: 1X2 matrix, Real or Integer
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: winType
    ARG_DESCRIPTION: window type
    ARG_DEFAULT: "Kaiser"
    ARG_RANGE: dagger.gif
    ARG_TYPE: string
    ARG_REQUIRED: NO
    ARGUMENT
    ARG_NAME: winConst
    ARG_DESCRIPTION: window constant that affects the shape of the applied window.
    ARG_DEFAULT: depends on winType used
    ARG_RANGE: [0:inf)
    ARG_TYPE: Real
    ARG_REQUIRED: NO
    FOOTNOTES: dagger.gif winType can be: "none", "hamming", "hanning", "gaussian", "kaiser", "8510", "blackman","blackman-harris"
    DEFINED_IN: 
    SEE ALSO: Mod_Data_from_1toneSwpUNI()
    NOTES: This function returns the adjacent or alternate channel power ratio (in dBc), main channel power (in dBm), or EVM in percent.  
    It can be used in a measurement expression in a schematic or in the data display.  While it is slower to use the 
    ACPR_ChPwr_or_EVM_from_1tone_swp() function on the schematic than the Mod_Data_from_1tone_swpUNI() in the data display, the advantage 
    is that the results are written into the dataset, and data displays that show these results open instantly. 
    However, when using ACPR_ChPwr_or_EVM_from_1tone_swp(), you have to call it once to get the adjacent channel power ratios, once 
    again to get the alternate channel power ratios, once again to get the main channel power, and once again to get the EVM.  The big 
    disadvantage of using the Mod_Data_from_1tone_swpUNI() is that this function will get executed each time you open a data display 
    that contains it.  
 
    For EVM, this single-tone method is not specification-compliant.  It just measures the 'raw' EVM, computed at each time point.  
    The EVM is computed after correcting for the average phase difference and RMS amplitude difference between the output and input 
    modulated signals.  If the modulated signal at the output of the amplifier has only a constant phase shift and a constant gain 
    (meaning that neither vary with the amplitude of the input modulated signal), then the EVM will be zero.  With this method, the 
    EVM is computed at each time point, not at just the symbol times.  There is no demodulation or decoding of the signal, so you can't 
    calculate the EVM of each sub-carrier, say for an LTE signal.

    For ACPR, this single-tone method does not include any receive-side filtering.  It just generates the spectrum at the output of 
    the amplifier, integrates the power in the main, adjacent, and alternate channels, then computes the ratios.
    The single-tone method of computing EVM (and ACPR) will tend to become less accurate as the bandwidth of the signal gets larger.  
    This is because this method assumes the response of the amplifier is constant across the modulation bandwidth (we're modeling the 
    nonlinearity by injecting a single tone at the carrier frequency, after all.)
    EXTERNAL: yes
    AUTHOR: Keysight Technologies (AEH)
    DATE: May 10 2010
    VERSION_CREATED: ADS 2009 Update 1
    END_DOC*/
  //***********************************************************************
  defun ACPR_ChPwr_or_EVM_from_1tone_swp(returnVal, algorithm, allowextrap, charVoltage, inputSig, sourceZ, loadZ, mainCh, lowerAdjCh, upperAdjCh, winType, winConst)
{
    if ((returnVal != "ACPR") && (returnVal != "MAINCHP") && (returnVal != "EVM") && (returnVal != NULL))
    {
	print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp", "returnVal must be set to \"ACPR\" for Adjacent or Alternate Channel Power Ratio, \"MAINCHP\" for Main Channel Power, or \"EVM\" for Error Vector Magnitude");
	return;
    }
    decl returnValChkd = if (returnVal == NULL) then "ACPR" else returnVal;  // return ACPR by default
    if ((algorithm != "CF") && (algorithm != "LI") && (algorithm != NULL))
    {
	print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp", "algorithm must be set to \"CF\" for Curve Fit or \"LI\" for Linear Interpolation");
	return;
    }
    decl algorithmChkd = if (algorithm == NULL) then "LI" else algorithm;  // use linear interpolation as the default algorithm
    if ((allowextrap != 0) && (allowextrap !="No") && (allowextrap !="NO") && (allowextrap !="no") && (allowextrap !=1) && (allowextrap !="Yes") && (allowextrap !="YES") && (allowextrap !="yes") && (allowextrap !=NULL))
    {
	print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp", "allowextrap must be set to 0, \"No\", \"NO\", \"no\", 1, \"Yes\", \"YES\", or \"yes\" ");
	return;
    }
    decl allowextrapChkd = if (allowextrap == NULL) then 1 else allowextrap; // allow extrapolation as the default if no parameter passed.
    if (sweep_dim(inputSig) !=1) 
    {
	print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp", "inputSig must be a 1-dimensional, complex voltage envelope versus time");
	return;
    }
    if (sourceZ == NULL)
    {
	print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp", "You must enter the source impedance(s) used during the harmonic balance sweep(s)");
	return;                         // The function does not use a default value for sourceZ because doing so would give erroneous results if the user swept sourceZ but did not enter
    }                                // the swept value into the function.
    decl sourceZ_Chkd = if (sweep_dim(sourceZ) == 2) then sourceZ[0] else sourceZ;
    if (loadZ == NULL)
    {
	print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp", "You must enter the load impedance(s) used during the harmonic balance sweep(s)");
	return;                         // The function does not use a default value for loadZ because doing so would give erroneous results if the user swept loadZ but did not enter
    }                                // the swept value into the function.
    decl loadZ_Chkd = if (sweep_dim(loadZ) == 2) then loadZ[0] else loadZ;
    if ((mainCh == NULL) || (size(mainCh) != 2) || (sweep_size(mainCh) !=1) || (sweep_dim(mainCh) !=0))
    {
	print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp", "There is something wrong with the mainCh parameter.  You must enter the main channel frequencies as an offset from the carrier.  Example: {-1.92 MHz, 1.92 MHz}");
	return;
    }
    if ((lowerAdjCh == NULL) || (size(lowerAdjCh) != 2) || (sweep_size(lowerAdjCh) !=1) || (sweep_dim(lowerAdjCh) !=0))
    {
	print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp", "There is something wrong with the lowerAdjCh parameter.  You must enter the lower adjacent channel frequencies as an offset from the carrier.  Example: {-1.92 MHz, 1.92 MHz}-(5 MHz)");
	return;
    }
    if ((upperAdjCh == NULL) || (size(upperAdjCh) != 2) || (sweep_size(upperAdjCh) !=1) || (sweep_dim(upperAdjCh) !=0))
    {
	print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp", "There is something wrong with the upperAdjCh parameter.  You must enter the upper adjacent channel frequencies as an offset from the carrier.  Example: {-1.92 MHz, 1.92 MHz}+(5 MHz)");
	return;
    }
    decl winTypeChkd = if (winType == NULL) then "Kaiser" else winType; // "Kaiser" is the default window type if no parameter passed.
    decl sweepDim = sweep_dim(charVoltage);
    decl results = NULL; 
   
    switch (sweepDim) {
    case 0: print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp", " does not support single number data.");
	return;
	break;
    case 1: results = ACPR_ChPwr_or_EVM_from_1tone_swp_1d(returnValChkd, algorithmChkd, allowextrapChkd, charVoltage, inputSig, sourceZ_Chkd, loadZ_Chkd, mainCh, lowerAdjCh, upperAdjCh, winTypeChkd, winConst);
	break;
    case 2: results = ACPR_ChPwr_or_EVM_from_1tone_swp_2d(returnValChkd, algorithmChkd, allowextrapChkd, charVoltage, inputSig, sourceZ_Chkd, loadZ_Chkd, mainCh, lowerAdjCh, upperAdjCh, winTypeChkd, winConst);	 
	break;
    default: print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp", " does not support data with dimensions greater than two.");
	return;
	break;
    }

    return results;
} // fun - ACPR_ChPwr_or_EVM_from_1tone_swp

// fputs(stderr, " Defining function ACPR_ChPwr_or_EVM_from_1tone_swp_2d");
defun ACPR_ChPwr_or_EVM_from_1tone_swp_2d(returnVal, algorithm, allowextrap, charVoltage, inputSig, sourceZ, loadZ, mainCh, lowerAdjCh, upperAdjCh, winType, winConst)
{
    decl numPts_i=sweep_size(charVoltage[::,0]);
    decl inumRows=2;
   
    if (returnVal=="ACPR")             // If ACPR, values returned are pairs of numbers
    {
	inumRows=2;
    } else if (returnVal=="MAINCHP" || returnVal=="EVM")   // If MAINCHP, values returned are scalars
    {
	inumRows=1;
    }
    decl result_array = create(2,"Real",{"indepVar1","InputPower_dBm"},{"Real","Real"}, inumRows, 1);
    decl pointerX1=indep(result_array,"indepVar1");
    decl pointerX2=indep(result_array,"InputPower_dBm");
   
    decl outerIndep=indep(charVoltage[0]);
    decl temp=result_array[0,::];
    decl sourceZparam;
    decl loadZparam;
    decl i;
    for (i=0; i<numPts_i; i++)
    {
	sourceZparam=if (sweep_dim(sourceZ)==1) then sourceZ[i] else sourceZ endif; // this handles the case where sourceZ is the swept parameter
	loadZparam=if (sweep_dim(loadZ)==1) then loadZ[i] else loadZ endif;         // this handles the case where loadZ is the swept parameter
	temp=ACPR_ChPwr_or_EVM_from_1tone_swp_1d(returnVal, algorithm, allowextrap, charVoltage[i,::], inputSig, sourceZparam, loadZparam, mainCh, lowerAdjCh, upperAdjCh, winType, winConst);
	result_array[i,::]=temp;
	 
	pointerX2[i,::]=indep(temp);
    }
    pointerX1[::]=outerIndep[::];
    return result_array;
} //fun ACPR_ChPwr_or_EVM_from_1tone_swp_2d

// fputs(stderr," Defining function ACPR_ChPwr_or_EVM_from_1tone_swp_1d");
defun ACPR_ChPwr_or_EVM_from_1tone_swp_1d(returnVal, algorithm, allowextrap, charVoltage, inputSig, sourceZ, loadZ, mainCh, lowerAdjCh, upperAdjCh, winType, winConst)
{
/* *********************************************************************************
   Function: ACPR_ChPwr_or_EVM_from_1tone_swp_1d
   --------------------------------
   Returns:	ACPR, Main Channel Power, or EVM
   --------------------------------
   Arguments: 
   1) returnVal	-flag for defining what to return.  "ACPR" returns ACPR,
   "MAINCHP" returns Main Channel Power, "EVM" returns Error Vector Magnitude.
   2) algorithm	-flag for approximating transfer function (vout/vin).  Set to
   "CF" to use curve fit, "LI" to use Linear Interpolation
   3) allowextrap	-flag for allowing extrapolation.  If set to 1, the scalefactors
   used to create the pseudo-power-swept modulated data will be 
   created from -30 dB to the the max input signal power.
   If set to 0, extrapolation is not allowed and scale factors that
   cause the modulated signal power to exceed the power of the HB
   sweep are omitted.
   4) charVoltage	-output voltage from the HB sweep
   5) inputSig	-input modulated signal
   6) sourceZ	-Source impedance
   7) loadZ	-Load impledance
   8) mainCh	-main channel limits
   9) lowerAdjCh	-lower channel limits
   10) upperAdjCh	-upper channel limits
   11) winType	-window type (ie, Kaiser)
   12) winConst	-
   --------------------------------
   Usage:		This function is called from the Data Display or schematic
   --------------------------------
   History:
   12/12/2006	Created based upon the script that AEH generated
   ********************************************************************************* */
    decl debug=0;
    decl RFpower=indep(charVoltage);  
    decl ReturnVal;
    decl time=indep(inputSig);

    if(debug)
    {
	fprintf(stderr,"DEBUG FLAG ON.\n  IN FUNCTION ACPR_ChPwr_or_EVM_from_1tone_swp\n");
	fprintf(stderr,"  Looking for: %s\n",returnVal);
	decl minPwr=min(RFpower);
	decl maxPwr=max(RFpower);
	decl minTime=min(time);
	decl maxTime=max(time);
	fprintf(stderr,"  minPwr=%f\n",minPwr);
	fprintf(stderr,"  maxPwr=%f\n",maxPwr);
	fprintf(stderr,"  minTime=%f\n",minTime);
	fprintf(stderr,"  maxTime=%f\n",maxTime);
	fprintf(stderr,"  CALLING ROUTINE scaleFactors\n");
    }

    decl scaleFactors=calculate_scalefactors( allowextrap, RFpower, inputSig, sourceZ, debug);

    if(debug)
    {
	fprintf(stderr,"  BACK FROM calculate_scalefactors, FIRST FACTOR IS %f\n", scaleFactors[0]);
	fprintf(stderr,"  CALLING ROUTINE approxvoutvin\n");
    }

    decl resultsArray=approxVoutVin(algorithm,charVoltage,sourceZ,inputSig,scaleFactors, debug);
    decl vout=resultsArray[0];
    // decl magFit=resultsArray[1];
    // decl phaseFit=resultsArray[2];
    decl scaledInputSig=resultsArray[1];
    decl inSigPower=channel_power_vr(scaledInputSig,real(sourceZ),mainCh,winType,winConst);
    decl inSigPower_dBm=10*log(inSigPower)+30;

    if (returnVal=="ACPR")
    {
	decl acpr = acpr_vr(vout,real(loadZ),mainCh,lowerAdjCh,upperAdjCh,winType,winConst);
	decl acpr_vs_inSigPower=vs(acpr,inSigPower_dBm);
	ReturnVal=acpr_vs_inSigPower;
    } else if (returnVal=="MAINCHP")
    {
	decl main_channel_power = channel_power_vr(vout,real(loadZ),mainCh,winType,winConst);
	decl main_channel_power_dBm = 10*log(main_channel_power)+30;
	decl main_channel_power_dBm_vs_Inpower=vs(main_channel_power_dBm,inSigPower_dBm);
	ReturnVal=main_channel_power_dBm_vs_Inpower;
    } else if (returnVal=="EVM")
    {
	decl timestep=time[1];
	decl temp;
	decl evm_vs_inSigPower=vs(scaleFactors,inSigPower_dBm);                
	decl i;
	decl numPts_i=sweep_size(scaleFactors);
	for (i=0; i<numPts_i; i++)
	{
	    temp=evm(inputSig,vout[i,::],1/timestep,,0,,);
	    evm_vs_inSigPower[i]=temp;
	}
	ReturnVal=evm_vs_inSigPower;
    }

    if(debug)
    {
	fputs(stderr,"  FUNCTION ACPR_or_ChPwr_from_1tone_swp_1d COMPLETED"); 
    }

    return(ReturnVal);
}

// fputs(stderr, " Defining function ACPR_ChPwr_or_EVM_from_1tone_swp_r1");
//***********************************************************************
  /*BEGIN_DOC
    FUN_NAME: ACPR_ChPwr_or_EVM_from_1tone_swp_r1()
    FUN_DESCRIPTION: Returns an amplifier's adjacent or alternate channel power ratios, or main channel power, or error vector magnitude
    MAKE_PUBLIC: True
    RETURNED_VALUE: Real
    CATEGORY: Harmonic Balance and Envelope
    SYNTAX: ACPR_ChPwr_or_EVM_from_1tone_swp_r1(returnVal, algorithm, allowextrap, charVoltage, inputSig, inputSigPowers, sourceZ, loadZ, mainCh, lowerAdjCh, upperAdjCh, winType, winConst)
    EXAMPLE:
    Vload_fundHB=Vload[1]
    Vin_fund=_3GPPFDD_UE_Tx_12_2_SigGen..Vsource[0::2000]
	inputSigPowers1=[-10::5::0]
	inputSigPowers2=[2::2::10]
	inputSigPowers=[inputSigPowers1,inputSigPowers2]
    Zsource=50
    Zload=50
    MainLimits={-3.84 MHz/2,3.84 MHz/2}
    LoChLimits=MainLimits-(5 MHz)
    UpChLimits=MainLimits+(5 MHz)
    LoChLimitsAlt=MainLimits-(10 MHz)
    UpChLimitsAlt=MainLimits+(10 MHz)
    ACPR_dBc=ACPR_ChPwr_or_EVM_from_1tone_swp("ACPR", "LI", "Yes", Vload_fundHB, Vin_fund, inputSigPowers, Zsource, Zload, MainLimits, LoChLimits, UpChLimits, "Kaiser",)
    AltCPR_dBc=ACPR_ChPwr_or_EVM_from_1tone_swp("ACPR", "LI", "Yes", Vload_fundHB, Vin_fund, inputSigPowers, Zsource, Zload, MainLimits, LoChLimitsAlt, UpChLimitsAlt, "Kaiser",)
    Pout_dBm=ACPR_ChPwr_or_EVM_from_1tone_swp("MAINCHP", "LI", "Yes", Vload_fundHB, Vin_fund, inputSigPowers, Zsource, Zload, MainLimits, LoChLimits, UpChLimits, "Kaiser",)
    ACPR_vs_Pout=vs(ACPR_dBc,Pout_dBm)
    AltCPR_vs_Pout=vs(AltCPR_dBc,Pout_dBm)
    EVM_percent=ACPR_ChPwr_or_EVM_from_1tone_swp("EVM", "LI", "Yes", Vload_fundHB, Vin_fund, inputSigPowers, Zsource, Zload, MainLimits, LoChLimits, UpChLimits, "Kaiser",)
    EVM_vs_Pout=vs(EVM_percent,Pout_dBm)
    ARGUMENT
    ARG_NAME: returnVal
    ARG_DESCRIPTION: Specifies what the function is to return.  Use "ACPR" for Adjacent (or Alternate) Channel Power Ratio (dBc), "MAINCHP" for Main Channel Power (dBm), or "EVM" for Error Vector Magnitude (%). 
    ARG_DEFAULT: None
    ARG_RANGE: "ACPR", "MAINCHP", or "EVM"
    ARG_TYPE: String
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: algorithm
    ARG_DESCRIPTION: Specifies the algorithm to be used to model the vout-versus-vin data from the HB sweep.  Use "CF" for Curve Fit or "LI" for Linear Interpolation.
    ARG_DEFAULT: None
    ARG_RANGE: "LI" or "CF"
    ARG_TYPE: String
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: allowextrap
    ARG_DESCRIPTION: Allow or disallow extrapolation when applying the scaled, modulated input signal to the vout-versus-vin model.
    ARG_DEFAULT: 1
    ARG_RANGE: 0, "No", "NO", "no", 1, "Yes", "YES", "yes"
    ARG_TYPE: String or Integer
    ARG_REQUIRED: NO
    ARGUMENT
    ARG_NAME: charVoltage
    ARG_DESCRIPTION: This is the characterization voltage (the fundamental output voltage from the harmonic balance sweep.)  Example: Vload_fund, where Vload_fund=Vload[1].
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: Complex
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: inputSig
    ARG_DESCRIPTION: This is the input modulated signal (the envelope.)  This signal should be a function of time, only.  
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: Complex
    ARG_REQUIRED: YES
	ARGUMENT
    ARG_NAME: inputSigPowers
    ARG_DESCRIPTION: This is either a single number or an array of modulated available source power values (in dBm).  
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: Real
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: sourceZ
    ARG_DESCRIPTION: This is the source impedance.  This can be a swept parameter.
    ARG_DEFAULT: None
    ARG_RANGE: (0:inf)
    ARG_TYPE: Complex
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: loadZ
    ARG_DESCRIPTION: This is the load impedance.  This can be a swept parameter.
    ARG_DEFAULT: None
    ARG_RANGE: (0:inf)
    ARG_TYPE: Complex
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: mainCh
    ARG_DESCRIPTION: These are the main channel frequency limits, as an offset from the carrier frequency.  Example: {(-3.84 MHz/2),(3.84 MHz/2)}
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: 1X2 matrix, Real or Integer
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: lowerAdjCh
    ARG_DESCRIPTION: These are the lower adjacent (or alternate) channel frequency limits as an offset from the carrier frequency.  Example: MainLimits - (5 MHz)
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: 1X2 matrix, Real or Integer
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: upperAdjCh
    ARG_DESCRIPTION: These are the upper adjacent (or alternate) channel frequency limits as an offset from the carrier frequency.  Example: MainLimits + (5 MHz)
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: 1X2 matrix, Real or Integer
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: winType
    ARG_DESCRIPTION: window type
    ARG_DEFAULT: "Kaiser"
    ARG_RANGE: dagger.gif
    ARG_TYPE: string
    ARG_REQUIRED: NO
    ARGUMENT
    ARG_NAME: winConst
    ARG_DESCRIPTION: window constant that affects the shape of the applied window.
    ARG_DEFAULT: depends on winType used
    ARG_RANGE: [0:inf)
    ARG_TYPE: Real
    ARG_REQUIRED: NO
    FOOTNOTES: dagger.gif winType can be: "none", "hamming", "hanning", "gaussian", "kaiser", "8510", "blackman","blackman-harris"
    DEFINED_IN: 
    SEE ALSO: Mod_Data_from_1toneSwpUNI_r1()
    NOTES: This function is similar to ACPR_ChPwr_or_EVM_from_1tone_swp() except that this revised version allows you to specify levels for the
	modulated input signal power, and it operates on data with up to 3 independent variables (one being the available source power from a 
	harmonic balance sweep.)
	
	This function returns the adjacent or alternate channel power ratio (in dBc), main channel power (in dBm), or EVM in percent.  
    It can be used in a measurement expression in a schematic or in the data display.  While it is slower to use the 
    ACPR_ChPwr_or_EVM_from_1tone_swp() function on the schematic than the Mod_Data_from_1tone_swpUNI() in the data display, the advantage 
    is that the results are written into the dataset, and data displays that show these results open instantly. 
    However, when using ACPR_ChPwr_or_EVM_from_1tone_swp(), you have to call it once to get the adjacent channel power ratios, once 
    again to get the alternate channel power ratios, once again to get the main channel power, and once again to get the EVM.  The big 
    disadvantage of using the Mod_Data_from_1tone_swpUNI() is that this function will get executed each time you open a data display 
    that contains it.  
 
    For EVM, this single-tone method is not specification-compliant.  It just measures the 'raw' EVM, computed at each time point.  
    The EVM is computed after correcting for the average phase difference and RMS amplitude difference between the output and input 
    modulated signals.  If the modulated signal at the output of the amplifier has only a constant phase shift and a constant gain 
    (meaning that neither vary with the amplitude of the input modulated signal), then the EVM will be zero.  With this method, the 
    EVM is computed at each time point, not at just the symbol times.  There is no demodulation or decoding of the signal, so you can't 
    calculate the EVM of each sub-carrier, say for an LTE signal.

    For ACPR, this single-tone method does not include any receive-side filtering.  It just generates the spectrum at the output of 
    the amplifier, integrates the power in the main, adjacent, and alternate channels, then computes the ratios.
    This single-tone method of computing EVM (and ACPR) will tend to become less accurate as the bandwidth of the signal gets larger.  
    This is because this method assumes the response of the amplifier is constant across the modulation bandwidth (we're modeling the 
    nonlinearity by injecting a single tone at the carrier frequency, after all.)
	
	This function can be made faster by reducing the number of values in the inSigPowers array and/or by limiting the number of time points in the
	Vin_fund modulated signal.  Adding syntax like [0::1000] or [0::2000] to the end of the equation defining the modulated signal limits the 
	number of time points included in the simulation.
	
	If allowextrap is set to 1, the modulated input signal will be scaled once for each value of the inputSigPowers (units of dBm) parameter.
	If set to 0, extrapolation is not allowed and scale factors that cause the modulated signal power to exceed the power of the HB sweep are omitted.
	
    EXTERNAL: yes
    AUTHOR: Keysight Technologies (AEH)
    DATE: May 21, 2013
    VERSION_CREATED: ADS 2012.08
    END_DOC*/
  //***********************************************************************
  defun ACPR_ChPwr_or_EVM_from_1tone_swp_r1(returnVal, algorithm, allowextrap, charVoltage, inputSig, inputSigPowers, sourceZ, loadZ, mainCh, lowerAdjCh, upperAdjCh, winType, winConst)
{
    if ((returnVal != "ACPR") && (returnVal != "MAINCHP") && (returnVal != "EVM") && (returnVal != NULL))
    {
		print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp_r1", "returnVal must be set to \"ACPR\" for Adjacent or Alternate Channel Power Ratio, \"MAINCHP\" for Main Channel Power, or \"EVM\" for Error Vector Magnitude");
		return;
    }
    decl returnValChkd = if (returnVal == NULL) then "ACPR" else returnVal;  // return ACPR by default
    if ((algorithm != "CF") && (algorithm != "LI") && (algorithm != NULL))
    {
		print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp_r1", "algorithm must be set to \"CF\" for Curve Fit or \"LI\" for Linear Interpolation");
		return;
    }
    decl algorithmChkd = if (algorithm == NULL) then "LI" else algorithm;  // use linear interpolation as the default algorithm
    if ((allowextrap != 0) && (allowextrap !="No") && (allowextrap !="NO") && (allowextrap !="no") && (allowextrap !=1) && (allowextrap !="Yes") && (allowextrap !="YES") && (allowextrap !="yes") && (allowextrap !=NULL))
    {
		print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp_r1", "allowextrap must be set to 0, \"No\", \"NO\", \"no\", 1, \"Yes\", \"YES\", or \"yes\" ");
		return;
    }
    decl allowextrapChkd = if ((allowextrap == NULL) || (allowextrap == 1) || (allowextrap == "Yes") || (allowextrap == "YES") || (allowextrap == "yes")) then 1 else 0; // allow extrapolation as the default if no parameter passed.
    if (sweep_dim(inputSig) !=1) 
    {
		print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp_r1", "inputSig must be a 1-dimensional, complex voltage envelope versus time");
		return;
    }
    if (sourceZ == NULL)
    {
		print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp_r1", "You must enter the source impedance(s) used during the harmonic balance sweep(s)");
		return;                         // The function does not use a default value for sourceZ because doing so would give erroneous results if the user swept sourceZ but did not enter
    }                                // the swept value into the function.
    if (loadZ == NULL)
    {
		print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp_r1", "You must enter the load impedance(s) used during the harmonic balance sweep(s)");
		return;                         // The function does not use a default value for loadZ because doing so would give erroneous results if the user swept loadZ but did not enter
    }                                // the swept value into the function.
    if ((mainCh == NULL) || (size(mainCh) > 3) || (size(mainCh) != 2) || (sweep_size(mainCh) !=1) || (sweep_dim(mainCh) !=0))
    {
		print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp_r1", "There is something wrong with the mainCh parameter.  You must enter the main channel frequencies as an offset from the carrier.  Example: {-1.92 MHz, 1.92 MHz}");
		return;
    }
    if ((lowerAdjCh == NULL) || (size(lowerAdjCh) > 3) || (size(lowerAdjCh) != 2) || (sweep_size(lowerAdjCh) !=1) || (sweep_dim(lowerAdjCh) !=0))
    {
		print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp_r1", "There is something wrong with the lowerAdjCh parameter.  You must enter the lower adjacent channel frequencies as an offset from the carrier.  Example: {-1.92 MHz, 1.92 MHz}-(5 MHz)");
		return;
    }
    if ((upperAdjCh == NULL) || (size(upperAdjCh) > 3) || (size(upperAdjCh) != 2) || (sweep_size(upperAdjCh) !=1) || (sweep_dim(upperAdjCh) !=0))
    {
		print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp_r1", "There is something wrong with the upperAdjCh parameter.  You must enter the upper adjacent channel frequencies as an offset from the carrier.  Example: {-1.92 MHz, 1.92 MHz}+(5 MHz)");
		return;
    }
    decl winTypeChkd = if (winType == NULL) then "Kaiser" else winType; // "Kaiser" is the default window type if no parameter passed.
    decl sweepDim = sweep_dim(charVoltage);
    decl results = NULL; 
   
    switch (sweepDim) {
    case 0: print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp_r1", " does not support single number data.");
	return;
	break;
    case 1: 
	if (sweep_size(charVoltage)<sweep_size(inputSigPowers))
	{
		print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp_r1", "The number of modulated input signal power levels must be <= the number of input power values from the HB sweep.");
		return;
	}
	if (sweep_dim(loadZ)==1)
	{
		if (sweep_size(charVoltage) != sweep_size(loadZ))
		{
			print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp_r1", "The loadZ parameter should be a single number, or its innermost independent variable should be the same as the charVoltage parameter's innermost independent variable.");
			return;
		}
	}
	results = ACPR_ChPwr_or_EVM_from_1tone_swp_1d_r1(returnValChkd, algorithmChkd, allowextrapChkd, charVoltage, inputSig, inputSigPowers, sourceZ, loadZ, mainCh, lowerAdjCh, upperAdjCh, winTypeChkd, winConst);
	break;
    case 2: 
	if (sweep_size(charVoltage[0,::])<sweep_size(inputSigPowers))
	{
		print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp_r1", "The number of modulated input signal power levels must be <= the number of input power values from the HB sweep.");
		return;
	}	
	if (sweep_dim(loadZ)==2)
	{
		if (sweep_size(charVoltage[0,::]) != sweep_size(loadZ[0,::]))
		{
			print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp_r1", "The loadZ parameter should be a single number, or its innermost independent variable should be the same as the charVoltage parameter's innermost independent variable.");
			return;
		}
	}
	if (sweep_dim(loadZ)==1)
	{
		if (sweep_size(charVoltage[0,::]) != sweep_size(loadZ))
		{
			print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp_r1", "The loadZ parameter should be a single number, or its innermost independent variable should be the same as the charVoltage parameter's innermost independent variable.");
			return;
		}
	}
	results = ACPR_ChPwr_or_EVM_from_1tone_swp_2d_r1(returnValChkd, algorithmChkd, allowextrapChkd, charVoltage, inputSig, inputSigPowers, sourceZ, loadZ, mainCh, lowerAdjCh, upperAdjCh, winTypeChkd, winConst);	 
	break;
	case 3: 
	if (sweep_size(charVoltage[0,0,::])<sweep_size(inputSigPowers))
	{
		print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp_r1", "The number of modulated input signal power levels must be <= the number of input power values from the HB sweep.");
		return;
	}
	if (sweep_dim(loadZ)==3)
	{
		if (sweep_size(charVoltage[0,0,::]) != sweep_size(loadZ[0,0,::]))
		{
			print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp_r1", "The loadZ parameter should be a single number, or its innermost independent variable should be the same as the charVoltage parameter's innermost independent variable.");
			return;
		}
	}
	if (sweep_dim(loadZ)==2)
	{
		if (sweep_size(charVoltage[0,0,::]) != sweep_size(loadZ[0,::]))
		{
			print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp_r1", "The loadZ parameter should be a single number, or its innermost independent variable should be the same as the charVoltage parameter's innermost independent variable.");
			return;
		}
	}
	if (sweep_dim(loadZ)==1)
	{
		if (sweep_size(charVoltage[0,0,::]) != sweep_size(loadZ))
		{
			print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp_r1", "The loadZ parameter should be a single number, or its innermost independent variable should be the same as the charVoltage parameter's innermost independent variable.");
			return;
		}
	}	
	results = ACPR_ChPwr_or_EVM_from_1tone_swp_3d(returnValChkd, algorithmChkd, allowextrapChkd, charVoltage, inputSig, inputSigPowers, sourceZ, loadZ, mainCh, lowerAdjCh, upperAdjCh, winTypeChkd, winConst);
	break;
    default: print_function_error( "ACPR_ChPwr_or_EVM_from_1tone_swp_r1", " does not support data with dimensions greater than three.");
	return;
	break;
    }

    return results;
} // fun - ACPR_ChPwr_or_EVM_from_1tone_swp_r1

// fputs(stderr, " Defining function ACPR_ChPwr_or_EVM_from_1tone_swp_3d");
defun ACPR_ChPwr_or_EVM_from_1tone_swp_3d(returnVal, algorithm, allowextrap, charVoltage, inputSig, inputSigPowers, sourceZ, loadZ, mainCh, lowerAdjCh, upperAdjCh, winType, winConst)
{
	decl debugFlag=0;
    decl numPts_i=sweep_size(charVoltage[::,0,0]);
	decl last_index_inputSigPowers=sweep_size(inputSigPowers)-1;
	decl charPower=indep(charVoltage[0,0,::]);
	decl sourceZparam;
    decl loadZparam;
	decl scaleFactorsTemp;
    decl i;
	decl inputSigPowersReduced=inputSigPowers;
	if (!allowextrap)   	// If extrapolation is not allowed, the length of the result array will likely be shorter.
	{
		scaleFactorsTemp = calculate_scalefactors_1d_r1( allowextrap, charPower, inputSig, inputSigPowers, 50, debugFlag);  // This is just used to get the length of the result array.
		last_index_inputSigPowers=sweep_size(scaleFactorsTemp)-1;
	}
	if (last_index_inputSigPowers<1)
	{
		inputSigPowersReduced=min(inputSigPowers);
	} else
	{
		inputSigPowersReduced=inputSigPowers[0::last_index_inputSigPowers];
	}
	decl result_array_3d_acpr=vs({real(charVoltage[::,::,0::last_index_inputSigPowers]),real(charVoltage[::,::,0::last_index_inputSigPowers])},inputSigPowersReduced); // result array initialized as 3d matrix in case ACPR must be returned.
	decl result_array_2d_acpr={real(charVoltage[::,::,0]),real(charVoltage[::,::,0])}; // same initialization as above, except for single point.  	
	decl result_array_3d_non_acpr=vs(real(charVoltage[::,::,0::last_index_inputSigPowers]),inputSigPowersReduced);  // result array initialized in case something other than ACPR must be returned.
	decl result_array_2d_non_acpr=real(charVoltage[::,::,0]);  // same initialization as above, except for a single point.  
	
	if (returnVal!="ACPR")
	{
		if ((sweep_dim(inputSigPowers)==0) || (last_index_inputSigPowers<1))
		{
			for (i=0; i<numPts_i; i++)
			{
				sourceZparam=if (sweep_dim(sourceZ)==3) then sourceZ[i,::,0] else if (sweep_dim(sourceZ)==2) then sourceZ[i,0] else if (sweep_dim(sourceZ)==1) then sourceZ[i] else sourceZ endif; // this handles the case where sourceZ is the swept parameter
				loadZparam=if (sweep_dim(loadZ)==3) then loadZ[i,::,0] else if (sweep_dim(loadZ)==2) then loadZ[i,0] else if (sweep_dim(loadZ)==1) then loadZ[i] else loadZ endif;         // this handles the case where loadZ is the swept parameter
				result_array_2d_non_acpr[i,::]=ACPR_ChPwr_or_EVM_from_1tone_swp_2d_r1(returnVal, algorithm, allowextrap, charVoltage[i,::,::], inputSig, [inputSigPowersReduced::inputSigPowersReduced], sourceZparam, loadZparam, mainCh, lowerAdjCh, upperAdjCh, winType, winConst);
			}
			return result_array_2d_non_acpr;
		} else
		{
			for (i=0; i<numPts_i; i++)
			{
				sourceZparam=if (sweep_dim(sourceZ)==3) then sourceZ[i,::,0] else if (sweep_dim(sourceZ)==2) then sourceZ[i,0] else if (sweep_dim(sourceZ)==1) then sourceZ[i] else sourceZ endif; // this handles the case where sourceZ is the swept parameter
				loadZparam=if (sweep_dim(loadZ)==3) then loadZ[i,::,0] else if (sweep_dim(loadZ)==2) then loadZ[i,0] else if (sweep_dim(loadZ)==1) then loadZ[i] else loadZ endif;         // this handles the case where loadZ is the swept parameter
				result_array_3d_non_acpr[i,::,::]=ACPR_ChPwr_or_EVM_from_1tone_swp_2d_r1(returnVal, algorithm, allowextrap, charVoltage[i,::,::], inputSig, inputSigPowersReduced, sourceZparam, loadZparam, mainCh, lowerAdjCh, upperAdjCh, winType, winConst);
			}
			return result_array_3d_non_acpr;
		}
	} else
	{
		if ((sweep_dim(inputSigPowers)==0) || (last_index_inputSigPowers<1))
		{
			for (i=0; i<numPts_i; i++)
			{
				sourceZparam=if (sweep_dim(sourceZ)==3) then sourceZ[i,::,0] else if (sweep_dim(sourceZ)==2) then sourceZ[i,0] else if (sweep_dim(sourceZ)==1) then sourceZ[i] else sourceZ endif; // this handles the case where sourceZ is the swept parameter
				loadZparam=if (sweep_dim(loadZ)==3) then loadZ[i,::,0] else if (sweep_dim(loadZ)==2) then loadZ[i,0] else if (sweep_dim(loadZ)==1) then loadZ[i] else loadZ endif;         // this handles the case where loadZ is the swept parameter
				result_array_2d_acpr[i,::]=ACPR_ChPwr_or_EVM_from_1tone_swp_2d_r1(returnVal, algorithm, allowextrap, charVoltage[i,::,::], inputSig, [inputSigPowersReduced::inputSigPowersReduced], sourceZparam, loadZparam, mainCh, lowerAdjCh, upperAdjCh, winType, winConst);
			}
			return result_array_2d_acpr;
		} else
		{
			for (i=0; i<numPts_i; i++)
			{
				sourceZparam=if (sweep_dim(sourceZ)==3) then sourceZ[i,::,0] else if (sweep_dim(sourceZ)==2) then sourceZ[i,0] else if (sweep_dim(sourceZ)==1) then sourceZ[i] else sourceZ endif; // this handles the case where sourceZ is the swept parameter
				loadZparam=if (sweep_dim(loadZ)==3) then loadZ[i,::,0] else if (sweep_dim(loadZ)==2) then loadZ[i,0] else if (sweep_dim(loadZ)==1) then loadZ[i] else loadZ endif;         // this handles the case where loadZ is the swept parameter
				result_array_3d_acpr[i,::,::]=ACPR_ChPwr_or_EVM_from_1tone_swp_2d_r1(returnVal, algorithm, allowextrap, charVoltage[i,::,::], inputSig, inputSigPowersReduced, sourceZparam, loadZparam, mainCh, lowerAdjCh, upperAdjCh, winType, winConst);
			}
			return result_array_3d_acpr;
		}	
	}
} //fun ACPR_ChPwr_or_EVM_from_1tone_swp_3d

// fputs(stderr, " Defining function ACPR_ChPwr_or_EVM_from_1tone_swp_2d_r1");
defun ACPR_ChPwr_or_EVM_from_1tone_swp_2d_r1(returnVal, algorithm, allowextrap, charVoltage, inputSig, inputSigPowers, sourceZ, loadZ, mainCh, lowerAdjCh, upperAdjCh, winType, winConst)
{
    decl debugFlag=0;
    decl numPts_i=sweep_size(charVoltage[::,0]);
	decl last_index_inputSigPowers=sweep_size(inputSigPowers)-1;
	decl charPower=indep(charVoltage[0,::]);
	decl sourceZparam;
    decl loadZparam;
	decl scaleFactorsTemp;
	decl i;
	decl inputSigPowersReduced=inputSigPowers;
	if (!allowextrap)   	// If extrapolation is not allowed, the length of the result array will likely be shorter.
	{
		scaleFactorsTemp = calculate_scalefactors_1d_r1( allowextrap, charPower, inputSig, inputSigPowers, 50, debugFlag);  // This is just used to get the length of the result array.
		last_index_inputSigPowers=sweep_size(scaleFactorsTemp)-1;
	}
	if (last_index_inputSigPowers<1)
	{
		inputSigPowersReduced=min(inputSigPowers);
	} else
	{
		inputSigPowersReduced=inputSigPowers[0::last_index_inputSigPowers];
	}
	decl result_array_2d_acpr=vs({real(charVoltage[::,0::last_index_inputSigPowers]),real(charVoltage[::,0::last_index_inputSigPowers])},inputSigPowersReduced); // result array initialized as 2d matrix in case ACPR must be returned.
	decl result_array_1d_acpr={real(charVoltage[::,0]),real(charVoltage[::,0])}; // same initialization as above, except for single point.  
	decl result_array_2d_non_acpr=vs(real(charVoltage[::,0::last_index_inputSigPowers]),inputSigPowersReduced);  // result array initialized in case something other than ACPR must be returned.
	decl result_array_1d_non_acpr=real(charVoltage[::,0]);  // same initialization as above, except for a single point.  
	
	if (returnVal!="ACPR")
	{
		if ((sweep_dim(inputSigPowers)==0) || (last_index_inputSigPowers<1))   //  This is for the case where inputSigPowers is a single value.
		{
			for (i=0; i<numPts_i; i++)
			{
				sourceZparam=if (sweep_dim(sourceZ)==2) then sourceZ[i,0] else if (sweep_dim(sourceZ)==1) then sourceZ[i] else sourceZ endif; // this handles the case where sourceZ is the swept parameter
				loadZparam=if (sweep_dim(loadZ)==2) then loadZ[i,0] else if (sweep_dim(loadZ)==1) then loadZ[i] else loadZ endif;         // this handles the case where loadZ is the swept parameter
				result_array_1d_non_acpr[i]=ACPR_ChPwr_or_EVM_from_1tone_swp_1d_r1(returnVal, algorithm, allowextrap, charVoltage[i,::], inputSig, [inputSigPowersReduced::inputSigPowersReduced], sourceZparam, loadZparam, mainCh, lowerAdjCh, upperAdjCh, winType, winConst);
			}
			return result_array_1d_non_acpr;  
		} else
		{
			for (i=0; i<numPts_i; i++)
			{
				sourceZparam=if (sweep_dim(sourceZ)==2) then sourceZ[i,0] else if (sweep_dim(sourceZ)==1) then sourceZ[i] else sourceZ endif; // this handles the case where sourceZ is the swept parameter
				loadZparam=if (sweep_dim(loadZ)==2) then loadZ[i,0] else if (sweep_dim(loadZ)==1) then loadZ[i] else loadZ endif;         // this handles the case where loadZ is the swept parameter
				result_array_2d_non_acpr[i,::]=ACPR_ChPwr_or_EVM_from_1tone_swp_1d_r1(returnVal, algorithm, allowextrap, charVoltage[i,::], inputSig, inputSigPowersReduced, sourceZparam, loadZparam, mainCh, lowerAdjCh, upperAdjCh, winType, winConst);
			}
			return result_array_2d_non_acpr;
		}
	} else
	{
		if ((sweep_dim(inputSigPowers)==0) || (last_index_inputSigPowers<1))   //  This is for the case where inputSigPowers is a single value.
		{
			for (i=0; i<numPts_i; i++)
			{
				sourceZparam=if (sweep_dim(sourceZ)==2) then sourceZ[i,0] else if (sweep_dim(sourceZ)==1) then sourceZ[i] else sourceZ endif; // this handles the case where sourceZ is the swept parameter
				loadZparam=if (sweep_dim(loadZ)==2) then loadZ[i,0] else if (sweep_dim(loadZ)==1) then loadZ[i] else loadZ endif;         // this handles the case where loadZ is the swept parameter
				result_array_1d_acpr[i]=ACPR_ChPwr_or_EVM_from_1tone_swp_1d_r1(returnVal, algorithm, allowextrap, charVoltage[i,::], inputSig, [inputSigPowersReduced::inputSigPowersReduced], sourceZparam, loadZparam, mainCh, lowerAdjCh, upperAdjCh, winType, winConst);
			}
			return result_array_1d_acpr; 
		} else
		{
			for (i=0; i<numPts_i; i++)
			{
				sourceZparam=if (sweep_dim(sourceZ)==2) then sourceZ[i,0] else if (sweep_dim(sourceZ)==1) then sourceZ[i] else sourceZ endif; // this handles the case where sourceZ is the swept parameter
				loadZparam=if (sweep_dim(loadZ)==2) then loadZ[i,0] else if (sweep_dim(loadZ)==1) then loadZ[i] else loadZ endif;         // this handles the case where loadZ is the swept parameter
				result_array_2d_acpr[i,::]=ACPR_ChPwr_or_EVM_from_1tone_swp_1d_r1(returnVal, algorithm, allowextrap, charVoltage[i,::], inputSig, inputSigPowersReduced, sourceZparam, loadZparam, mainCh, lowerAdjCh, upperAdjCh, winType, winConst);
			}
			return result_array_2d_acpr;
		}
	}
    if(debugFlag)
    {
		fputs(stderr,"  FUNCTION ACPR_or_ChPwr_from_1tone_swp_2d_r1 COMPLETED"); 
    }
} //fun ACPR_ChPwr_or_EVM_from_1tone_swp_2d_r1

// fputs(stderr," Defining function ACPR_ChPwr_or_EVM_from_1tone_swp_1d_r1");
defun ACPR_ChPwr_or_EVM_from_1tone_swp_1d_r1(returnVal, algorithm, allowextrap, charVoltage, inputSig, inputSigPowers, sourceZ, loadZ, mainCh, lowerAdjCh, upperAdjCh, winType, winConst)
{
/* *********************************************************************************
   Function: ACPR_ChPwr_or_EVM_from_1tone_swp_1d_r1
   --------------------------------
   Returns:	ACPR, Main Channel Power, or EVM
   --------------------------------
   Arguments: 
   1) returnVal	-flag for defining what to return.  "ACPR" returns ACPR,
   "MAINCHP" returns Main Channel Power, "EVM" returns Error Vector Magnitude.
   2) algorithm	-flag for approximating transfer function (vout/vin).  Set to
   "CF" to use curve fit, "LI" to use Linear Interpolation
   3) allowextrap	-flag for allowing extrapolation.  	
	If allowextrap is set to 1, the modulated input signal will be scaled once for each 
	value of the inputSigPowers (units of dBm) parameter.
	If set to 0, extrapolation is not allowed and scale factors that cause the modulated 
	signal power to exceed the power of the HB sweep are omitted.
   4) charVoltage	-output voltage from the HB sweep
   5) inputSig	-input modulated signal
   6) inputSigPowers -desired modulated input signal powers (dBm)
   7) sourceZ	-Source impedance
   8) loadZ	-Load impledance
   9) mainCh	-main channel limits
   10) lowerAdjCh	-lower channel limits
   11) upperAdjCh	-upper channel limits
   12) winType	-window type (ie, Kaiser)
   13) winConst	-
   --------------------------------
   Usage:		This function is called from the Data Display or schematic
   --------------------------------
   History:
   12/12/2006	Created based upon the script that AEH generated
   05/2013		Updated by AEH.
   ********************************************************************************* */
    decl debugFlag=0;
    decl RFpower=indep(charVoltage);  
    decl ReturnVal;
    decl time=indep(inputSig);
	decl sourceZparam = if (sweep_dim(sourceZ)==1) then sourceZ[0] else sourceZ endif;
    decl loadZparam = if (sweep_dim(loadZ)==1) then loadZ[0] else loadZ endif;

    if(debugFlag)
    {
		fprintf(stderr,"DEBUG FLAG ON.\n  IN FUNCTION ACPR_ChPwr_or_EVM_from_1tone_swp_1d_r1\n");
		fprintf(stderr,"  Looking for: %s\n",returnVal);
		// decl maxTime=max(time);
		// fprintf(stderr,"  maxTime=%f\n",maxTime);
		fprintf(stderr,"  CALLING ROUTINE calculate_scaleFactors_1d_r1\n");
    }
    decl scaleFactors=calculate_scalefactors_1d_r1( allowextrap, RFpower, inputSig, inputSigPowers, sourceZparam, debugFlag); // Calling 1d version of this function is sufficient
    if(debugFlag)
    {
		fprintf(stderr,"  BACK FROM calculate_scalefactors\n");
		fprintf(stderr,"  CALLING ROUTINE approxVoutVin_1d_r1\n");
    }

    decl resultsArray=approxVoutVin_1d_r1(algorithm,allowextrap,charVoltage,sourceZparam,inputSig,scaleFactors, debugFlag);   			// Calling 1d-version of this function is sufficient
	decl vout=resultsArray[0];
    // decl magFit=resultsArray[1];
    // decl phaseFit=resultsArray[2];
    decl scaledInputSig=vs(resultsArray[1],time);											// Added vs( ,time) so EVM calc would work.
	decl inSigPower=mean(0.5*real(scaledInputSig*conj(scaledInputSig/(conj(sourceZparam)))));	
    decl inSigPower_dBm=10*log(inSigPower)+30;

    if (returnVal=="ACPR")
    {
		decl acpr = acpr_vi(vout,(vout/loadZparam),mainCh,lowerAdjCh,upperAdjCh,winType,winConst);
		decl acpr_vs_inSigPower=vs(acpr,inSigPower_dBm);
		ReturnVal=acpr_vs_inSigPower;
    } else if (returnVal=="MAINCHP")
    {
		decl main_channel_power = channel_power_vi(vout,(vout/loadZparam),mainCh,winType,winConst);
		decl main_channel_power_dBm = 10*log(main_channel_power)+30;
		decl main_channel_power_dBm_vs_Inpower=vs(main_channel_power_dBm,inSigPower_dBm);
		ReturnVal=main_channel_power_dBm_vs_Inpower;
    } else if (returnVal=="EVM")
	{
	    decl timestep=time[1];  
		decl evm_vs_inSigPower;
		if (sweep_size(vout[0])==1)
		{
			evm_vs_inSigPower=vs(evm(scaledInputSig[0,::],vout[0,::],1/timestep,,0,,),inSigPower_dBm);  // 
		} else
		{
			evm_vs_inSigPower=vs(evm(scaledInputSig,vout,1/timestep,,0,,),inSigPower_dBm);  // 
		}
		ReturnVal=evm_vs_inSigPower;
    }
    if(debugFlag)
    {
		fputs(stderr,"  FUNCTION ACPR_or_ChPwr_from_1tone_swp_1d_r1 COMPLETED"); 
    }
    return(ReturnVal);
}

// fputs(stderr, " Defining function Data_from_1tone_swp");
//***********************************************************************
  /*BEGIN_DOC
    FUN_NAME: Data_from_1tone_swp()
    FUN_DESCRIPTION: Returns the mean value of some performance, such as an amplifier's bias current, when a modulated signal is applied
    RETURNED_VALUE: Real or Complex dagger.gif
    CATEGORY: Harmonic Balance and Envelope
    SYNTAX: Data_from_1tone_swp(algorithm, allowextrap, charData, inputSig, inputSigPowers, sourceZ, loadZ)
    EXAMPLE:
    I_Bias_DC=real(I_Bias.i[0])
    Vin_fund=_3GPPFDD_UE_Tx_12_2_SigGen..Vsource[0::2000]
	inputSigPowers1=[-10::5::0]
	inputSigPowers2=[2::2::10]
	inputSigPowers=[inputSigPowers1,inputSigPowers2]
    Zsource=50
    Zload=50
    Mean_I_Bias=Data_from_1tone_swp("LI", "Yes", I_Bias_DC, Vin_fund, inputSigPowers, Zsource, Zload)
    ARGUMENT
    ARG_NAME: algorithm
    ARG_DESCRIPTION: Specifies the algorithm to be used to model the Data-versus-vin data from the HB sweep.  Use "CF" for Curve Fit or "LI" for Linear Interpolation.
    ARG_DEFAULT: None
    ARG_RANGE: "LI" or "CF"
    ARG_TYPE: String
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: allowextrap
    ARG_DESCRIPTION: Allow or disallow extrapolation when applying the scaled, modulated input signal to the Data-versus-vin model.
    ARG_DEFAULT: 1
    ARG_RANGE: 0, "No", "NO", "no", 1, "Yes", "YES", "yes"
    ARG_TYPE: String or Integer
    ARG_REQUIRED: NO
    ARGUMENT
    ARG_NAME: charData
    ARG_DESCRIPTION: This is the characterization data from the harmonic balance sweep.  Example: I_Bias_DC, where I_Bias_DC=real(I_Bias.i[0]).
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: Complex
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: inputSig
    ARG_DESCRIPTION: This is the input modulated signal (the envelope.)  This signal should be a function of time, only.  
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: Complex
    ARG_REQUIRED: YES
	ARGUMENT
    ARG_NAME: inputSigPowers
    ARG_DESCRIPTION: This is either a single number or an array of modulated available source power values (in dBm).  
    ARG_DEFAULT: None
    ARG_RANGE: (-inf:inf)
    ARG_TYPE: Real
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: sourceZ
    ARG_DESCRIPTION: This is the source impedance.  This can be a swept parameter.
    ARG_DEFAULT: None
    ARG_RANGE: (0:inf)
    ARG_TYPE: Complex
    ARG_REQUIRED: YES
    ARGUMENT
    ARG_NAME: loadZ
    ARG_DESCRIPTION: This is the load impedance.  This can be a swept parameter.
    ARG_DEFAULT: None
    ARG_RANGE: (0:inf)
    ARG_TYPE: Complex
    ARG_REQUIRED: YES
	FOOTNOTES: dagger.gif If charData is real, then the returned value is real.  If charData is complex, the returned value is complex.
    DEFINED_IN: 

    NOTES: This function takes the data, such as bias current, from a swept-power harmonic balance simulation, and computes the mean value of the data 
	when a modulated signal is applied.  The function handles data with up to 3 independent variables.  The innermost is assumed to be the swept input
	power.  

	If this function is used on a data display page, it will get executed each time you open a data display that contains it.  
    If the function is used on a schematic, the advantage is that the results are written into the dataset, and data displays that show these results 
	should open more quickly.  

    This single-tone method of computing data will tend to become less accurate as the bandwidth of the signal gets larger.  
    This is because this method assumes the response of the amplifier (or circuit) is constant across the modulation bandwidth (we're modeling the 
    nonlinearity by injecting a single tone at the carrier frequency, after all.)
	
	This function can be made faster by reducing the number of values in the inSigPowers array and/or by limiting the number of time points in the
	Vin_fund modulated signal.  Adding syntax like [0::1000] or [0::2000] to the end of the equation defining the modulated signal limits the 
	number of time points included in the simulation.
	
	If allowextrap is set to 1, the modulated input signal will be scaled once for each value of the inputSigPowers (units of dBm) parameter.
	If set to 0, extrapolation is not allowed and scale factors that cause the modulated signal power to exceed the power of the HB sweep are omitted.
	
    EXTERNAL: yes
    AUTHOR: Keysight Technologies (AEH)
    DATE: Dec 12, 2013
    VERSION_CREATED: ADS 2012.08
    END_DOC*/
  //***********************************************************************
  defun Data_from_1tone_swp(algorithm, allowextrap, charData, inputSig, inputSigPowers, sourceZ, loadZ)
{
    if ((algorithm != "CF") && (algorithm != "LI") && (algorithm != NULL))
    {
		print_function_error( "Data_from_1tone_swp", "algorithm must be set to \"CF\" for Curve Fit or \"LI\" for Linear Interpolation");
		return;
    }
    decl algorithmChkd = if (algorithm == NULL) then "LI" else algorithm;  // use linear interpolation as the default algorithm
    if ((allowextrap != 0) && (allowextrap !="No") && (allowextrap !="NO") && (allowextrap !="no") && (allowextrap !=1) && (allowextrap !="Yes") && (allowextrap !="YES") && (allowextrap !="yes") && (allowextrap !=NULL))
    {
		print_function_error( "Data_from_1tone_swp", "allowextrap must be set to 0, \"No\", \"NO\", \"no\", 1, \"Yes\", \"YES\", or \"yes\" ");
		return;
    }
    decl allowextrapChkd = if ((allowextrap == NULL) || (allowextrap == 1) || (allowextrap == "Yes") || (allowextrap == "YES") || (allowextrap == "yes")) then 1 else 0; // allow extrapolation as the default if no parameter passed.
    if (sweep_dim(inputSig) !=1) 
    {
		print_function_error( "Data_from_1tone_swp", "inputSig must be a 1-dimensional, complex voltage envelope versus time");
		return;
    }
    if (sourceZ == NULL)
    {
		print_function_error( "Data_from_1tone_swp", "You must enter the source impedance(s) used during the harmonic balance sweep(s)");
		return;                         // The function does not use a default value for sourceZ because doing so would give erroneous results if the user swept sourceZ but did not enter
    }                                // the swept value into the function.

    if (loadZ == NULL)
    {
		print_function_error( "Data_from_1tone_swp", "You must enter the load impedance(s) used during the harmonic balance sweep(s)");
		return;                         // The function does not use a default value for loadZ because doing so would give erroneous results if the user swept loadZ but did not enter
    }                                // the swept value into the function.

    decl sweepDim = sweep_dim(charData);
    decl result = NULL; 
   
    switch (sweepDim) {
    case 0: print_function_error( "Data_from_1tone_swp", " does not support single number data.");
	return;
	break;			
    case 1: 
	if (sweep_size(charData)<sweep_size(inputSigPowers))
	{
		print_function_error( "Data_from_1tone_swp", "The number of modulated input signal power levels must be <= the number of input power values from the HB sweep.");
		return;
	}
	if (sweep_dim(loadZ)==1)
	{
		if (sweep_size(charData) != sweep_size(loadZ))
		{
			print_function_error( "Data_from_1tone_swp", "The loadZ parameter should be a single number, or its independent variable should be the same as the charData parameter's independent variable.");
			return;
		}
	}
	result = Data_from_1tone_swp_1d(algorithmChkd, allowextrapChkd, charData, inputSig, inputSigPowers, sourceZ, loadZ);
	break;
    case 2: 
	if (sweep_size(charData[0,::])<sweep_size(inputSigPowers))
	{
		print_function_error( "Data_from_1tone_swp", "The number of modulated input signal power levels must be <= the number of input power values from the HB sweep.");
		return;
	}
	if (sweep_dim(loadZ)==2)
	{
		if (sweep_size(charData[0,::]) != sweep_size(loadZ[0,::]))
		{
			print_function_error( "Data_from_1tone_swp", "The loadZ parameter should be a single number, or its inner independent variable should be the same as the charData parameter's inner independent variable.");
			return;
		}
	}
	if (sweep_dim(loadZ)==1)
	{
		if (sweep_size(charData[0,::]) != sweep_size(loadZ))
		{
			print_function_error( "Data_from_1tone_swp", "The loadZ parameter should be a single number, or its inner independent variable should be the same as the charData parameter's inner independent variable.");
			return;
		}
	}
	result = Data_from_1tone_swp_2d(algorithmChkd, allowextrapChkd, charData, inputSig, inputSigPowers, sourceZ, loadZ);	 
	break;
	case 3: 
	if (sweep_size(charData[0,0,::])<sweep_size(inputSigPowers))
	{
		print_function_error( "Data_from_1tone_swp", "The number of modulated input signal power levels must be <= the number of input power values from the HB sweep.");
		return;
	}
	if (sweep_dim(loadZ)==3)
	{
		if (sweep_size(charData[0,0,::]) != sweep_size(loadZ[0,0,::]))
		{
			print_function_error( "Data_from_1tone_swp", "The loadZ parameter should be a single number, or its innermost independent variable should be the same as the charData parameter's innermost independent variable.");
			return;
		}
	}
	if (sweep_dim(loadZ)==2)
	{
		if (sweep_size(charData[0,0,::]) != sweep_size(loadZ[0,::]))
		{
			print_function_error( "Data_from_1tone_swp", "The loadZ parameter should be a single number, or its innermost independent variable should be the same as the charData parameter's innermost independent variable.");
			return;
		}
	}
	if (sweep_dim(loadZ)==1)
	{
		if (sweep_size(charData[0,0,::]) != sweep_size(loadZ))
		{
			print_function_error( "Data_from_1tone_swp", "The loadZ parameter should be a single number, or its innermost independent variable should be the same as the charData parameter's innermost independent variable.");
			return;
		}
	}
	result = Data_from_1tone_swp_3d(algorithmChkd, allowextrapChkd, charData, inputSig, inputSigPowers, sourceZ, loadZ);	 
	break;
    default: print_function_error( "Data_from_1tone_swp", " does not support data with dimensions greater than three.");
	return;
	break;
    }

    return result;
} // fun - Data_from_1tone_swp

// fputs(stderr, " Defining function Data_from_1tone_swp_3d");
defun Data_from_1tone_swp_3d(algorithm, allowextrap, charData, inputSig, inputSigPowers, sourceZ, loadZ)
{
	decl debugFlag=0;
    decl numPts_i=sweep_size(charData[::,0,0]);
	decl last_index_inputSigPowers=sweep_size(inputSigPowers)-1;
	decl charPower=indep(charData[0,0,::]);
	decl sourceZparam;
    decl loadZparam;
	decl scaleFactorsTemp;
    decl i;
	decl inputSigPowersReduced=inputSigPowers;
	if (!allowextrap)   	// If extrapolation is not allowed, the length of the result array will likely be shorter.
	{
		scaleFactorsTemp = calculate_scalefactors_1d_r1( allowextrap, charPower, inputSig, inputSigPowers, 50, debugFlag);  // This is just used to get the length of the result array.
		last_index_inputSigPowers=sweep_size(scaleFactorsTemp)-1;
	}
	if (last_index_inputSigPowers<1)
	{
		inputSigPowersReduced=min(inputSigPowers);
	} else
	{
		inputSigPowersReduced=inputSigPowers[0::last_index_inputSigPowers];
	}
    decl Data_vs_Inpower_array=vs(charData[::,::,0::last_index_inputSigPowers],inputSigPowersReduced);
	decl Data_array=charData[::,::,0];
    if ((sweep_dim(inputSigPowers)==0) || (last_index_inputSigPowers<1))  //  This is for the case where inputSigPowers is a single value.
	{
	    for (i=0; i<numPts_i; i++)
		{
			sourceZparam=if (sweep_dim(sourceZ)==3) then sourceZ[i,::,0] else if (sweep_dim(sourceZ)==2) then sourceZ[i,0] else if (sweep_dim(sourceZ)==1) then sourceZ[i] else sourceZ endif; // this handles the case where sourceZ is the swept parameter
			loadZparam=if (sweep_dim(loadZ)==3) then loadZ[i,::,0] else if (sweep_dim(loadZ)==2) then loadZ[i,0] else if (sweep_dim(loadZ)==1) then loadZ[i] else loadZ endif;         // this handles the case where loadZ is the swept parameter
			Data_array[i,::]=Data_from_1tone_swp_2d(algorithm, allowextrap, charData[i,::,::], inputSig, [inputSigPowersReduced::inputSigPowersReduced], sourceZparam, loadZparam);
		}
		return Data_array;		
	} else
	{
		for (i=0; i<numPts_i; i++)
		{
			sourceZparam=if (sweep_dim(sourceZ)==3) then sourceZ[i,::,0] else if (sweep_dim(sourceZ)==2) then sourceZ[i,0] else if (sweep_dim(sourceZ)==1) then sourceZ[i] else sourceZ endif; // this handles the case where sourceZ is the swept parameter
			loadZparam=if (sweep_dim(loadZ)==3) then loadZ[i,::,0] else if (sweep_dim(loadZ)==2) then loadZ[i,0] else if (sweep_dim(loadZ)==1) then loadZ[i] else loadZ endif;         // this handles the case where loadZ is the swept parameter
			Data_vs_Inpower_array[i,::,::]=Data_from_1tone_swp_2d(algorithm, allowextrap, charData[i,::,::], inputSig, inputSigPowersReduced, sourceZparam, loadZparam);
		}
		return Data_vs_Inpower_array;
	}
} //fun - Data_from_1tone_swp_3d

// fputs(stderr, " Defining function Data_from_1tone_swp_2d");
defun Data_from_1tone_swp_2d(algorithm, allowextrap, charData, inputSig, inputSigPowers, sourceZ, loadZ)
{
	decl debugFlag=0;
    decl numPts_i=sweep_size(charData[::,0]);
	decl last_index_inputSigPowers=sweep_size(inputSigPowers)-1;
	decl charPower=indep(charData[0,::]);
	decl sourceZparam;
    decl loadZparam;
	decl scaleFactorsTemp;
	decl i;
	decl inputSigPowersReduced=inputSigPowers;

	if (!allowextrap)   	// If extrapolation is not allowed, the length of the result array will likely be shorter.
	{
		scaleFactorsTemp = calculate_scalefactors_1d_r1( allowextrap, charPower, inputSig, inputSigPowers, 50, debugFlag);  // This is just used to get the length of the result array.
		last_index_inputSigPowers=sweep_size(scaleFactorsTemp)-1;
	}
	if (last_index_inputSigPowers<1)
	{
		inputSigPowersReduced=min(inputSigPowers);
	} else
	{
		inputSigPowersReduced=inputSigPowers[0::last_index_inputSigPowers];
	}
    decl Data_vs_Inpower_array=vs(charData[::,0::last_index_inputSigPowers],inputSigPowersReduced);
	decl Data_array=charData[::,0];
    if ((sweep_dim(inputSigPowers)==0) || (last_index_inputSigPowers<1))   //  This is for the case where inputSigPowers is a single value.
	{
		for (i=0; i<numPts_i; i++)
		{
			sourceZparam=if (sweep_dim(sourceZ)==2) then sourceZ[i,0] else if (sweep_dim(sourceZ)==1) then sourceZ[i] else sourceZ endif; // this handles the case where sourceZ is the swept parameter
			loadZparam=if (sweep_dim(loadZ)==2) then loadZ[i,0] else if (sweep_dim(loadZ)==1) then loadZ[i] else loadZ endif;         // this handles the case where loadZ is the swept parameter
			Data_array[i]=Data_from_1tone_swp_1d(algorithm, allowextrap, charData[i,::], inputSig, [inputSigPowersReduced::inputSigPowersReduced], sourceZparam, loadZparam);
		}		
		return Data_array;		
	} else
	{
		for (i=0; i<numPts_i; i++)
		{
			sourceZparam=if (sweep_dim(sourceZ)==2) then sourceZ[i,0] else if (sweep_dim(sourceZ)==1) then sourceZ[i] else sourceZ endif; // this handles the case where sourceZ is the swept parameter
			loadZparam=if (sweep_dim(loadZ)==2) then loadZ[i,0] else if (sweep_dim(loadZ)==1) then loadZ[i] else loadZ endif;         // this handles the case where loadZ is the swept parameter
			Data_vs_Inpower_array[i,::]=Data_from_1tone_swp_1d(algorithm, allowextrap, charData[i,::], inputSig, inputSigPowersReduced, sourceZparam, loadZparam);
		}
		return Data_vs_Inpower_array;
	}
} //fun - Data_from_1tone_swp_2d

// fputs(stderr," Defining function Data_from_1tone_swp_1d");
defun Data_from_1tone_swp_1d(algorithm, allowextrap, charData, inputSig, inputSigPowers, sourceZ, loadZ)
{
/* *********************************************************************************
   Function: Data_from_1tone_swp_1d
   --------------------------------
   Returns:	The mean value of a response

   Arguments: 
   1) algorithm	-flag for approximating transfer function.  Set to
   "CF" to use curve fit, "LI" to use Linear Interpolation
   2) allowextrap	-flag for allowing extrapolation.  
   If allowextrap is set to 1, the scalefactors used to create the pseudo-power-swept 
   modulated data will be created from the inputSigPowers (units of dBm) passed into the function.
   If set to 0, extrapolation is not allowed and scale factors that
   cause the modulated signal power to exceed the power of the HB
   sweep are omitted.
   3) charData	-some response from the HB sweep
   4) inputSig	-input modulated signal
   5) inputSigPowers -desired modulated signal input power levels
   6) sourceZ	-Source impedance
   7) loadZ	-Load impledance
   --------------------------------
   History:
   12/2013		Created by AEH
   ********************************************************************************* */
	decl debugFlag=0;
    if(debugFlag)
    {
		fprintf(stderr,"DEBUG FLAG ON.\n  IN FUNCTION Data_from_1tone_swp_1d\n");
    }

    decl RFpower=indep(charData);
    decl time=indep(inputSig);
	decl sourceZparam = if (sweep_dim(sourceZ)==1) then sourceZ[0] else sourceZ endif;
    decl loadZparam = if (sweep_dim(loadZ)==1) then loadZ[0] else loadZ endif;	
    decl scaleFactors=calculate_scalefactors_1d_r1( allowextrap, RFpower, inputSig, inputSigPowers, sourceZparam, debugFlag);  		// Calling 1d version of this function is sufficient.
	decl resultsArray=approxData_1d(algorithm, allowextrap, charData, sourceZparam, inputSig, scaleFactors, debugFlag);       		// Calling 1d version of this function is sufficient.
	decl resultsArrayTypeChecked;
	if(type(charData)=="Real")							// If charData is real, we want to return real data.  
	{
		resultsArrayTypeChecked=real(resultsArray[0]);
	}
	else
	{
		resultsArrayTypeChecked=resultsArray[0];
	}
	
    decl Data=mean(resultsArrayTypeChecked);
	decl scaledInputSig=resultsArray[1];
	decl inSigPower=mean(0.5*real(scaledInputSig*conj(scaledInputSig/(conj(sourceZparam)))));
    decl inSigPower_dBm=10*log(inSigPower)+30;	

    decl Data_vs_Inpower=vs(Data,inSigPower_dBm);

    if(debugFlag)
    {
		fputs(stderr,"  BOTTOM OF Data_from_1tone_swp_1d FUNCTION");
    }
	return Data_vs_Inpower;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//
// ***** PLEASE DO NOT DELETE THE FOLLOWING!!!!! *****
//
// This obviously isn't a C++ file, but the C++ editing mode works.
//
// Local Variables:
// mode: c++
// header-comment-character: ?*
// header-prefix: "/* -*-C++-*-"
// header-suffix: "*/"
// End:
//
