// Copyright Keysight Technologies 2002 - 2014  

defun comput_INL(output_code,input,LSB)
{
// This function calculates INL of an A to D converter in terms of LSB.

decl max_input=max(input);
decl n_max=find_index(input,max_input);
decl Xo=input[0];
decl Xf=0;
decl error=0;
decl new_error=0;
decl n;

for (n=1; n<(n_max); n++)
{
if (output_code[n]>(0.5+output_code[n-1]))
	{ 
		Xf=input[n-1];
		error=1-abs((Xf-Xo)/LSB);
		
		new_error=new_error+abs(error);
		Xo=input[n-1];
	}
}

return new_error;
}




//****************************************************************************
// Copyright Keysight Technologies 2002 - 2014  
//
// This function takes time domain data, and using eye patterns and cumulative
// distribution functions, calculates the eye amplitude of the waveform. The
// eye amplitude definition comes from the 86100 DCA help files. The definition
// is: eye amplitude = 1 level histogram mean - 0 level histogram mean
// within a defined measurement window, typically 20% of the bit period.
//
/*BEGIN_DOC
FUN_NAME: eye_amplitude() 
FUN_DESCRIPTION: Returns eye amplitude
RETURNED_VALUE: Real
CATEGORY: Envelope, Signal Processing
SYNTAX: y = eye_amplitude(Vout_time, Delay, BitRate, SamplePoint, WindowPct) 
EXAMPLE:
Eye_amp = eye_amplitude(vout,12 ps,10 GHz, m1, 0.2) 
ARGUMENT
  ARG_NAME: Vout_time
  ARG_DESCRIPTION: time domain voltage waveform
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: Delay
  ARG_DESCRIPTION: used to remove initial transient in the eye diagram and is expressed in time units
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: BitRate
  ARG_DESCRIPTION: bit rate of the channel and is expressed in frequency units
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: SamplePoint
  ARG_DESCRIPTION: marker name placed on the eye diagram measurement. The independent value of this marker is used to determine the symbol offset.
  ARG_DEFAULT: None
  ARG_RANGE: None
  ARG_TYPE: string
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: WindowPct
  ARG_DESCRIPTION: used to determine level '1' and level '0' of the time domain waveform and its typical value is 0.2.
  ARG_DEFAULT: None
  ARG_RANGE: [0:1]
  ARG_TYPE: Real
  ARG_REQUIRED: YES
DEFINED_IN: $HPEESOF_DIR/expressions/ael/DesignGuide_fun.ael
SEE ALSO: cross_hist(), eye_closure(), eye_fall_time(), eye_height(), eye_rise_time() 
NOTES: The eye_amplitude() function essentially takes the vertical histogram of the eye voltages and subtracts the "0" level mean from "1" level mean within a given measurement window. 
EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/

//****************************************************************************
defun eye_amplitude(Import_data,delay,symrate,samplepoint,windowpct)
{
       decl data_level=min(Import_data);
       decl data=Import_data-data_level;
       decl dataIndep = indep(data);
       decl startDataTime = dataIndep[0];
       decl symPeriod = 1 / symrate;
       decl startTimeIndex = find_index(dataIndep, startDataTime + delay);
       decl dataNew = data[startTimeIndex::sweep_size(data)-1];
       decl eyeData = eye(dataNew, symrate, 2);
       decl symOffset = indep(samplepoint) - symPeriod + delay;
       decl windowTime = windowpct * symPeriod;
       decl modulusTime = (((indep(dataNew) - symOffset) / symPeriod) - int(0.5 + (indep(dataNew) - symOffset) / symPeriod)) * symPeriod;
       decl samplePulse = if (mag(modulusTime) < (windowTime/2)) then 1 else 0;
       decl choppedData = samplePulse * dataNew;
       decl choppedCDF = cdf(choppedData, 100);
       decl choppedCDFZero = choppedCDF[0::49];
       decl choppedCDFOne = choppedCDF[51::100];
       decl zeroMax = max(choppedCDFZero);
       decl zeroMin = min(choppedCDFZero);
       decl zeroMean = (zeroMax + zeroMin) / 2;
       decl oneMax = max(choppedCDFOne);
       decl oneMin = min(choppedCDFOne);
       decl oneMean = (oneMax + oneMin) / 2;
       decl i;
       decl indepCDFZeroVolt = indep(choppedCDFZero);
       decl zeroMeanVolt = indepCDFZeroVolt[0];
       decl indepCDFOneVolt = indep(choppedCDFOne);
       decl oneMeanVolt = indepCDFOneVolt[0];
       for (i=1; i<=49; i++)
       {
            if ((zeroMean >= choppedCDFZero[i-1]) && (zeroMean < choppedCDFZero[i])) 
	         zeroMeanVolt = interp_new(choppedCDFZero[i-1],choppedCDFZero[i],indepCDFZeroVolt[i-1],indepCDFZeroVolt[i],zeroMean);
       }
       for (i=1; i<=49; i++)
       {
            if ((oneMean >= choppedCDFOne[i-1]) && (oneMean < choppedCDFOne[i])) 
                 oneMeanVolt = interp_new(choppedCDFOne[i-1],choppedCDFOne[i],indepCDFOneVolt[i-1],indepCDFOneVolt[i],oneMean);
       }

       decl result = oneMeanVolt - zeroMeanVolt;
       return result;

} //fun - eye_amplitude

defun interp_new(x1,x2,y1,y2,x)
{
  decl m = (y2 - y1)/(x2 - x1);
  decl b = y1 - (m * x1);
  decl answer = (m * x) + b;
  return answer;
}

//****************************************************************************
// Copyright Keysight Technologies 2002 - 2014  
//
// This function takes time domain data, and using eye patterns and cumulative
// distribution functions, calculates the eye closure of the waveform. The
// eye height definition comes from the 86100 DCA help files. The definition
// is: eye height = (1 level mean - 3sigma ) - (0 level mean + 3sigma)
// within a defined measurement window, typically 20% of the bit period.
/*BEGIN_DOC
FUN_NAME: eye_height() 
FUN_DESCRIPTION: Returns eye height
RETURNED_VALUE: Real
CATEGORY: Envelope, Signal Processing
SYNTAX: y = eye_height(Vout_time, Delay, BitRate, SamplePoint, WindowPct) 
EXAMPLE:
Eye_Ht = eye_height(vout,12 ps,10 GHz, m1, 0.2)
ARGUMENT
  ARG_NAME: Vout_time
  ARG_DESCRIPTION: time domain voltage waveform
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: Delay
  ARG_DESCRIPTION: used to remove initial transient in the eye diagram and is expressed in time units
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: BitRate
  ARG_DESCRIPTION: bit rate of the channel and is expressed in frequency units
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: SamplePoint
  ARG_DESCRIPTION: marker name placed on the eye diagram measurement. The independent value of this marker is used to determine the symbol offset.
  ARG_DEFAULT: None
  ARG_RANGE: None
  ARG_TYPE: string
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: WindowPct
  ARG_DESCRIPTION: used to determine level '1' and level '0' of the time domain waveform and its typical value is 0.2.
  ARG_DEFAULT: None
  ARG_RANGE: [0:1]
  ARG_TYPE: Real
  ARG_REQUIRED: YES
DEFINED_IN: $HPEESOF_DIR/expressions/ael/DesignGuide_fun.ael
SEE ALSO: cross_hist(), eye_amplitude(), eye_closure(), eye_fall_time(), eye_rise_time()
NOTES:
The eye_height() function essentially takes the vertical histogram of the eye voltages and computes inner bounds of the eye opening. 
EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS
END_DOC*/
//****************************************************************************
defun eye_height(Import_data,delay,symrate,samplepoint,windowpct)
{
 
      decl data_level=min(Import_data);
      decl data=Import_data-data_level;
      decl dataIndep = indep(data);
      decl startDataTime = dataIndep[0];
      decl symPeriod = 1 / symrate;
      decl startTimeIndex = find_index(dataIndep, startDataTime + delay);
      decl dataNew = data[startTimeIndex::sweep_size(data)-1];
      decl eyeData = eye(dataNew, symrate, 2);
      decl symOffset = indep(samplepoint) - symPeriod + delay;
      decl windowTime = windowpct * symPeriod;
      decl modulusTime = (((indep(dataNew) - symOffset) / symPeriod) - int(0.5 + (indep(dataNew) - symOffset) / symPeriod)) * symPeriod;
      decl samplePulse = if (mag(modulusTime) < (windowTime/2)) then 1 else 0;
      decl choppedData = samplePulse * dataNew;
      decl choppedCDF = cdf(choppedData, 100);
      decl choppedCDFZero = choppedCDF[0::49];
      decl choppedCDFOne = choppedCDF[51::100];
      decl zeroMax = max(choppedCDFZero);
      decl zeroMin = min(choppedCDFZero);
      decl zeroMean = (zeroMax + zeroMin) / 2;
      decl oneMax = max(choppedCDFOne);
      decl oneMin = min(choppedCDFOne);
      decl oneMean = (oneMax + oneMin) / 2;
      decl i;
      decl indepCDFZeroVolt = indep(choppedCDFZero);
      decl indepCDFOneVolt = indep(choppedCDFOne);
      decl oneMinVolt = indepCDFOneVolt[0];
      for (i=1; i<=49; i++)
      {
           if (oneMin == choppedCDFOne[i]) 
		oneMinVolt = indepCDFOneVolt[i];
      }
      decl zeroMaxVolt = indepCDFZeroVolt[0];
      for (i=1; i<=49; i++)
      {
           if (zeroMax == choppedCDFZero[i])
           {
                zeroMaxVolt = indepCDFZeroVolt[i];
                break;
           }
      }

     decl result = oneMinVolt - zeroMaxVolt;
     return result;

}     

//****************************************************************************
// Copyright Keysight Technologies 2002 - 2014  

// This function takes time domain data, and using eye patterns and cumulative
// distribution functions, calculates the eye closure of the waveform. The
// eye amplitude definition comes from the 86100 DCA help files. The definition
// is: eye closure = eye amplitude / eye height
// within a defined measurement window, typically 20% of the bit period.
// See other definitions of eye height and eye amplitude.
// 
// NOTE: The value given for eye closure is a ratio so that the user can
// multiply by 100 for percentage or apply dB(eye_closure).
//
//
/*BEGIN_DOC
FUN_NAME: eye_closure() 
FUN_DESCRIPTION: Returns eye closure
RETURNED_VALUE: Real
CATEGORY: Envelope, Signal Processing
SYNTAX: y = eye_closure(Vout_time, Delay, BitRate, SamplePoint, WindowPct) 
EXAMPLE:
Eye_Close = eye_closure(vout,12 ps,10 GHz, m1, 0.2)
ARGUMENT
  ARG_NAME: Vout_time
  ARG_DESCRIPTION: time domain voltage waveform
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: Delay
  ARG_DESCRIPTION: used to remove initial transient in the eye diagram and is expressed in time units
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: BitRate
  ARG_DESCRIPTION: bit rate of the channel and is expressed in frequency units
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: SamplePoint
  ARG_DESCRIPTION: marker name placed on the eye diagram measurement. The independent value of this marker is used to determine the symbol offset.
  ARG_DEFAULT: None
  ARG_RANGE: None
  ARG_TYPE: string
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: WindowPct
  ARG_DESCRIPTION: used to determine level '1' and level '0' of the time domain waveform and its typical value is 0.2.
  ARG_DEFAULT: None
  ARG_RANGE: [0:1]
  ARG_TYPE: Real
  ARG_REQUIRED: YES
DEFINED_IN: $HPEESOF_DIR/expressions/ael/DesignGuide_fun.ael
SEE ALSO: cross_hist(), eye_amplitude(), eye_fall_time(), eye_height(), eye_rise_time() 
NOTES:
Computes the ratio of eye height to eye amplitude to provide eye closure. 
EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS
END_DOC*/
//****************************************************************************

defun eye_closure(Import_data,delay,symrate,samplepoint,windowpct)
{
      decl data_level=min(Import_data);
      decl data=Import_data-data_level;
      decl dataIndep = indep(data);
      decl startDataTime = dataIndep[0];
      decl symPeriod = 1 / symrate;
      decl startTimeIndex = find_index(dataIndep, startDataTime + delay);
      decl dataNew = data[startTimeIndex::sweep_size(data)-1];
      decl eyeData = eye(dataNew, symrate, 2);
      decl symOffset = indep(samplepoint) - symPeriod + delay;
      decl windowTime = windowpct * symPeriod;
      decl modulusTime = (((indep(dataNew) - symOffset) / symPeriod) - int(0.5 + (indep(dataNew) - symOffset) / symPeriod)) * symPeriod;
      decl samplePulse = if (mag(modulusTime) < (windowTime/2)) then 1 else 0;
      decl choppedData = samplePulse * dataNew;
      decl choppedCDF = cdf(choppedData, 100);
      decl choppedCDFZero = choppedCDF[0::49];
      decl choppedCDFOne = choppedCDF[51::100];
      decl zeroMax = max(choppedCDFZero);
      decl zeroMin = min(choppedCDFZero);
      decl zeroMean = (zeroMax + zeroMin) / 2;
      decl oneMax = max(choppedCDFOne);
      decl oneMin = min(choppedCDFOne);
      decl oneMean = (oneMax + oneMin) / 2;
      decl i;
      decl indepCDFZeroVolt = indep(choppedCDFZero);
      decl zeroMeanVolt = indepCDFZeroVolt[0];
      decl indepCDFOneVolt = indep(choppedCDFOne);
      decl oneMeanVolt = indepCDFOneVolt[0];
      for (i=1; i<=49; i++)
      {
             if ((zeroMean >= choppedCDFZero[i-1]) && (zeroMean < choppedCDFZero[i]))
                     zeroMeanVolt = interp_new(choppedCDFZero[i-1],choppedCDFZero[i],indepCDFZeroVolt[i-1],indepCDFZeroVolt[i],zeroMean);
      }
      for (i=1; i<=49; i++)
      {
             if ((oneMean >= choppedCDFOne[i-1]) && (oneMean < choppedCDFOne[i])) 
                     oneMeanVolt = interp_new(choppedCDFOne[i-1],choppedCDFOne[i],indepCDFOneVolt[i-1],indepCDFOneVolt[i],oneMean);
      }
      decl oneMinVolt = indepCDFOneVolt[0];
      for (i=1; i<=49; i++)
      {
             if (oneMin == choppedCDFOne[i]) oneMinVolt = indepCDFOneVolt[i];
      }
      decl zeroMaxVolt = indepCDFZeroVolt[0];
      for (i=1; i<=49; i++)
      {
             if (zeroMax == choppedCDFZero[i])
             {
                      zeroMaxVolt = indepCDFZeroVolt[i];
                      break;
             }
      }

      decl result = (oneMinVolt - zeroMaxVolt) / (oneMeanVolt - zeroMeanVolt);
      return result;

} //fun - eye_closure

defun interp_new(x1,x2,y1,y2,x)
{
      decl m = (y2 - y1)/(x2 - x1);
      decl b = y1 - (m * x1);
      decl answer = (m * x) + b;
      return answer;
}

//****************************************************************************
// Copyright Keysight Technologies 2002 - 2014  
//
// This function takes time domain data and calculates 20% to 80% rise time of the
// waveform. Function can be modified easily to calculate 10% to 90% rise time. The
// eye rise time calculates 0-level mean and 1-level mean and computes 20 to 80%.
//
/*BEGIN_DOC
FUN_NAME: eye_rise_time() 
FUN_DESCRIPTION: Returns eye rise time
RETURNED_VALUE: Real
CATEGORY: Envelope, Signal Processing
SYNTAX: y = eye_rise_time(Vout_time,Delay,BitRate,SamplePoint,WindowPct) 
EXAMPLE:
Eye_Rise = eye_rise_time(vout,12 ps,10 GHz, m1, 0.2) 
ARGUMENT
  ARG_NAME: Vout_time
  ARG_DESCRIPTION: time domain voltage waveform
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: Delay
  ARG_DESCRIPTION: used to remove initial transient in the eye diagram and is expressed in time units
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: BitRate
  ARG_DESCRIPTION: bit rate of the channel and is expressed in frequency units
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: SamplePoint
  ARG_DESCRIPTION: marker name placed on the eye diagram measurement. The independent value of this marker is used to determine the symbol offset.
  ARG_DEFAULT: None
  ARG_RANGE: None
  ARG_TYPE: string
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: WindowPct
  ARG_DESCRIPTION: used to determine level '1' and level '0' of the time domain waveform and its typical value is 0.2.
  ARG_DEFAULT: None
  ARG_RANGE: [0:1]
  ARG_TYPE: Real
  ARG_REQUIRED: YES
DEFINED_IN: $HPEESOF_DIR/expressions/ael/DesignGuide_fun.ael
SEE ALSO: cross_hist(), eye_amplitude(), eye_closure(), eye_fall_time(), eye_height()
NOTES:
Computes 20% - 80% rise time of a time domain waveform. 
EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS
END_DOC*/
//****************************************************************************
defun eye_rise_time(Import_data,delay,symrate,samplepoint,windowpct)
{
      decl data_level=min(Import_data);
      decl data=Import_data-data_level;
      decl dataIndep = indep(data);
      decl startDataTime = dataIndep[0];
      decl symPeriod = 1 / symrate;
      decl startTimeIndex = find_index(dataIndep, startDataTime + delay);
      decl dataNew = data[startTimeIndex::sweep_size(data)-1];
      decl eyeData = eye(dataNew, symrate, 2);
      decl symOffset = indep(samplepoint) - symPeriod + delay;
      decl windowTime = windowpct * symPeriod;
      decl modulusTime = (((indep(dataNew) - symOffset) / symPeriod) - int(0.5 + (indep(dataNew) - symOffset) / symPeriod)) * symPeriod;
      decl samplePulse = if (mag(modulusTime) < (windowTime/2)) then 1 else 0;
      decl choppedData = samplePulse * dataNew;
      decl choppedCDF = cdf(choppedData, 100);
      decl choppedCDFZero = choppedCDF[0::49];
      decl choppedCDFOne = choppedCDF[51::100];
      decl zeroMax = max(choppedCDFZero);
      decl zeroMin = min(choppedCDFZero);
      decl zeroMean = (zeroMax + zeroMin) / 2;
      decl oneMax = max(choppedCDFOne);
      decl oneMin = min(choppedCDFOne);
      decl oneMean = (oneMax + oneMin) / 2;
      decl i;
      decl indepCDFZeroVolt = indep(choppedCDFZero);
      decl zeroMeanVolt = indepCDFZeroVolt[0];
      decl indepCDFOneVolt = indep(choppedCDFOne);
      decl oneMeanVolt = indepCDFOneVolt[0];
      for (i=1; i<=49; i++)
      {
             if ((zeroMean >= choppedCDFZero[i-1]) && (zeroMean < choppedCDFZero[i])) 
             zeroMeanVolt = interp_new(choppedCDFZero[i-1],choppedCDFZero[i],indepCDFZeroVolt[i-1],indepCDFZeroVolt[i],zeroMean);
      }
      for (i=1; i<=49; i++)
      {
             if ((oneMean >= choppedCDFOne[i-1]) && (oneMean < choppedCDFOne[i])) 
             oneMeanVolt = interp_new(choppedCDFOne[i-1],choppedCDFOne[i],indepCDFOneVolt[i-1],indepCDFOneVolt[i],oneMean);
      }
      decl average_pt=(zeroMeanVolt+oneMeanVolt)/2;
      decl i,z,cross_mean,cross_high,cross_low;
      decl j1=0;
      decl Rise_time=0;
      decl mean_high=0.8*(oneMeanVolt-average_pt);
      decl level_1=average_pt+mean_high;
      decl mean_low=0.2*(average_pt-zeroMeanVolt);
      decl level_0=zeroMeanVolt+mean_low;
      decl Point1,Point_low,Point_high;  
      cross_mean=indep(cross(data-average_pt,1));   
      cross_low=indep(cross(data-level_1,1)); 
      cross_high=indep(cross(data-level_0,1));
      decl sweepSize= sweep_size(cross_mean)-1;
      for(i=1;i<=sweepSize;i++) 
      {  
            Point1=(cross_mean[i]);
           z=find_index(cross_low,Point1);
          Point_low=(cross_low[z]);
            z=find_index(cross_high,Point1);
            Point_high=cross_high[z];
            if((Point_low>Point1) && (Point_high<Point1)) 
            {
                  Rise_time=(Point_low-Point_high)+Rise_time;
                  j1=j1+1;
            } 
       } 
      if (j1!=0) 
            Rise_time=Rise_time/j1; 
      return Rise_time; 

}


//****************************************************************************
// Copyright Keysight Technologies 2002 - 2014  
// This function takes time domain data and calculates 80% to 20% fall time of the
// waveform. Function can be modified easily to calculate 90% to 10% fall time. The
// eye fall time calculates 1-level mean and 0-level mean and computes 80% to 20%.
/*BEGIN_DOC
FUN_NAME: eye_fall_time() 
FUN_DESCRIPTION: Returns eye fall time
RETURNED_VALUE: Real
CATEGORY: Envelope, Signal Processing
SYNTAX: y = eye_fall_time(Vout_time,Delay,BitRate,SamplePoint,WindowPct) 
EXAMPLE:
Eye_Fall = eye_fall_time(vout,12 ps,10 GHz, m1, 0.2) 
ARGUMENT
  ARG_NAME: Vout_time
  ARG_DESCRIPTION: time domain voltage waveform
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: Delay
  ARG_DESCRIPTION: used to remove initial transient in the eye diagram and is expressed in time units
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: BitRate
  ARG_DESCRIPTION: bit rate of the channel and is expressed in frequency units
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: SamplePoint
  ARG_DESCRIPTION: marker name placed on the eye diagram measurement. The independent value of this marker is used to determine the symbol offset.
  ARG_DEFAULT: None
  ARG_RANGE: None
  ARG_TYPE: string
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: WindowPct
  ARG_DESCRIPTION: used to determine level '1' and level '0' of the time domain waveform and its typical value is 0.2.
  ARG_DEFAULT: None
  ARG_RANGE: [0:1]
  ARG_TYPE: Real
  ARG_REQUIRED: YES
DEFINED_IN: $HPEESOF_DIR/expressions/ael/DesignGuide_fun.ael
SEE ALSO: cross_hist(), eye_amplitude(), eye_closure(), eye_height(), eye_rise_time() 
NOTES:
Computes 20% - 80% fall time of a time domain waveform.
EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS
END_DOC*/
//****************************************************************************

defun eye_fall_time(Import_data,delay,symrate,samplepoint,windowpct)
{
       decl data_level=min(Import_data);
       decl data=Import_data-data_level;
       decl dataIndep = indep(data);
       decl startDataTime = dataIndep[0];
       decl symPeriod = 1 / symrate;
       decl startTimeIndex = find_index(dataIndep, startDataTime + delay);
       decl dataNew = data[startTimeIndex::sweep_size(data)-1];
       decl eyeData = eye(dataNew, symrate, 2);
       decl symOffset = indep(samplepoint) - symPeriod + delay;
       decl windowTime = windowpct * symPeriod;
       decl modulusTime = (((indep(dataNew) - symOffset) / symPeriod) - int(0.5 + (indep(dataNew) - symOffset) / symPeriod)) * symPeriod;
       decl samplePulse = if (mag(modulusTime) < (windowTime/2)) then 1 else 0;
       decl choppedData = samplePulse * dataNew;
       decl choppedCDF = cdf(choppedData, 100);
       decl choppedCDFZero = choppedCDF[0::49];
       decl choppedCDFOne = choppedCDF[51::100];
       decl zeroMax = max(choppedCDFZero);
       decl zeroMin = min(choppedCDFZero);
       decl zeroMean = (zeroMax + zeroMin) / 2;
       decl oneMax = max(choppedCDFOne);
       decl oneMin = min(choppedCDFOne);
       decl oneMean = (oneMax + oneMin) / 2;
       decl i;
       decl indepCDFZeroVolt = indep(choppedCDFZero);
       decl zeroMeanVolt = indepCDFZeroVolt[0];
       decl indepCDFOneVolt = indep(choppedCDFOne);
       decl oneMeanVolt = indepCDFOneVolt[0];
       for (i=1; i<=49; i++)
       {
              if ((zeroMean >= choppedCDFZero[i-1]) && (zeroMean < choppedCDFZero[i])) 
                       zeroMeanVolt = interp_new(choppedCDFZero[i-1],choppedCDFZero[i],indepCDFZeroVolt[i-1],indepCDFZeroVolt[i],zeroMean);
       }
       for (i=1; i<=49; i++)
       {
              if ((oneMean >= choppedCDFOne[i-1]) && (oneMean < choppedCDFOne[i])) 
                        oneMeanVolt = interp_new(choppedCDFOne[i-1],choppedCDFOne[i],indepCDFOneVolt[i-1],indepCDFOneVolt[i],oneMean);
       }
       decl average_pt=(zeroMeanVolt+oneMeanVolt)/2;
       decl i,z,cross_mean,cross_high,cross_low;
       decl j1=0;
       decl Fall_time=0;
       decl mean_high=0.8*(oneMeanVolt-average_pt);
       decl level_1=average_pt+mean_high;
       decl mean_low=0.2*(average_pt-zeroMeanVolt);
       decl level_0=zeroMeanVolt+mean_low;
       decl Point1,Point_low,Point_high;  
       cross_mean=indep(cross(data-average_pt,-1));   
       cross_low=indep(cross(data-level_1,-1)); 
       cross_high=indep(cross(data-level_0,-1));
       decl sweepSize= sweep_size(cross_mean)-1;
       for(i=1;i<=sweepSize;i++) 
       {
             Point1=(cross_mean[i]);
             z=find_index(cross_low,Point1);
             Point_low=(cross_low[z]);
             z=find_index(cross_high,Point1);
             Point_high=cross_high[z];
             if((Point_low<Point1) && (Point_high>Point1)) 
             {
                 Fall_time=(Point_high-Point_low)+Fall_time;
                 j1=j1+1;
             } 
        }
        if (j1!=0) 
             Fall_time=Fall_time/j1; 
        return Fall_time; 

}

//////////////////////////////////////////////////////////////////////
// A couple of helper utilities for the eye_density() and
// eye_binning() routines.
//////////////////////////////////////////////////////////////////////
defun eye_get_max_value(data)
{
	decl i = sweep_dim(data);
	while(i>0)
	{
		data = max(data);
		i--;
	}
	return data;
}

defun eye_get_min_value(data)
{
	decl i = sweep_dim(data);
	while(i>0)
	{
		data = min(data);
		i--;
	}
	return data;
}


//****************************************************************************
// Copyright Keysight Technologies 2002 - 2014  
/*BEGIN_DOC
FUN_NAME: eye_binning() 
FUN_DESCRIPTION: Returns density binning data
RETURNED_VALUE: Real
CATEGORY: Envelope, Signal Processing
SYNTAX: y = eye_binning(eye_data, Indep_bins, Dep_bins)
EXAMPLE:
Eye_data=FrontPanel_eye(vout,10GHz)
Eye_bins = eye_binning(Eye_data, 100, 70);
ARGUMENT
  ARG_NAME: eye_data
  ARG_DESCRIPTION: eye diagram data
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: Indep_bins
  ARG_DESCRIPTION: number of independent bins
  ARG_DEFAULT: None
  ARG_RANGE: [1:inf)
  ARG_TYPE: Integer
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: Dep_bins
  ARG_DESCRIPTION: number of dependent bins
  ARG_DEFAULT: None
  ARG_RANGE: [1:inf)
  ARG_TYPE: Integer
  ARG_REQUIRED: YES
DEFINED_IN: $HPEESOF_DIR/expressions/ael/DesignGuide_fun.ael
SEE ALSO: eye()
NOTES:
EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: January 31, 2005
VERSION_CREATED: ADS
END_DOC*/
defun eye_binning(eye_data, hori_bins, vert_bins)
{
	// Calculate the minimum time of the eye display
	decl min_time = eye_get_min_value(indep(eye_data));

	// Calculate the maximum time on the eye display
	decl max_time = eye_get_max_value(indep(eye_data));

	// get the minimum amplitude
	decl min_amp = eye_get_min_value(eye_data);
	
	// get the maximum amplitude
	decl max_amp = eye_get_max_value(eye_data);

	decl col_size=(max_time-min_time)/hori_bins;

	// Interpolate the eye data to get the sampling points at the binning position.
	// This only does horizontal interpolation. The vertical interpolation is handled
	// in the binning function.
	decl new_data=interp(eye_data, min_time, max_time, col_size);
	
	// Call into C++ to do the binning...
	return eye_binning_internal(new_data, hori_bins, vert_bins, min_time, max_time, min_amp, max_amp);
}

//****************************************************************************
// Copyright Keysight Technologies 2002 - 2014  
/*BEGIN_DOC
FUN_NAME: eye_density() 
FUN_DESCRIPTION: Returns density trace.
RETURNED_VALUE: Real
CATEGORY: Envelope, Signal Processing
SYNTAX: y = eye_density(eye_data, Indep_bins, Dep_bins)
EXAMPLE:
Eye_data=FrontPanel_eye(vount,10GHz)
Eye_bins = eye_density(Eye_data, 100, 70);
ARGUMENT
  ARG_NAME: eye_data
  ARG_DESCRIPTION: eye diagram data
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: Indep_bins
  ARG_DESCRIPTION: number of independent bins
  ARG_DEFAULT: None
  ARG_RANGE: [1:inf)
  ARG_TYPE: Integer
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: Dep_bins
  ARG_DESCRIPTION: number of dependent bins
  ARG_DEFAULT: None
  ARG_RANGE: [1:inf)
  ARG_TYPE: Integer
  ARG_REQUIRED: YES
DEFINED_IN: $HPEESOF_DIR/expressions/ael/DesignGuide_fun.ael
SEE ALSO: eye()
NOTES:
EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: January 31, 2005
VERSION_CREATED: ADS
END_DOC*/
defun eye_density(eye_data, hori_bins, vert_bins)
{
	// Calculate the minimum time of the eye display
	decl min_time = eye_get_min_value(indep(eye_data));

	// Calculate the maximum time on the eye display
	decl max_time = eye_get_max_value(indep(eye_data));

	// get the minimum amplitude
	decl min_amp = eye_get_min_value(eye_data);
	
	// get the maximum amplitude
	decl max_amp = eye_get_max_value(eye_data);

	decl col_size=(max_time-min_time)/hori_bins;

	// Interpolate the eye data to get the sampling points at the binning position.
	// This only does horizontal interpolation. The vertical interpolation is handled
	// in the binning function.
	decl new_data=interp(eye_data, min_time, max_time, col_size);
	
	// Call into C++ to do the binning and generate the density trace...
	return eye_density_internal(new_data, hori_bins, vert_bins, min_time, max_time, min_amp, max_amp);
}


//****************************************************************************
// Copyright Keysight Technologies 2002 - 2014  
/*BEGIN_DOC
FUN_NAME: eye_mask_time_shift()
FUN_DESCRIPTION: Returns density trace shifted by a specific time value.
RETURNED_VALUE: Real
CATEGORY: Envelope, Signal Processing
SYNTAX: y = eye_mask_time_shift(density_data, offset)
EXAMPLE:
Eye_data=FrontPanel_eye(vount,10GHz)
Eye_bins = eye_density(Eye_data, 100, 70);
Eye_Shifted = eye_mask_time_shift(Eye_bins, 1ps);
ARGUMENT
  ARG_NAME: density_data
  ARG_DESCRIPTION: the density trace data returned from the eye_density() routine.
  ARG_DEFAULT: None
  ARG_RANGE: (0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: offset
  ARG_DESCRIPTION: the time value to slide the density trace by.
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Integer
  ARG_REQUIRED: YES
DEFINED_IN: $HPEESOF_DIR/expressions/ael/DesignGuide_fun.ael
SEE ALSO: eye_density()
NOTES:
EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: January 31, 2013
VERSION_CREATED: ADS
END_DOC*/
//****************************************************************************
defun eye_mask_time_shift(density, toffset)
{
	decl num_of_indep_vars = sweep_dim(density);

	if (num_of_indep_vars != 2)
    {
        print_function_error("eye_mask_time_shift: Swept density data is currently unsupported.");
		return NULL; //we only support 2 indeps. No sweeps etc are supported
    }
		
	decl index_size = sweep_size(density[::,0]) - 1; 
	decl i = 0;
	decl new_density = create(2, "Real", {"index", "time"}, {"Real", "Real"},1, 1);
	decl indep1_result = indep(new_density, "index");
	decl indep2_result = indep(new_density, "time");
	decl max_time = max(max(indep(density, "time")));
	decl min_time = min(min(indep(density, "time")));
		
	for (i = 0; i <= index_size; i++)
	{
		decl data = density[i,::];
		decl time_size = sweep_size(data) - 1;
		decl time_array = indep(data);
		decl time_array_temp = time_array + toffset;
		decl new_time_array = indep(vs(time_array_temp, time_array_temp));
	
		decl j = 0;
		for (j = 0; j <= time_size; j++)
		{
			if (new_time_array[j] > max_time)
			{
				decl t1 = new_time_array[j] - max_time + min_time;
				new_time_array[j] = t1;
			}
			else if (new_time_array[j] < min_time)
			{
				decl t2 = new_time_array[j] + max_time - min_time;
				new_time_array[j] = t2;
			}			
			
		}
		new_density[i,::] = data;
		indep2_result[i,::] = new_time_array;
		indep1_result[i] = i;
	}
	return new_density;
}

//****************************************************************************
// Created:      1st May 2002
// Copyright Keysight Technologies 2002 - 2014  
//
// This function takes time domain data and calculates jitter histograms
// within defined window parameters. The density can be controlled by parameters 
// numberOfBins and steps.

/*BEGIN_DOC
FUN_NAME: cross_hist
FUN_DESCRIPTION: Returns jitter histogram 
RETURNED_VALUE: Real
CATEGORY: Envelope
SYNTAX: y = cross_hist(Vout_time, time_start, time_stop, level_low, level_high, number_of_bins, BitRate, No_of_Eye, Delay, steps)
EXAMPLE:
Jitter_Histogram = cross_hist(vout, 0 ps, 100 ps, 0 V, 0.1V, 300, 10 GHz, 1,0, 20) 
ARGUMENT
  ARG_NAME: Vout_time
  ARG_DESCRIPTION: time domain voltage waveform
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: time_start
  ARG_DESCRIPTION: define the rectangular window points for jitter histogram plot
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: time_stop
  ARG_DESCRIPTION: define the rectangular window points for jitter histogram plot
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: level_low
  ARG_DESCRIPTION: define the rectangular window points for jitter histogram plot
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: level_high
  ARG_DESCRIPTION: define the rectangular window points for jitter histogram plot
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: number_of_bins
  ARG_DESCRIPTION: defines the number of bins on the time axis of eye diagram and controls the resolution of jitter histogram plot
  ARG_DEFAULT: None
  ARG_RANGE: [1:inf)
  ARG_TYPE: Integer
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: BitRate
  ARG_DESCRIPTION: bit rate of the channel and is expressed in frequency units
  ARG_DEFAULT: None
  ARG_RANGE: (0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: No_of_Eye
  ARG_DESCRIPTION: Used for multiple eye jitter histogram plots
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Integer
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: Delay
  ARG_DESCRIPTION: used to remove initial transient in the eye diagram and is expressed in time units
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE: Real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: steps
  ARG_DESCRIPTION: represents the number of sampling points between level_low and level_high and is used for controlling the density of jitter histogram.
  ARG_DEFAULT: None
  ARG_RANGE: [1:inf)
  ARG_TYPE: Integer
  ARG_REQUIRED: YES
DEFINED_IN: $HPEESOF_DIR/expressions/ael/DesignGuide_fun.ael
SEE ALSO: eye_amplitude(), eye_closure(), eye_fall_time(),eye_rise_time(), eye_height() 
NOTES:
Jitter histogram plots the jitter histogram of a time domain voltage waveform. 
EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/

//****************************************************************************
defun cross_hist(timed_data,time1,time2,level_zero,level_one,numberOfBins,symrate,n,delay,steps)
{
  decl Amp_Step,i,time_stmp,cal_time,wrapper,index,sweepSize;
  decl counter=0;
  decl low_amp=level_zero;
  decl high_amp=level_one;
  if (level_one < level_zero) {
    decl low_amp=level_one;
    decl high_amp=level_zero;
  }
  decl low_time=time1;
  decl high_time=time2;
  if ( time2<time1) {
    decl low_time=time2;
    decl high_time=time1;
  }
  Amp_Step=(high_amp-low_amp)/steps;
  decl dataIndep=indep(timed_data);
  decl startDataTime=dataIndep[0];
  decl startTimeindex=find_index(dataIndep,startDataTime+delay);
  decl data=timed_data[startTimeindex::sweep_size(timed_data)-1];
  decl sym_period = n/symrate;
  decl maxValue=sym_period;
  decl minValue=0;
  decl increment = (maxValue-minValue)/numberOfBins;
  decl result = create(1,"Real",{"time"},{"Real"},1,1);
  decl timeresult = indep(result);
  for(i=0;i<numberOfBins;i++) {
    timeresult[i] = minValue + (i*increment);
    result[i] = 0;
  }
  for ( i=0;i<=steps;i++) {
    wrapper=0;
    time_stmp=indep(cross(data-low_amp-i*Amp_Step,0));
    sweepSize=sweep_size(time_stmp)-1;
    for(index=0;index<=sweepSize;index++) {
      cal_time=time_stmp[index];
      while(cal_time>sym_period) {
        cal_time=(cal_time-wrapper*sym_period); 
        wrapper=wrapper+1;
      }
      if(( cal_time>=low_time)&&(cal_time<=high_time)) {
        counter = int(floor((cal_time-minValue)/increment));
        result[counter]=result[counter]+1;
      }
    } //for
  } //for
  return result;

} //fun - cross_hist


//****************************************************************************
// Copyright Keysight Technologies 2002 - 2014  
/*BEGIN_DOC
FUN_NAME: tdr_step_imped()
FUN_DESCRIPTION: Returns time domain Impedance. This function essentially takes
voltage reflection coefficient and calculates impedance versus time. 
RETURNED_VALUE: Real
CATEGORY: S-Parameter
SYNTAX: y = tdr_step_imped(time_waveform, zRef) 
EXAMPLE: x = tdr_step_imped(vout, 50) 
ARGUMENT
  ARG_NAME: time_waveform
  ARG_DESCRIPTION:  time domain pulse TDR waveform
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE:  Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: zRef
  ARG_DESCRIPTION: Reference impedance
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE:  real
  ARG_REQUIRED: YES
DEFINED_IN: $HPEESOF_DIR/expressions/ael/DesignGuide_fun.ael
SEE ALSO: tdr_sp_gamma(), tdr_sp_imped()
NOTES: 
  As of ADS 2011.01, this function has been deprecated in favor of tdr_step_impedance()
  
This function takes a time domain pulse TDR waveform, and computes the
impedance versus time. The function also assumes that a step impulse was
applied to the DUT, since it normalizes the impedance data to the last time
point. 

EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/

//****************************************************************************
defun tdr_step_imped(data,refimped)
{
  decl LastDataPoint=find_index(indep(data),max(indep(data)));
  decl Imped=mag(zin(data-data[LastDataPoint],refimped));

  return Imped;
} //fun - tdr_step_imped


//****************************************************************************
// Copyright Keysight Technologies 2002 - 2014  
/*BEGIN_DOC
FUN_NAME: tdr_step_impedance()
FUN_DESCRIPTION: Returns time domain Impedance. This function essentially takes
voltage reflection coefficient and calculates impedance versus time. 
RETURNED_VALUE: Real
CATEGORY: S-Parameter
SYNTAX: y = tdr_step_impedance(VSource, Zref,  Vincident) 
EXAMPLE: x = tdr_step_impedance(VSrc, 50, Vin) 
ARGUMENT
  ARG_NAME: VSource
  ARG_DESCRIPTION:  Step voltage source
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE:  Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: zRef
  ARG_DESCRIPTION: Reference impedance
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE:  real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: Vincident
  ARG_DESCRIPTION:  time domain pulse TDR waveform
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE:  Complex
  ARG_REQUIRED: YES

DEFINED_IN: $HPEESOF_DIR/expressions/ael/DesignGuide_fun.ael
SEE ALSO: tdr_sp_gamma(), tdr_sp_imped()
NOTES: This function takes a time domain pulse TDR waveform, and computes the
impedance versus time. The function  requires that a step impulse was
applied to the DUT.   Please use this function instead of tdr_step_imped()

EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 2010
END_DOC*/

//****************************************************************************

defun tdr_step_impedance( Vsrc, Zref, Vin )
{
  if ( Vsrc == NULL )
  {
    print_function_error( "tdr_step_impedance", "Source Voltage cannot be NULL" ) ;
    return ;
  }
  if ( Zref == NULL ) 
  {
    print_function_error( "tdr_step_impedance", "Reference impedance cannot be NULL" ) ;
    return ;
  }    
  if ( Vin == NULL ) 
  {
    print_function_error( "tdr_step_impedance", "Reference Voltage cannot be NULL" ) ;
    return ;
  }
  
  decl denom = ( Vsrc - Vin ) ;

/*
// This would return invalid even if only one data point of Vsrc and Vin being equal:
  if ( min(abs(denom[1::sweep_size(denom)-1])) == 0 )
// This comparison causes operand: ee_boolparameter value required error:
  if ( Vsrc == Vin )
  {
    print_function_error( "tdr_step_impedance", "Reference Voltage cannot be same as Source Voltage " ) ;
    return ;
  }
*/
  
  decl ZL = Zref * Vin / denom ;  
  return ZL;
  
} //fun - tdr_step_impedance


//****************************************************************************
// Copyright Keysight Technologies 2002 - 2014  
/*BEGIN_DOC
FUN_NAME: tdr_sp_gamma()
FUN_DESCRIPTION: Returns step response. This function calculates time domain response from the S-parameter measurement directly. Normalization is taken into account. 
RETURNED_VALUE: Real
CATEGORY: S-Parameter
SYNTAX: y = tdr_sp_gamma(Sii, delay, Tstart, Tstop, NumPts, window)
EXAMPLE:  x = tdr_sp_gamma(S(1,1), 0.05ns, -0.2 ns, 3.8 ns, 401, "Hamming")
ARGUMENT
  ARG_NAME: Sii
  ARG_DESCRIPTION: Complex reflection coefficient
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE:  Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: delay
  ARG_DESCRIPTION: delay value
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE:  real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: Tstart
  ARG_DESCRIPTION: Start Time
  ARG_DEFAULT: 0
  ARG_RANGE: [0:inf)
  ARG_TYPE:  real
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: Tstop
  ARG_DESCRIPTION: Stop Time
  ARG_DEFAULT: 2 cycles
  ARG_RANGE: [0:inf)
  ARG_TYPE:  real
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: NumPts
  ARG_DESCRIPTION: Number of points
  ARG_DEFAULT: 101
  ARG_RANGE: [0:inf)
  ARG_TYPE:  real ot string
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: Window
  ARG_DESCRIPTION: Windowing to be applied
  ARG_DEFAULT: 0
  ARG_RANGE: [0:9] dagger.gif
  ARG_TYPE:  real
  ARG_REQUIRED: NO
FOOTNOTES: dagger.gif The window types allowed and their default constants are: 

  0 = None 
  1 = Hamming 0.54 
  2 = Hanning 0.50 
  3 = Gaussian 0.75 
  4 = Kaiser 7.865 
  5 = 8510 6.0 (This is equivalent to the frequency-to-time transformation with
		normal gate window setting in the 8510 series network analyzer.) 
  6 = Blackman 
  7 = Blackman-Harris 
  8 = 8510-Minimum 0
  9 = 8510-Maximum 13
DEFINED_IN: $HPEESOF_DIR/expressions/ael/DesignGuide_fun.ael
SEE ALSO: tdr_sp_imped(), tdr_step_imped() 
NOTES: This function takes an S-parameter dataset and changes it to a step
response. The step response is normalized and used to calculate reflection
coefficient vs. time. 

EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/

//****************************************************************************
defun tdr_sp_gamma(data,delay,start,stop,numpts,window)
{
  decl NumFreqPts=sweep_size(indep(data));
  decl BandWidth=max(indep(data))-min(indep(data));
  decl LaPlaceNorm=1/(j*2*pi*indep(data));
  decl DelayPhasor=exp(-j*2*pi*indep(data)*delay);
  decl Gamma=data*DelayPhasor*(2*BandWidth/NumFreqPts)*LaPlaceNorm;
  decl Time_Gamma=ts(Gamma,start,stop,numpts,,window);

  return Time_Gamma;
} //fun - tdr_sp_gamma

//****************************************************************************
//
// File:         tdr_sp_imped.ael
// Copyright Keysight Technologies 2002 - 2014  
// Usage: x=tdr_sp_imped(Sdataset,delay,ref imped,start time,stop time,num pts,window)
//
/*BEGIN_DOC
FUN_NAME: tdr_sp_imped()
FUN_DESCRIPTION: Returns step response. This function calculates time domain response from the S-parameter measurement directly. Normalization is taken into account. 
RETURNED_VALUE: Real
CATEGORY: S-Parameter
SYNTAX: y = tdr_sp_imped(Sii, delay, zRef, Tstart, Tstop, NumPts, window)
EXAMPLE:  x = tdr_sp_imped(S(1,1), 0.05ns, 50, -0.2 ns, 3.8 ns, 401, "Hamming")
ARGUMENT
  ARG_NAME: Sii
  ARG_DESCRIPTION: Complex reflection coefficient
  ARG_DEFAULT: None
  ARG_RANGE: (-inf:inf)
  ARG_TYPE:  Complex
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: delay
  ARG_DESCRIPTION: delay value
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE:  real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: zRef
  ARG_DESCRIPTION: Reference impedance
  ARG_DEFAULT: None
  ARG_RANGE: [0:inf)
  ARG_TYPE:  real
  ARG_REQUIRED: YES
ARGUMENT
  ARG_NAME: Tstart
  ARG_DESCRIPTION: Start Time
  ARG_DEFAULT: 0
  ARG_RANGE: [0:inf)
  ARG_TYPE:  real
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: Tstop
  ARG_DESCRIPTION: Stop Time
  ARG_DEFAULT: 2 cycles
  ARG_RANGE: [0:inf)
  ARG_TYPE:  real
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: NumPts
  ARG_DESCRIPTION: Number of points
  ARG_DEFAULT: 101
  ARG_RANGE: [0:inf)
  ARG_TYPE:  real ot string
  ARG_REQUIRED: NO
ARGUMENT
  ARG_NAME: Window
  ARG_DESCRIPTION: Windowing to be applied
  ARG_DEFAULT: 0
  ARG_RANGE: [0:7] dagger.gif
  ARG_TYPE:  real
  ARG_REQUIRED: NO
FOOTNOTES: dagger.gif The window types allowed and their default constants are: 

  0 = None 
  1 = Hamming 0.54 
  2 = Hanning 0.50 
  3 = Gaussian 0.75 
  4 = Kaiser 7.865 
  5 = 8510 6.0 (This is equivalent to the frequency-to-time transformation with
		normal gate window setting in the 8510 series network analyzer.) 
  6 = Blackman 
  7 = Blackman-Harris 
  8 = 8510-Minimum 0
  9 = 8510-Maximum 13
DEFINED_IN: $HPEESOF_DIR/expressions/ael/DesignGuide_fun.ael
SEE ALSO: tdr_sp_gamma(), tdr_step_imped() 
NOTES: This function takes an S-parameter dataset and changes it to a step
response. The step response is normalized and used to calculate reflection
coefficient vs. time. This gamma is then used to calculate impedance versus
time. 
EXTERNAL: yes
AUTHOR: Keysight Technologies
DATE: Unknown
VERSION_CREATED: ADS 1.0
END_DOC*/

//****************************************************************************
defun tdr_sp_imped(data,delay,refimped,start,stop,numpts,window)
{
  decl NumFreqPts=sweep_size(indep(data));
  decl BandWidth=max(indep(data))-min(indep(data));
  decl LaPlaceNorm=1/(j*2*pi*indep(data));
  decl DelayPhasor=exp(-j*2*pi*indep(data)*delay);
  decl Gamma=data*DelayPhasor*(2*BandWidth/NumFreqPts)*LaPlaceNorm;
  decl Time_Gamma=ts(Gamma,start,stop,numpts,,window);
  decl Time_Imped=mag(zin(Time_Gamma-Time_Gamma[0],refimped));

  return Time_Imped;
} //fun - tdr_sp_imped

//****************************************************************************
// The following code is used with the RF System DesignGuide for ADS 2003A
// Code provided by Prof. Shawn Stapleton
//
//	COMMUNICATIONS ROUTINES
//		GENERAL
//			kmm_symbol_extract
//		HPSK
//			kmm_evm_hpsk
//			kmm_evm_hpsk_v2
//			const_evm_hpsk_ref
//			const_evm_hpsk_ref_v2
//		OQPSK
//			const_evm_oqpsk_ref
//			const_evm_oqpsk_ref_v2
//		QPSK
//			const_evm_qpsk
//			const_evm_qpsk_ref_v2
//			kmm_evm_qpsk
//			kmm_evm_qpsk_v2
//
//	GENERAL PURPOSE ROUTINES
//		kmm_cross_corr
//		kmm_filt
//		kmm_conv
//		kmm_spectrum_shift
//		kmm_filtcoef
//		kmm_rem
//		kmm_delay
//
//	GSM/EDGE SPECIFIC ROUTINES - GMSK, GSM 8-PSK
//		kmm_get_8psk_TSC
//		kmm_get_gmsk_TSC
//		kmm_gsm_8psk_symbol_extract
//		kmm_gsm_gmsk_evm
//		kmm_gsm_evm
//		kmm_LUT_init
//		kmm_init_foft
//		kmm_init_TSC_wav
//		kmm_gsm_8psk_const_evm_v2
//		kmm_gsm_gmsk_const_evm_v2
//		kmm_gsm_8psk_const_evm
//		kmm_freq_hop
//		kmm_dehop
//
//	INCOMPLETE ROUTINES
//		kmm_lagrange_interp
//
//	UTILITY/DEBUGGING ROUTINES	
//		kmm_dbugout_n
//		kmm_dbugout_a
//
//
//



//***********************************************************************************************************
//
//  Function name:
//  Usage:
//
//  Parameters:
//
//
//  Description:
//
//
//
//
//
//
//
//
//
//
//
//






defun kmm_delay(vin, u_delay_steps)
{

    if ( vin == NULL || u_delay_steps < 0 )
	 return;

    decl delay_steps = u_delay_steps == NULL ? 0 : u_delay_steps;
    decl vin_indep = indep(vin);
    decl dly = (vin_indep[1] - vin_indep[0]) * delay_steps;

    return vs(vin,vin_indep - dly);
   
}


//***********************************************************************************************************

defun const_evm_qpsk(vfund_ideal, vfund_dist, u_symbol_rate, u_sample_delay, u_transient_duration, u_path_delay, u_dc, u_rotation, u_gaincomp)
{
    decl slice_flag = 0;
    decl k;

    if ( vfund_dist == NULL ) {
	print_function_error("const_evm_qpsk","No distorted envelope data.");
	return;
    }

    if ( vfund_ideal == NULL )
        slice_flag = 1;

    decl symbol_rate = u_symbol_rate;
    decl sample_delay = u_sample_delay == NULL ? 0 : u_sample_delay;
    decl transient_duration = u_transient_duration == NULL ? 0 : u_transient_duration;
    decl path_delay = u_path_delay == NULL ? 0 : u_path_delay;
    decl dc = u_dc;
    decl rotation =  u_rotation;
    decl gaincomp = u_gaincomp;
 
    if ( symbol_rate == NULL || symbol_rate == 0)  {
	print_function_error("const_evm_oqpsk","The symbol rate must be greater than zero.");
	return;
    }
	 
	//??????????? do I use tran_time below?
    decl tran_time = 0;
    if ( transient_duration ) //skip integer number of symbols
      tran_time = ceil(mag(transient_duration)*symbol_rate)/symbol_rate;

    decl start_time = sample_delay + tran_time;
    decl stop_time = start_time;
    decl incr = 1/symbol_rate;
  
    decl vfund_ideal_real;
    decl vfund_ideal_imag;
    decl ideal_trajectory;
    decl ideal_constellation;
    decl time_vector;
    decl sample_period; 
    decl start_index;
    decl end_index;
    if (slice_flag == 0) {
    	vfund_ideal_real = real(vfund_ideal);
    	vfund_ideal_imag = imag(vfund_ideal);

        // generate ideal trajectory - start trajectory data after transient duration
        time_vector = indep(vfund_ideal);
	sample_period = time_vector[1] - time_vector[0];
	start_index = ceil(mag(transient_duration)/sample_period);
	end_index = sweep_size(vfund_ideal_real) - 1;
	ideal_trajectory = vs(vfund_ideal_imag[start_index::end_index], vfund_ideal_real[start_index::end_index]);

    	// ideal constellation
        stop_time = max(indep(vfund_ideal));
    	vfund_ideal_real = interp(vfund_ideal_real, start_time, stop_time, incr);
    	vfund_ideal_imag = interp(vfund_ideal_imag, start_time, stop_time, incr);
    	vfund_ideal = vfund_ideal_real + j*vfund_ideal_imag;
	ideal_constellation = vs(vfund_ideal_imag, vfund_ideal_real);
    	set_attr(ideal_constellation,"TraceType","Scatter");
    } else {
	ideal_trajectory = NULL;
    }

    // sample the distorted (& manually compensated) signal
    start_time += path_delay;
    if (slice_flag != 0) 
        stop_time = max(indep(vfund_dist));
    decl vfund_dist_real = interp(real(vfund_dist), start_time, stop_time, incr);
    decl vfund_dist_imag = interp(imag(vfund_dist), start_time, stop_time, incr);
    decl tn = sweep_size(vfund_dist_real);

    // slice to get ideal constellation, if necessary
    if (slice_flag != 0) {
        vfund_ideal_real = vfund_dist_real + 0.0; 
        vfund_ideal_imag = vfund_dist_imag + 0.0; 
	for (k=0; k < tn; k++) {
	    vfund_ideal_real[k] = (vfund_dist_real[k] >= 0.0) ? 1.0 : -1.0;
            vfund_ideal_imag[k] = (vfund_dist_imag[k] >= 0.0) ? 1.0 : -1.0;
	}
        vfund_ideal = vfund_ideal_real + j * vfund_ideal_imag;
	ideal_constellation = vs(vfund_ideal_real, vfund_ideal_imag);
    	set_attr(ideal_constellation,"TraceType","Scatter");
    } 

    tn = min([tn, sweep_size(vfund_ideal)]);

    // distorted trajectory 
    time_vector = indep(vfund_dist);
    sample_period = time_vector[1] - time_vector[0];
    start_index = ceil(mag(transient_duration)/sample_period);
    end_index = sweep_size(vfund_dist) - 1;
    decl dist_trajectory = vs(imag(vfund_dist[start_index::end_index]),real(vfund_dist[start_index::end_index]));

    // use specified values to compensate 
    if (rotation != NULL) vfund_dist *= exp(j*rotation);
    if (dc != NULL) vfund_dist += dc;
    if (gaincomp != NULL) vfund_dist *= gaincomp;

    // find mean phase difference and compensate
    decl phase_delta = phaserad(vfund_dist_real[0::tn-1] +j*vfund_dist_imag[0::tn-1])
	             - phaserad(vfund_ideal_real[0::tn-1]+j*vfund_ideal_imag[0::tn-1]);
    decl phase_unwrapped1= if (phase_delta < -pi) then (phase_delta+2*pi) else phase_delta;
    decl phase_unwrapped = if (phase_unwrapped1>pi) then phase_unwrapped1 -2*pi else phase_unwrapped1;
    decl mean_phase_delta = mean(phase_unwrapped);
    if (rotation == NULL) vfund_dist *= exp(-j*mean_phase_delta);

    // find mean dc difference and compensate
    decl mean_dc = mean(vfund_dist_real[0::tn-1]) + j * mean(vfund_dist_imag[0::tn-1]) - 
			mean(vfund_ideal_real[0::tn-1] + j * vfund_ideal_imag[0::tn-1]);
    if (dc == NULL) vfund_dist -= mean_dc;

    // determine scaling (gain/compression) and compensate
    decl mean_gaincomp = mean(mag(vfund_ideal_real[0::tn-1] + j * vfund_ideal_imag[0::tn-1])) / 
			mean(mag(vfund_dist_real[0::tn-1] + j * vfund_dist_imag[0::tn-1]));
    if (gaincomp == NULL) vfund_dist = vfund_dist * mean_gaincomp;
  
    // resample vfund_dist to get the compensated constellation points
    vfund_dist_real = interp(real(vfund_dist), start_time, stop_time, incr);
    vfund_dist_imag = interp(imag(vfund_dist), start_time, stop_time, incr);
    vfund_dist =  vfund_dist_real + j*vfund_dist_imag;
    decl distorted_constellation = vs(imag(vfund_dist), real(vfund_dist));
    set_attr(distorted_constellation,"TraceType","Scatter");

    // EVM - for magnitude to the furthest constellation point, simply average the magnitude
    //   of all constellation points, since this is evm for qpsk
    decl evm = mag(vfund_dist[0::tn-1]-vfund_ideal[0::tn-1]);
    decl evm_rms = sqrt(mean(evm**2));
    decl evm_percent = 100*evm_rms/mean(mag(vfund_ideal[0::tn-1]));

    return list(ideal_constellation, ideal_trajectory, distorted_constellation, dist_trajectory, evm, evm_percent, mean_phase_delta, mean_dc, mean_gaincomp);
}

//***********************************************************************************************************

defun const_evm_qpsk_ref_v2(vfund_ref, vfund_dist, u_symbol_rate, u_sample_delay, u_transient_duration, u_path_delay, u_dc, u_rotation, u_gaincomp)
{
    decl slice_flag = 0;
    decl k;

    if ( vfund_dist == NULL ) {
	print_function_error("const_evm_qpsk_ref_v2","No distorted envelope data.");
	return;
    }

    if ( vfund_ref == NULL )
        slice_flag = 1;

    decl symbol_rate = u_symbol_rate;
    decl sample_delay = u_sample_delay == NULL ? 0 : u_sample_delay;
    decl transient_duration = u_transient_duration == NULL ? 0 : u_transient_duration;
    decl path_delay = u_path_delay == NULL ? 0 : u_path_delay;
    decl dc = u_dc;
    decl rotation =  u_rotation;
    decl gaincomp = u_gaincomp;
 
    if ( symbol_rate == NULL || symbol_rate == 0)  {
	print_function_error("const_evm_qpsk_ref_v2","The symbol rate must be greater than zero.");
	return;
    }
	 
    decl tran_time = 0;
    if ( transient_duration ) //skip integer number of symbols
      tran_time = ceil(mag(transient_duration)*symbol_rate)/symbol_rate;

    // distorted trajectory - no compensation
    decl time_vector = indep(vfund_dist);
    decl sample_period = time_vector[1] - time_vector[0];
    decl start_index = ceil(mag(tran_time)/sample_period);
    decl end_index = sweep_size(vfund_dist) - 1;
    decl dist_trajectory = vs(imag(vfund_dist[start_index::end_index]),real(vfund_dist[start_index::end_index]));

    // sample the distorted signal
    decl start_time = sample_delay + tran_time + path_delay;
    decl stop_time = max(indep(vfund_dist));
    decl incr = 1/symbol_rate;
    decl vfund_dist_real = interp(real(vfund_dist), start_time, stop_time, incr);
    decl vfund_dist_imag = interp(imag(vfund_dist), start_time, stop_time, incr);
    decl dist_const = vfund_dist_real + j * vfund_dist_imag;
    decl tn = sweep_size(vfund_dist_real);

    // generate reference trajectory and constellation
    decl vfund_ref_real;
    decl vfund_ref_imag;
    decl dist_constellation;

    if (slice_flag != 1) {

        dist_constellation = vs(vfund_dist_imag, vfund_dist_real);
    	set_attr(dist_constellation,"TraceType","Scatter");

    	// determine reference constellation by sampling reference signal
	start_time = tran_time + sample_delay;
        stop_time = max(indep(vfund_ref));
    	vfund_ref_real = interp(real(vfund_ref), start_time, stop_time, incr);
    	vfund_ref_imag = interp(imag(vfund_ref), start_time, stop_time, incr);

    } else {

        // in this case the reference signal is the compensated distorted signal
	// use specified values to compensate distorted signal PRIOR to slicing
   	vfund_ref = vfund_dist;
        if (rotation != NULL) vfund_ref *= exp(j * rotation * pi / 180);
        if (dc != NULL) vfund_ref += 
		mean(abs(real(vfund_dist))) * real(dc) + j * (mean(abs(imag(vfund_dist))) * imag(dc));
        if (gaincomp != NULL) vfund_ref *= gaincomp;

	// the start time includes the path delay, as vfund_ref is derived from vfund_dist
	start_time = tran_time + sample_delay + path_delay;
        stop_time = max(indep(vfund_ref));
    	vfund_ref_real = interp(real(vfund_ref), start_time, stop_time, incr);
    	vfund_ref_imag = interp(imag(vfund_ref), start_time, stop_time, incr);
        
        dist_constellation = vs(vfund_ref_imag, vfund_ref_real);
    	set_attr(dist_constellation,"TraceType","Scatter");

        // slice to get ideal constellation
	for (k = 0; k < sweep_size(vfund_ref_real); k++) {
	    vfund_ref_real[k] = (vfund_ref_real[k] >= 0.0) ? 1.0 : -1.0;
            vfund_ref_imag[k] = (vfund_ref_imag[k] >= 0.0) ? 1.0 : -1.0;
	}
    
    }

    decl ref_const = vfund_ref_real + j * vfund_ref_imag;
    decl ref_constellation = vs(vfund_ref_imag, vfund_ref_real);
    set_attr(ref_constellation,"TraceType","Scatter");

    // generate reference trajectory - start trajectory data after transient duration
    time_vector = indep(vfund_ref);
    sample_period = time_vector[1] - time_vector[0];
    start_index = ceil(tran_time / sample_period);
    end_index = sweep_size(vfund_ref) - 1;
    decl ref_trajectory = vs(imag(vfund_ref[start_index::end_index]), real(vfund_ref[start_index::end_index]));

    tn = min([tn, sweep_size(vfund_ref_real)]) - 1;
    decl dist_const_comp = [dist_const] + 0.0;

    // find mean phase difference between reference and distorted constellations and compensate, unless
    // user directed compensation has already been carried out
    decl phase_delta = phaserad(dist_const[0::tn]) - phaserad(ref_const[0::tn]);
    decl phase_unwrapped1 = if (phase_delta < -pi) then (phase_delta + 2 * pi) else phase_delta;
    decl phase_unwrapped = if (phase_unwrapped1 > pi) then (phase_unwrapped1 - 2 * pi) else phase_unwrapped1;
    decl mean_phase_delta = mean(phase_unwrapped);
    if (rotation == NULL || slice_flag == 1) 
	dist_const_comp *= exp(-j * mean_phase_delta);

    // find mean dc offset between reference and distorted constellations and compensate, unless
    // user directed compensation has already been carried out
    decl rel_dc_x_ref = mean(real(ref_const[0::tn])) / mean(abs(real(ref_const[0::tn])));
    decl rel_dc_y_ref = mean(imag(ref_const[0::tn])) / mean(abs(imag(ref_const[0::tn])));
    decl rel_dc_x_dist = mean(real(dist_const[0::tn])) / mean(abs(real(dist_const[0::tn])));
    decl rel_dc_y_dist = mean(imag(dist_const[0::tn])) / mean(abs(imag(dist_const[0::tn])));
    decl mean_dc_delta = (rel_dc_x_ref - rel_dc_x_dist) + j * (rel_dc_y_ref - rel_dc_y_dist);
    if (dc == NULL || slice_flag == 1) 
	dist_const_comp += (rel_dc_x_ref - rel_dc_x_dist) * mean(abs(real(dist_const))) + 
			j * (rel_dc_y_ref - rel_dc_y_dist) * mean(abs(imag(dist_const)));

    // determine scaling (gain/compression) difference between reference and distorted constellations
    // and compensate, unless user directed compensation has already been carried out
    decl mean_gaincomp = mean(mag(ref_const[0::tn])) / mean(mag(dist_const[0::tn]));
    if (gaincomp == NULL || slice_flag == 1) 
	dist_const_comp *= mean_gaincomp;

    decl evm = mag(dist_const_comp[0::tn] - ref_const[0::tn]);
    decl evm_rms = sqrt(mean(evm**2)); 
    decl avgrefmag = mean(mag(ref_const[0::tn]));
    if (avgrefmag < 1e-20) avgrefmag = 1.0;
    decl evm_rms_percent = 100 * evm_rms / avgrefmag;
    decl max_evm_percent = 100 * max(evm) / avgrefmag;
    decl mag_err_percent = 100 * mean(abs(mag(dist_const_comp[0::tn]) - mag(ref_const[0::tn]))) / avgrefmag;
    decl phase_err_deg = mean_phase_delta * 180 / pi;
    decl iq_origin_offset_dB = 10 * log(mag(mean_dc_delta) + 1e-20);

    return list(ref_constellation, ref_trajectory, dist_constellation, dist_trajectory, evm_rms_percent, max_evm_percent, evm, mag_err_percent, phase_err_deg, iq_origin_offset_dB);
}

//*********************************************************************************************************

defun const_evm_oqpsk(vfund_ideal, vfund_dist, u_symbol_rate, u_offset, u_sample_delay, u_transient_duration, u_path_delay, u_dc, u_rotation, u_gaincomp)
{
    decl slice_flag = 0;
    decl k;

    if ( vfund_dist == NULL ) {
	print_function_error("const_evm_oqpsk","No distorted envelope data.");
	return;
    }

    if ( vfund_ideal == NULL )
        slice_flag = 1;

    decl symbol_rate = u_symbol_rate;
    decl sample_delay = u_sample_delay == NULL ? 0 : u_sample_delay;
    decl offset = u_offset == NULL ? 0 : u_offset;
    decl transient_duration = u_transient_duration == NULL ? 0 : u_transient_duration;
    decl path_delay = u_path_delay == NULL ? 0 : u_path_delay;
    decl dc = u_dc;
    decl rotation =  u_rotation;
    decl gaincomp = u_gaincomp;
 
    if ( symbol_rate == NULL || symbol_rate == 0) {
	print_function_error("const_evm_oqpsk","The symbol rate must be greater than zero.");
	return;
    }

    decl tran_time = 0;
    if ( transient_duration ) //skip integer number of symbols
      tran_time = ceil(mag(transient_duration)*symbol_rate)/symbol_rate;

    decl start_time = sample_delay + tran_time;
    decl stop_time = start_time;
    decl incr = 1/symbol_rate;
  
    decl vfund_ideal_real;
    decl vfund_ideal_imag;
    decl ideal_trajectory;
    decl ideal_constellation;
    decl sn;
    decl time_vector;
    decl sample_period; 
    decl start_index;
    decl end_index;
    if (slice_flag == 0) {
    	vfund_ideal_real = real(vfund_ideal);
    	vfund_ideal_imag = imag(vfund_ideal);

        // generate ideal trajectory
        time_vector = indep(vfund_ideal);
	sample_period = time_vector[1] - time_vector[0];
	start_index = ceil(mag(transient_duration)/sample_period);
	end_index = sweep_size(vfund_ideal_real) - 1;
	ideal_trajectory = vs(vfund_ideal_imag[start_index::end_index], vfund_ideal_real[start_index::end_index]);

    	// ideal constellation
        stop_time = max(indep(vfund_ideal));
    	vfund_ideal_real = interp(vfund_ideal_real, start_time + offset, stop_time, incr);
    	vfund_ideal_imag = interp(vfund_ideal_imag, start_time, stop_time - offset, incr);
	sn = min([sweep_size(vfund_ideal_real), sweep_size(vfund_ideal_imag)]);
    	vfund_ideal = vfund_ideal_real[0::sn-1] + j*vfund_ideal_imag[0::sn-1];
	ideal_constellation = vs(vfund_ideal_imag[0::sn-1], vfund_ideal_real[0::sn-1]);
    	set_attr(ideal_constellation,"TraceType","Scatter");
    } else {
	ideal_trajectory = NULL;
    }

    // sample the distorted (& manually compensated) signal
    start_time += path_delay;
    if (slice_flag != 0) 
        stop_time = max(indep(vfund_dist));
    decl vfund_dist_real = interp(real(vfund_dist), start_time + offset, stop_time, incr);
    decl vfund_dist_imag = interp(imag(vfund_dist), start_time, stop_time - offset, incr);
    decl tn = min([sweep_size(vfund_dist_real), sweep_size(vfund_dist_imag)]);

    // slice to get ideal constellation, if necessary
    if (slice_flag != 0) {
	sn = tn;
        vfund_ideal_real = vfund_dist_real[0::tn-1] + 0.0; 
        vfund_ideal_imag = vfund_dist_imag[0::tn-1] + 0.0; 
	for (k=0; k < tn; k++) {
	    vfund_ideal_real[k] = (vfund_dist_real[k] >= 0.0) ? 1.0 : -1.0;
            vfund_ideal_imag[k] = (vfund_dist_imag[k] >= 0.0) ? 1.0 : -1.0;
	}
        vfund_ideal = vfund_ideal_real + j * vfund_ideal_imag;
	ideal_constellation = vs(vfund_ideal_real, vfund_ideal_imag);
    	set_attr(ideal_constellation,"TraceType","Scatter");
    } 

    decl un = min([tn, sn]);

    // distorted trajectory 
    time_vector = indep(vfund_dist);
    sample_period = time_vector[1] - time_vector[0];
    start_index = ceil(mag(transient_duration)/sample_period);
    end_index = sweep_size(vfund_dist) - 1;
    decl dist_trajectory = vs(imag(vfund_dist[start_index::end_index]),real(vfund_dist[start_index::end_index]));

    // use specified values to compensate 
    if (rotation != NULL) vfund_dist *= exp(j*rotation);
    if (dc != NULL) vfund_dist += dc;
    if (gaincomp != NULL) vfund_dist *= gaincomp;

    // find mean phase difference and compensate
    decl phase_delta = phaserad(vfund_dist_real[0::un-1] +j*vfund_dist_imag[0::un-1])
	             - phaserad(vfund_ideal_real[0::un-1]+j*vfund_ideal_imag[0::un-1]);
    decl phase_unwrapped1= if (phase_delta < -pi) then (phase_delta+2*pi) else phase_delta;
    decl phase_unwrapped = if (phase_unwrapped1>pi) then phase_unwrapped1 -2*pi else phase_unwrapped1;
    decl mean_phase_delta = mean(phase_unwrapped);
    if (rotation == NULL) vfund_dist *= exp(-j*mean_phase_delta);

    // find mean dc difference and compensate
    decl mean_dc = mean(vfund_dist_real[0::un-1]) + j * mean(vfund_dist_imag[0::un-1]) - 
			mean(vfund_ideal_real[0::un-1] + j * vfund_ideal_imag[0::un-1]);
    if (dc == NULL) vfund_dist -= mean_dc;

    // determine scaling (gain/compression) and compensate
    decl mean_gaincomp = mean(mag(vfund_ideal_real[0::un-1] + j * vfund_ideal_imag[0::un-1])) / 
			mean(mag(vfund_dist_real[0::un-1] + j * vfund_dist_imag[0::un-1]));
    if (gaincomp == NULL) vfund_dist = vfund_dist * mean_gaincomp;
  
    // resample vfund_dist to get the compensated constellation points
    vfund_dist_real = interp(real(vfund_dist), start_time + offset, stop_time, incr);
    vfund_dist_imag = interp(imag(vfund_dist), start_time, stop_time - offset, incr);
    tn = min([sweep_size(vfund_dist_real), sweep_size(vfund_dist_imag)]);
    vfund_dist =  vfund_dist_real[0::tn-1] + j*vfund_dist_imag[0::tn-1];
    decl distorted_constellation = vs(imag(vfund_dist), real(vfund_dist));
    set_attr(distorted_constellation,"TraceType","Scatter");

    un = min([sn, tn]);
    // EVM - for magnitude to the furthest constellation point, simply average the magnitude
    //   of all constellation points, since this is evm for oqpsk
    decl evm = mag(vfund_dist[0::un-1]-vfund_ideal[0::un-1]);
    decl evm_rms = sqrt(mean(evm**2));
    decl evm_percent = 100*evm_rms/mean(mag(vfund_ideal[0::un-1]));

    return list(ideal_constellation, ideal_trajectory, distorted_constellation, dist_trajectory, evm, evm_percent, mean_phase_delta, mean_dc, mean_gaincomp);
}

//*********************************************************************************************************

defun const_evm_oqpsk_ref_v2(vfund_ref, vfund_dist, u_symbol_rate, u_offset, u_sample_delay, u_transient_duration, u_path_delay, u_dc, u_rotation, u_gaincomp)
{
    decl slice_flag = 0;
    decl k;

    if ( vfund_dist == NULL ) {
	print_function_error("const_evm_oqpsk_ref_v2","No distorted envelope data.");
	return;
    }

    if ( vfund_ref == NULL )
        slice_flag = 1;

    decl symbol_rate = u_symbol_rate;
    decl sample_delay = u_sample_delay == NULL ? 0 : u_sample_delay;
    decl offset = u_offset == NULL ? 0 : u_offset;
    decl transient_duration = u_transient_duration == NULL ? 0 : u_transient_duration;
    decl path_delay = u_path_delay == NULL ? 0 : u_path_delay;
    decl dc = u_dc;
    decl rotation =  u_rotation;
    decl gaincomp = u_gaincomp;
 
    if ( symbol_rate == NULL || symbol_rate == 0)  {
	print_function_error("const_evm_oqpsk_ref_v2","The symbol rate must be greater than zero.");
	return;
    }
	 
    decl tran_time = 0;
    if ( transient_duration ) //skip integer number of symbols
      tran_time = ceil(mag(transient_duration)*symbol_rate)/symbol_rate;

    // distorted trajectory - no compensation
    decl time_vector = indep(vfund_dist);
    decl sample_period = time_vector[1] - time_vector[0];
    decl start_index = ceil(mag(tran_time)/sample_period);
    decl end_index = sweep_size(vfund_dist) - 1;
    decl dist_trajectory = vs(imag(vfund_dist[start_index::end_index]),real(vfund_dist[start_index::end_index]));

    // sample the distorted signal
    decl start_time = sample_delay + tran_time + path_delay;
    decl stop_time = max(indep(vfund_dist));
    decl incr = 1/symbol_rate;
    decl vfund_dist_real = interp(real(vfund_dist), start_time + offset, stop_time, incr);
    decl vfund_dist_imag = interp(imag(vfund_dist), start_time, stop_time - offset, incr);
    decl tn = min([sweep_size(vfund_dist_real), sweep_size(vfund_dist_imag)]) - 1;
    decl dist_const = vfund_dist_real[0::tn] + j * vfund_dist_imag[0::tn];

    // generate reference trajectory and constellation
    decl vfund_ref_real;
    decl vfund_ref_imag;
    decl dist_constellation;
    decl sn;

    if (slice_flag != 1) {

        dist_constellation = vs(vfund_dist_imag, vfund_dist_real);
    	set_attr(dist_constellation,"TraceType","Scatter");

    	// determine reference constellation by sampling reference signal
	start_time = tran_time + sample_delay;
        stop_time = max(indep(vfund_ref));
    	vfund_ref_real = interp(real(vfund_ref), start_time + offset, stop_time, incr);
    	vfund_ref_imag = interp(imag(vfund_ref), start_time, stop_time - offset, incr);
        sn = min([sweep_size(vfund_ref_real), sweep_size(vfund_ref_imag)]) - 1;

    } else {

        // in this case the reference signal is the compensated distorted signal
	// use specified values to compensate distorted signal PRIOR to slicing
   	vfund_ref = vfund_dist;
        if (rotation != NULL) vfund_ref *= exp(j * rotation * pi / 180);
        if (dc != NULL) vfund_ref += 
		mean(abs(real(vfund_dist))) * real(dc) + j * (mean(abs(imag(vfund_dist))) * imag(dc));
        if (gaincomp != NULL) vfund_ref *= gaincomp;

	// the start time includes the path delay, as vfund_ref is derived from vfund_dist
	start_time = tran_time + sample_delay + path_delay;
        stop_time = max(indep(vfund_ref));
    	vfund_ref_real = interp(real(vfund_ref), start_time + offset, stop_time, incr);
    	vfund_ref_imag = interp(imag(vfund_ref), start_time, stop_time - offset, incr);
        sn = min([sweep_size(vfund_ref_real), sweep_size(vfund_ref_imag)]) - 1;
        
        dist_constellation = vs(vfund_ref_imag[0::sn], vfund_ref_real[0::sn]);
    	set_attr(dist_constellation,"TraceType","Scatter");

        // slice to get ideal constellation
	for (k = 0; k < sweep_size(vfund_ref_real); k++) {
	    vfund_ref_real[k] = (vfund_ref_real[k] >= 0.0) ? 1.0 : -1.0;
            vfund_ref_imag[k] = (vfund_ref_imag[k] >= 0.0) ? 1.0 : -1.0;
	}
    
    }

    decl ref_const = vfund_ref_real + j * vfund_ref_imag;
    decl ref_constellation = vs(vfund_ref_imag[0::sn], vfund_ref_real[0::sn]);
    set_attr(ref_constellation,"TraceType","Scatter");

    // generate reference trajectory - start trajectory data after transient duration
    time_vector = indep(vfund_ref);
    sample_period = time_vector[1] - time_vector[0];
    start_index = ceil(tran_time / sample_period);
    end_index = sweep_size(vfund_ref) - 1;
    decl ref_trajectory = vs(imag(vfund_ref[start_index::end_index]), real(vfund_ref[start_index::end_index]));

    tn = min([tn, sn]) - 1;
    decl dist_const_comp = [dist_const] + 0.0;

    // find mean phase difference between reference and distorted constellations and compensate, unless
    // user directed compensation has already been carried out
    decl phase_delta = phaserad(dist_const[0::tn]) - phaserad(ref_const[0::tn]);
    decl phase_unwrapped1 = if (phase_delta < -pi) then (phase_delta + 2 * pi) else phase_delta;
    decl phase_unwrapped = if (phase_unwrapped1 > pi) then (phase_unwrapped1 - 2 * pi) else phase_unwrapped1;
    decl mean_phase_delta = mean(phase_unwrapped);
    if (rotation == NULL || slice_flag == 1) 
	dist_const_comp *= exp(-j * mean_phase_delta);

    // find mean dc offset between reference and distorted constellations and compensate, unless
    // user directed compensation has already been carried out
    decl rel_dc_x_ref = mean(real(ref_const[0::tn])) / mean(abs(real(ref_const[0::tn])));
    decl rel_dc_y_ref = mean(imag(ref_const[0::tn])) / mean(abs(imag(ref_const[0::tn])));
    decl rel_dc_x_dist = mean(real(dist_const[0::tn])) / mean(abs(real(dist_const[0::tn])));
    decl rel_dc_y_dist = mean(imag(dist_const[0::tn])) / mean(abs(imag(dist_const[0::tn])));
    decl mean_dc_delta = (rel_dc_x_ref - rel_dc_x_dist) + j * (rel_dc_y_ref - rel_dc_y_dist);
    if (dc == NULL || slice_flag == 1) 
	dist_const_comp += (rel_dc_x_ref - rel_dc_x_dist) * mean(abs(real(dist_const))) + 
			j * (rel_dc_y_ref - rel_dc_y_dist) * mean(abs(imag(dist_const)));

    // determine scaling (gain/compression) difference between reference and distorted constellations
    // and compensate, unless user directed compensation has already been carried out
    decl mean_gaincomp = mean(mag(ref_const[0::tn])) / mean(mag(dist_const[0::tn]));
    if (gaincomp == NULL || slice_flag == 1) 
	dist_const_comp *= mean_gaincomp;

    decl evm = mag(dist_const_comp[0::tn] - ref_const[0::tn]);
    decl evm_rms = sqrt(mean(evm**2)); 
    decl avgrefmag = mean(mag(ref_const[0::tn]));
    if (avgrefmag < 1e-20) avgrefmag = 1.0;
    decl evm_rms_percent = 100 * evm_rms / avgrefmag;
    decl max_evm_percent = 100 * max(evm) / avgrefmag;
    decl mag_err_percent = 100 * mean(abs(mag(dist_const_comp[0::tn]) - mag(ref_const[0::tn]))) / avgrefmag;
    decl phase_err_deg = mean_phase_delta * 180 / pi;
    decl iq_origin_offset_dB = 10 * log(mag(mean_dc_delta) + 1e-20);

    return list(ref_constellation, ref_trajectory, dist_constellation, dist_trajectory, evm_rms_percent, max_evm_percent, evm, mag_err_percent, phase_err_deg, iq_origin_offset_dB);
}


//*********************************************************************************************************
// 
defun kmm_evm_qpsk(dist_const)
{
    if (dist_const == NULL || sweep_size(dist_const) < 1)  {
	print_function_error("kmm_evm_qpsk","No constellation data.");
	return;
    };
    decl tn = sweep_size(dist_const);
    decl dist_const_real = real(dist_const) + 0.0;
    decl dist_const_imag = imag(dist_const) + 0.0;
    decl ideal_const_real = dist_const_real + 0.0;
    decl ideal_const_imag = dist_const_imag + 0.0;
    decl k;

    // slice the constellation to determine the ideal constellation points
    for (k=0; k < tn; k++) {
	ideal_const_real[k] = (dist_const_real[k] >= 0.0) ? 1.0 : -1.0;
        ideal_const_imag[k] = (dist_const_imag[k] >= 0.0) ? 1.0 : -1.0;
    }        
    decl ideal_const = ideal_const_real + j * ideal_const_imag;

    // find mean phase difference and compensate
    decl phase_delta = phaserad(dist_const_real + j * dist_const_imag)
	             - phaserad(ideal_const_real + j * ideal_const_imag);
    decl phase_unwrapped1 = if (phase_delta < -pi) then (phase_delta + 2 * pi) else phase_delta;
    decl phase_unwrapped = if (phase_unwrapped1 > pi) then (phase_unwrapped1 - 2 * pi) else phase_unwrapped1;
    decl mean_phase_delta = mean(phase_unwrapped);
    dist_const *= exp(-j*mean_phase_delta);

    // find mean dc difference and compensate
    decl mean_dc = mean(dist_const_real + j * dist_const_imag) - 
			mean(ideal_const_real + j * ideal_const_imag);
    dist_const -= mean_dc;

    // determine scaling (gain/compression) and compensate
    decl mean_gaincomp = mean(mag(ideal_const_real + j * ideal_const_imag)) / 
			mean(mag(dist_const_real + j * dist_const_imag));
    dist_const *= mean_gaincomp;

    decl evm = mag(dist_const - ideal_const);
    decl evm_rms = sqrt(mean(evm**2));
    decl evm_percent = 100 * evm_rms / (2**0.5);

    return evm_rms;
}

//*********************************************************************************************************
// 
defun kmm_evm_qpsk_v2(u_dist_const, u_dc, u_rotation, u_gaincomp)
{
    decl dc = u_dc;
    decl rotation = u_rotation;
    decl gaincomp = u_gaincomp;

    if (u_dist_const == NULL || sweep_size(u_dist_const) < 1)  {
	print_function_error("kmm_evm_qpsk_v2","No constellation data.");
	return;
    };

    decl tn = sweep_size(u_dist_const);
    decl dist_const = [u_dist_const] + 0.0;
    decl ideal_const_real = [real(dist_const)] + 0.0;
    decl ideal_const_imag = [imag(dist_const)] + 0.0;
    decl k;

    // slice the constellation to determine the ideal constellation points
    for (k = 0; k < tn; k++) {
	ideal_const_real[k] = (real(dist_const[k]) >= 0.0) ? 1.0 : -1.0;
        ideal_const_imag[k] = (imag(dist_const[k]) >= 0.0) ? 1.0 : -1.0;
    }        
    decl ideal_const = ideal_const_real + j * ideal_const_imag;

    // compensate the distorted constellation using the passed parameter values, if any
    if (rotation != NULL) 
	dist_const *= exp(j * rotation * pi / 180);
    if (dc != NULL) 
	dist_const += mean(abs(real(dist_const))) * real(dc) + j * (mean(abs(imag(dist_const))) * imag(dc));
    if (gaincomp != NULL) 
	dist_const *= gaincomp;

    decl dist_const_comp = [dist_const] + 0.0;

    // find mean phase difference between reference and distorted constellations and compensate, unless
    // user directed compensation has already been carried out
    decl phase_delta = phaserad(dist_const) - phaserad(ideal_const);
    decl phase_unwrapped1 = if (phase_delta < -pi) then (phase_delta + 2 * pi) else phase_delta;
    decl phase_unwrapped = if (phase_unwrapped1 > pi) then (phase_unwrapped1 - 2 * pi) else phase_unwrapped1;
    decl mean_phase_delta = mean(phase_unwrapped);
    if (rotation == NULL) 
	dist_const_comp *= exp(-j * mean_phase_delta);

    // find mean dc offset between reference and distorted constellations and compensate, unless
    // user directed compensation has already been carried out
    decl rel_dc_x_ideal = mean(real(ideal_const)) / mean(abs(real(ideal_const)));
    decl rel_dc_y_ideal = mean(imag(ideal_const)) / mean(abs(imag(ideal_const)));
    decl rel_dc_x_dist = mean(real(dist_const)) / mean(abs(real(dist_const)));
    decl rel_dc_y_dist = mean(imag(dist_const)) / mean(abs(imag(dist_const)));
    decl mean_dc_delta = (rel_dc_x_ideal - rel_dc_x_dist) + j * (rel_dc_y_ideal - rel_dc_y_dist);
    if (dc == NULL) 
	dist_const_comp += (rel_dc_x_ideal - rel_dc_x_dist) * mean(abs(real(dist_const))) + 
			j * (rel_dc_y_ideal - rel_dc_y_dist) * mean(abs(imag(dist_const)));

    // determine scaling (gain/compression) difference between reference and distorted constellations
    // and compensate, unless user directed compensation has already been carried out
    decl mean_gaincomp = mean(mag(ideal_const)) / mean(mag(dist_const));
    if (gaincomp == NULL) 
	dist_const_comp *= mean_gaincomp;

    decl evm = mag(dist_const_comp - ideal_const);
    decl evm_rms = sqrt(mean(evm**2)); 
    decl avgrefmag = mean(mag(ideal_const));
    if (avgrefmag < 1e-20) avgrefmag = 1.0;
    decl evm_rms_percent = 100 * evm_rms / avgrefmag;
    decl max_evm_percent = 100 * max(evm) / avgrefmag;
    decl mag_err_percent = 100 * mean(abs(mag(dist_const_comp) - mag(ideal_const))) / avgrefmag;
    decl phase_err_deg = mean_phase_delta * 180 / pi;
    decl iq_origin_offset_dB = 10 * log(mag(mean_dc_delta) + 1e-20);

    return list(evm_rms_percent, max_evm_percent, evm, mag_err_percent, phase_err_deg, iq_origin_offset_dB);
}

//***********************************************************************************************************
// 
defun const_evm_hpsk_ref(vfund_ref, vfund_dist, u_symbol_rate, u_sample_delay, u_transient_duration, u_path_delay, u_dc, u_rotation, u_gaincomp)
{
    decl k;

    if ( vfund_ref == NULL || vfund_dist == NULL ) {
	print_function_error("const_evm_hpsk","Missing reference and/or distorted envelope data.");
	return;
    }

    decl symbol_rate = u_symbol_rate;
    decl sample_delay = u_sample_delay == NULL ? 0 : u_sample_delay;
    decl transient_duration = u_transient_duration == NULL ? 0 : u_transient_duration;
    decl path_delay = u_path_delay == NULL ? 0 : u_path_delay;
    decl dc = u_dc;
    decl rotation =  u_rotation;
    decl gaincomp = u_gaincomp;
 
    if ( symbol_rate == NULL || symbol_rate == 0)  {
	print_function_error("const_evm_hpsk","The symbol rate must be greater than zero.");
	return;
    }
	 
    decl tran_time = 0;
    if ( transient_duration ) //skip integer number of symbols
      tran_time = ceil(mag(transient_duration)*symbol_rate)/symbol_rate;

    decl vfund_ref_real = real(vfund_ref);
    decl vfund_ref_imag = imag(vfund_ref);

    // generate reference trajectory - start trajectory data after transient duration
    decl time_vector = indep(vfund_ref);
    decl sample_period = time_vector[1] - time_vector[0];
    decl start_index = ceil(tran_time/sample_period);
    decl end_index = sweep_size(vfund_ref_real) - 1;
    decl ref_trajectory = vs(vfund_ref_imag[start_index::end_index], vfund_ref_real[start_index::end_index]);

    // generate reference constellation
    decl start_time = sample_delay + tran_time;
    decl stop_time = max(indep(vfund_ref));
    decl incr = 1/symbol_rate;
    vfund_ref_real = interp(vfund_ref_real, start_time, stop_time, incr);
    vfund_ref_imag = interp(vfund_ref_imag, start_time, stop_time, incr);
    vfund_ref = vfund_ref_real + j * vfund_ref_imag;
    decl ref_constellation = vs(vfund_ref_imag, vfund_ref_real);
    set_attr(ref_constellation,"TraceType","Scatter");

    // sample the distorted signal
    start_time += path_delay;
    stop_time = max(indep(vfund_dist));
    decl vfund_dist_real = interp(real(vfund_dist), start_time, stop_time, incr);
    decl vfund_dist_imag = interp(imag(vfund_dist), start_time, stop_time, incr);
    decl tn = sweep_size(vfund_dist_real);

    tn = min([tn, sweep_size(vfund_ref)]);

    // generate distorted trajectory - prior to compensation
    time_vector = indep(vfund_dist);
    sample_period = time_vector[1] - time_vector[0];
    start_index = ceil(mag(tran_time)/sample_period);
    end_index = sweep_size(vfund_dist) - 1;
    decl dist_trajectory = vs(imag(vfund_dist[start_index::end_index]),real(vfund_dist[start_index::end_index]));

    // use specified values to compensate distorted signal
    if (rotation != NULL) vfund_dist *= exp(j*rotation);
    if (dc != NULL) vfund_dist += dc;
    if (gaincomp != NULL) vfund_dist *= gaincomp;

    // find mean phase difference and compensate, if necessary
    // in other words, the function always returns the phase difference between the reference constellation and 
    //  the uncompensated distorted constellation - if no phase compensation figure is passed to the function
    //  then the distorted constellation is compensated by the mean phase difference, if a phase compensation 
    //  figure is passed to the function, the distorted constellation is compensated using only this figure
    decl phase_delta = phaserad(vfund_dist_real[0::tn-1] +j*vfund_dist_imag[0::tn-1])
	             - phaserad(vfund_ref_real[0::tn-1]+j*vfund_ref_imag[0::tn-1]);
    decl phase_unwrapped1= if (phase_delta < -pi) then (phase_delta+2*pi) else phase_delta;
    decl phase_unwrapped = if (phase_unwrapped1>pi) then phase_unwrapped1 -2*pi else phase_unwrapped1;
    decl mean_phase_delta = mean(phase_unwrapped);
    if (rotation == NULL) vfund_dist *= exp(-j*mean_phase_delta);

    // find mean dc difference and compensate
    decl mean_dc = mean(vfund_dist_real[0::tn-1]) + j * mean(vfund_dist_imag[0::tn-1]) - 
			mean(vfund_ref_real[0::tn-1] + j * vfund_ref_imag[0::tn-1]);
    if (dc == NULL) vfund_dist -= mean_dc;

    // determine scaling (gain/compression) and compensate
    decl mean_gaincomp = mean(mag(vfund_ref_real[0::tn-1] + j * vfund_ref_imag[0::tn-1])) / 
			mean(mag(vfund_dist_real[0::tn-1] + j * vfund_dist_imag[0::tn-1]));
    if (gaincomp == NULL) vfund_dist = vfund_dist * mean_gaincomp;
  
    // resample vfund_dist to get the compensated constellation points
    vfund_dist_real = interp(real(vfund_dist), start_time, stop_time, incr);
    vfund_dist_imag = interp(imag(vfund_dist), start_time, stop_time, incr);
    vfund_dist =  vfund_dist_real + j * vfund_dist_imag;
    decl dist_constellation = vs(imag(vfund_dist), real(vfund_dist));
    set_attr(dist_constellation,"TraceType","Scatter");

    // EVM 
    decl evm = mag(vfund_dist[0::tn-1]-vfund_ref[0::tn-1]);
    decl evm_rms = sqrt(mean(evm**2));
    decl avgrefmag = mean(mag(vfund_ref[0::tn-1]));
    if (avgrefmag < 1e-20) avgrefmag = 1.0;
    decl evm_percent = 100*evm_rms/avgrefmag;

    return list(ref_constellation, ref_trajectory, dist_constellation, dist_trajectory, evm, evm_percent, mean_phase_delta, mean_dc, mean_gaincomp);
}

//***********************************************************************************************************
// 
defun const_evm_hpsk_ref_v2(vfund_ref, vfund_dist, u_symbol_rate, u_sample_delay, u_transient_duration, u_path_delay, u_dc, u_rotation, u_gaincomp)
{
    decl k;

    if ( vfund_ref == NULL || vfund_dist == NULL ) {
	print_function_error("const_evm_hpsk_ref_v2","Missing reference and/or distorted envelope data.");
	return;
    }
    if (indep(vfund_ref,1) == NULL) {
	print_function_error("const_evm_hpsk_ref_v2","No indepedent time data attached to reference envelope data.");
	return;
    }
    if (indep(vfund_dist,1) == NULL) {
	print_function_error("const_evm_hpsk_ref_v2","No indepedent time data attached to distorted envelope data.");
	return;
    }

    decl symbol_rate = u_symbol_rate;
    decl sample_delay = u_sample_delay == NULL ? 0 : u_sample_delay;
    decl transient_duration = u_transient_duration == NULL ? 0 : u_transient_duration;
    decl path_delay = u_path_delay == NULL ? 0 : u_path_delay;
    decl dc = u_dc;
    decl rotation =  u_rotation;
    decl gaincomp = u_gaincomp;
 
    if ( symbol_rate == NULL || symbol_rate == 0)  {
	print_function_error("const_evm_hpsk_ref_v2","The symbol rate must be greater than zero.");
	return;
    }
	 
    decl tran_time = 0;
    if ( transient_duration ) //skip integer number of symbols
      tran_time = ceil(mag(transient_duration)*symbol_rate)/symbol_rate;

    // generate reference trajectory - start trajectory data after transient duration
    decl time_vector = indep(vfund_ref);
    decl sample_period = time_vector[1] - time_vector[0];
    if (sample_period <= 0.0) {
	print_function_error("const_evm_hpsk_ref_v2","Time step of reference envelope time data must be greater than zero.");
	return;
    }
    decl start_index = round(tran_time/sample_period);
    decl end_index = sweep_size(vfund_ref) - 1;
    decl ref_trajectory = vs(imag(vfund_ref[start_index::end_index]), real(vfund_ref[start_index::end_index]));

    // generate reference constellation
    decl start_time = sample_delay + tran_time;
    decl stop_time = max(indep(vfund_ref));
    decl incr = 1/symbol_rate;
    // the interp function only accepts real valued data - the times at which the data is interpolated
    // is attached as an independent to the output data
    decl vfund_ref_real = interp(real(vfund_ref), start_time, stop_time, incr);
    decl vfund_ref_imag = interp(imag(vfund_ref), start_time, stop_time, incr);
    decl ref_constellation = vs(vfund_ref_imag, vfund_ref_real);
    set_attr(ref_constellation,"TraceType","Scatter");

    // sample the distorted signal
    start_time += path_delay;
    stop_time = max(indep(vfund_dist));
    decl vfund_dist_real = interp(real(vfund_dist), start_time, stop_time, incr);
    decl vfund_dist_imag = interp(imag(vfund_dist), start_time, stop_time, incr);

    // generate distorted trajectory - prior to compensation
    time_vector = indep(vfund_dist);
    sample_period = time_vector[1] - time_vector[0];
    if (sample_period <= 0.0) {
	print_function_error("const_evm_hpsk_ref_v2","Time step of distorted envelope time data must be greater than zero.");
	return;
    }
    start_index = round(mag(tran_time)/sample_period);
    end_index = sweep_size(vfund_dist) - 1;
    decl dist_trajectory = vs(imag(vfund_dist[start_index::end_index]),real(vfund_dist[start_index::end_index]));

    decl tn = min([sweep_size(vfund_ref_real), sweep_size(vfund_dist_real)]);
    decl vfund_ref_samp = [vfund_ref_real[0::tn-1]] + j * [vfund_ref_imag[0::tn-1]];
    decl vfund_dist_samp = [vfund_dist_real[0::tn-1]] + j * [vfund_dist_imag[0::tn-1]];


    // apply the user specified parameters, if any, to compensate the distorted signal
    if (rotation != NULL) 
	vfund_dist_samp *= exp(j * rotation * pi / 180);
    if (dc != NULL) 
	vfund_dist_samp += mean(abs(real(vfund_dist_samp))) * real(dc) + 
				j * (mean(abs(imag(vfund_dist_samp))) * imag(dc));
    if (gaincomp != NULL)
	vfund_dist_samp *= gaincomp;

    decl vfund_dist_samp_comp = [vfund_dist_samp] + 0.0;

    // find mean phase difference and compensate, if necessary
    // in other words, the function always returns the phase difference between the reference constellation and 
    //  the uncompensated distorted constellation - if no phase compensation figure is passed to the function
    //  then the distorted constellation is compensated by the mean phase difference, if a phase compensation 
    //  figure is passed to the function, the distorted constellation is compensated using only this figure

    decl phase_delta = phaserad(vfund_dist_samp) - phaserad(vfund_ref_samp);
    decl phase_unwrapped1= if (phase_delta < -pi) then (phase_delta + 2 * pi) else phase_delta;
    decl phase_unwrapped = if (phase_unwrapped1>pi) then phase_unwrapped1 -2 * pi else phase_unwrapped1;
    decl mean_phase_delta = mean(phase_unwrapped);
    if (rotation == NULL) vfund_dist_samp_comp *= exp(-j * mean_phase_delta);

    // find mean dc offset between reference and distorted constellations and compensate, unless
    // user directed compensation has already been carried out
    decl divchk = mean(abs(real(vfund_ref_samp)));
    if (divchk <= 0.0) divchk = 1.0;
    decl rel_dc_x_ideal = mean(real(vfund_ref_samp)) / divchk;
    divchk = mean(abs(imag(vfund_ref_samp)));
    if (divchk <= 0.0) divchk = 1.0;
    decl rel_dc_y_ideal = mean(imag(vfund_ref_samp)) / divchk;
    divchk = mean(abs(real(vfund_dist_samp)));
    if (divchk <= 0.0) divchk = 1.0;
    decl rel_dc_x_dist = mean(real(vfund_dist_samp)) / divchk;
    divchk = mean(abs(imag(vfund_dist_samp)));
    if (divchk <= 0.0) divchk = 1.0;
    decl rel_dc_y_dist = mean(imag(vfund_dist_samp)) / divchk;
    decl mean_dc_delta = (rel_dc_x_ideal - rel_dc_x_dist) + j * (rel_dc_y_ideal - rel_dc_y_dist);
    if (dc == NULL)
    	vfund_dist_samp_comp += (rel_dc_x_ideal - rel_dc_x_dist) * mean(abs(real(vfund_dist_samp))) + 
	 			j * (rel_dc_y_ideal - rel_dc_y_dist) * mean(abs(imag(vfund_dist_samp)));

    // determine scaling (gain/compression) difference between reference and distorted constellations
    // and compensate, unless user directed compensation has already been carried out
    divchk = mean(mag(vfund_dist_samp));
    if (divchk <= 0.0) divchk = 1.0;
    decl mean_gaincomp = mean(mag(vfund_ref_samp)) / divchk;
    if (gaincomp == NULL)
	    vfund_dist_samp_comp *= mean_gaincomp;

    // return the compensated constellation points
    decl dist_constellation = vs(imag(vfund_dist_samp_comp), real(vfund_dist_samp_comp));
    set_attr(dist_constellation,"TraceType","Scatter");

    decl evm = mag(vfund_dist_samp_comp - vfund_ref_samp);
    decl evm_rms = sqrt(mean(evm**2)); 
    decl avgrefmag = mean(mag(vfund_ref_samp));
    if (avgrefmag < 1e-20) avgrefmag = 1.0;
    decl evm_rms_percent = 100 * evm_rms / avgrefmag;
    decl max_evm_percent = 100 * max(evm) / avgrefmag;
    decl mag_err_percent = 100 * mean(abs(mag(vfund_dist_samp_comp) - mag(vfund_ref_samp))) / avgrefmag;
    decl phase_err_deg = mean_phase_delta * 180 / pi;
    decl iq_origin_offset_dB = 10 * log(mag(mean_dc_delta) + 1e-20);

    return list(ref_constellation, ref_trajectory, dist_constellation, dist_trajectory, evm_rms_percent,
		max_evm_percent, evm, mag_err_percent, phase_err_deg, iq_origin_offset_dB);
}

//*********************************************************************************************************
// 
defun kmm_evm_hpsk(ideal_const, dist_const, u_dc, u_rotation, u_gaincomp)
{
    decl dc = u_dc;
    decl rotation =  u_rotation;
    decl gaincomp = u_gaincomp;
    decl tn = sweep_size(ideal_const);
    decl dn = sweep_size(dist_const);

    if (ideal_const == NULL || tn < 1)  {
	print_function_error("kmm_evm_hpsk","No ideal constellation data.");
	return;
    }
    if (dist_const == NULL || dn < 1)  {
	print_function_error("kmm_evm_hpsk","No distorted constellation data.");
	return;
    }
    if (tn != dn) 
	tn = min([tn, dn]);

    decl ideal_const_real = real(ideal_const[0::tn-1]) + 0.0;
    decl ideal_const_imag = imag(ideal_const[0::tn-1]) + 0.0;
    decl dist_const_real = real(dist_const[0::tn-1]) + 0.0;
    decl dist_const_imag = imag(dist_const[0::tn-1]) + 0.0;

    // find mean phase difference between uncompensated distorted constellation and compensate 
    decl phase_delta = phaserad(dist_const_real + j * dist_const_imag)
	             - phaserad(ideal_const_real + j * ideal_const_imag);
    decl phase_unwrapped1 = if (phase_delta < -pi) then (phase_delta + 2 * pi) else phase_delta;
    decl phase_unwrapped = if (phase_unwrapped1 > pi) then (phase_unwrapped1 - 2 * pi) else phase_unwrapped1;
    decl mean_phase_delta = mean(phase_unwrapped);
    if (rotation != NULL) 
	dist_const *= exp(j*rotation);
    else
	dist_const *= exp(-j * mean_phase_delta);

    // find mean dc difference and compensate 
    decl mean_dc = mean(dist_const_real + j * dist_const_imag) - 
			mean(ideal_const_real + j * ideal_const_imag);
    if (dc != NULL) 
	dist_const += dc;
    else
	dist_const -= mean_dc;

    // determine scaling (gain/compression) and compensate 
    decl mean_gaincomp = mean(mag(ideal_const_real + j * ideal_const_imag)) / 
			mean(mag(dist_const_real + j * dist_const_imag));
    if (gaincomp != NULL) 
	dist_const *= gaincomp;
    else
	dist_const *= mean_gaincomp;

    decl evm = mag(dist_const[0::tn-1] - ideal_const[0::tn-1]);
    decl evm_rms = sqrt(mean(evm**2)); 
    decl avgrefmag = mean(mag(ideal_const[0::tn-1]));
    if (avgrefmag < 1e-20) avgrefmag = 1.0;
    decl evm_percent = 100 * evm_rms/ avgrefmag;

    return list(evm, evm_rms, mean_phase_delta, mean_dc, mean_gaincomp);
}

//*********************************************************************************************************
// 
defun kmm_evm_hpsk_v2(u_ideal_const, u_dist_const, u_dc, u_rotation, u_gaincomp)
{
    decl dc = u_dc;
    decl rotation =  u_rotation;
    decl gaincomp = u_gaincomp;
    decl tn = sweep_size(u_ideal_const);
    decl dn = sweep_size(u_dist_const);

    if (u_ideal_const == NULL || tn < 1)  {
	print_function_error("kmm_evm_hpsk_v2","No ideal constellation data.");
	return;
    }
    if (u_dist_const == NULL || dn < 1)  {
	print_function_error("kmm_evm_hpsk_v2","No distorted constellation data.");
	return;
    }
    if (tn != dn) 
	tn = min([tn, dn]);

    decl ideal_const = [u_ideal_const[0::tn-1]] + 0.0;
    decl dist_const = [u_dist_const[0::tn-1]] + 0.0;

    // compensate the distorted constellation using the passed parameter values, if any
    if (rotation != NULL) 
	dist_const *= exp(j * rotation * pi / 180);
    if (dc != NULL) 
	dist_const += mean(abs(real(dist_const))) * real(dc) + j * (mean(abs(imag(dist_const))) * imag(dc));
    if (gaincomp != NULL) 
	dist_const *= gaincomp;

    decl dist_const_comp = [dist_const] + 0.0;

    // find mean phase difference between reference and distorted constellations and compensate, unless
    // user directed compensation has already been carried out
    decl phase_delta = phaserad(dist_const) - phaserad(ideal_const);
    decl phase_unwrapped1 = if (phase_delta < -pi) then (phase_delta + 2 * pi) else phase_delta;
    decl phase_unwrapped = if (phase_unwrapped1 > pi) then (phase_unwrapped1 - 2 * pi) else phase_unwrapped1;
    decl mean_phase_delta = mean(phase_unwrapped);
    if (rotation == NULL) 
	dist_const_comp *= exp(-j * mean_phase_delta);

    // find mean dc offset between reference and distorted constellations and compensate, unless
    // user directed compensation has already been carried out
    decl divchk = mean(abs(real(ideal_const)));
    if (divchk <= 0.0) divchk = 1.0;
    decl rel_dc_x_ideal = mean(real(ideal_const)) / divchk;
    divchk = mean(abs(imag(ideal_const)));
    if (divchk <= 0.0) divchk = 1.0;
    decl rel_dc_y_ideal = mean(imag(ideal_const)) / divchk;
    divchk = mean(abs(real(dist_const)));
    if (divchk <= 0.0) divchk = 1.0;
    decl rel_dc_x_dist = mean(real(dist_const)) / divchk;
    divchk = mean(abs(imag(dist_const)));
    if (divchk <= 0.0) divchk = 1.0;
    decl rel_dc_y_dist = mean(imag(dist_const)) / divchk;
    decl mean_dc_delta = (rel_dc_x_ideal - rel_dc_x_dist) + j * (rel_dc_y_ideal - rel_dc_y_dist);
    if (dc == NULL)
    	dist_const_comp += (rel_dc_x_ideal - rel_dc_x_dist) * mean(abs(real(dist_const))) + 
	 			j * (rel_dc_y_ideal - rel_dc_y_dist) * mean(abs(imag(dist_const)));

    // determine scaling (gain/compression) difference between reference and distorted constellations
    // and compensate, unless user directed compensation has already been carried out
    divchk = mean(mag(dist_const));
    if (divchk <= 0.0) divchk = 1.0;
    decl mean_gaincomp = mean(mag(ideal_const)) / divchk;
    if (gaincomp == NULL)
	    dist_const_comp *= mean_gaincomp;

    decl evm = mag(dist_const_comp - ideal_const);
    decl evm_rms = sqrt(mean(evm**2)); 
    decl avgrefmag = mean(mag(ideal_const));
    if (avgrefmag < 1e-20) avgrefmag = 1.0;
    decl evm_rms_percent = 100 * evm_rms / avgrefmag;
    decl max_evm_percent = 100 * max(evm) / avgrefmag;
    decl mag_err_percent = 100 * mean(abs(mag(dist_const_comp) - mag(ideal_const))) / avgrefmag;
    decl phase_err_deg = mean_phase_delta * 180 / pi;
    decl iq_origin_offset_dB = 10 * log(mag(mean_dc_delta) + 1e-20);

    return list(evm_rms_percent, max_evm_percent, evm, mag_err_percent, phase_err_deg, iq_origin_offset_dB);
}

//*********************************************************************************************************

defun kmm_dehop(venv, u_symbolrate, u_framestart, u_mobileallocation, u_channelspacing, u_hoppingsequencenumber, u_mobileallocationoffset)
{
	if ( venv == NULL ) {
		print_function_error("kmm_dehop", "No envelope data.");
		return;
	}

	if (indep(venv,1) == NULL) {
		print_function_error("kmm_dehop", "No indepedent time data attached to envelope data.");
		return;
	}

	decl symbol_rate = u_symbolrate;
	decl frame_start = u_framestart == NULL ? 0 : u_framestart;
	decl kmm_MA = u_mobileallocation == NULL ? 0 : u_mobileallocation;
	decl kmm_chanspac = u_channelspacing == NULL ? 1.0 : u_channelspacing;
	decl kmm_HSN = u_hoppingsequencenumber == NULL ? 0 : u_hoppingsequencenumber;
	decl kmm_MAIO = u_mobileallocationoffset == NULL ? 0 : u_mobileallocationoffset;
   
	if ( symbol_rate == NULL || symbol_rate <= 0)  {
		print_function_error("kmm_dehop", "The symbol rate must be greater than zero.");
		return;
	}
	if (kmm_MA < 1) {
		print_function_error("kmm_dehop", "Mobile RF channel allocation must be greater than 0.");
		return;
	} else if (kmm_MA == 1) {
		return venv;
	}	

	if (kmm_chanspac < 1) {
		kmm_chanspac = 1.0;
	} 

	if (kmm_HSN < 0) {
		kmm_HSN = 0;
	} else if (kmm_HSN > 63) {
		kmm_HSN = 63;
	}

	if (kmm_MAIO < 0) {
		kmm_MAIO = 0;
	} else if (kmm_MAIO >= kmm_MA) {
		kmm_MAIO = kmm_MA - 1;
	}
	
	decl slot_syms = 156.25;
	decl active_syms = 148;
	decl frame_syms = 1250; 

	decl time_vector = indep(venv);
	decl sample_period = time_vector[1] - time_vector[0];
	if (sample_period <= 0.0) {
		print_function_error("kmm_dehop","Time step of envelope data must be greater than zero.");
		return;
	}
	decl samples_per_symbol = round(1 / (sample_period * symbol_rate));
	decl total_frames = (time_vector[sweep_size(time_vector) - 1] - frame_start) / (frame_syms * samples_per_symbol * sample_period);

    // assume that the first frame is frame zero
    // see sections xx.xx of xxxx

	decl k;
	decl frame_number;
	decl new_venv = venv + 0.0;
	decl start = round(frame_start / sample_period);
	decl moredata = TRUE;
	decl start_index;
	decl end_index;
	decl frame_count = 0;
	frame_number = 0;
	decl max_index = sweep_size(venv) - 1;
	decl kmm_MAI = 0;
	decl kmm_RFCN = 0;
	decl kfreq = 200.0e3 * kmm_chanspac;

	while (moredata) {
		start_index = start + frame_count * frame_syms * samples_per_symbol;
		end_index = start_index + frame_syms * samples_per_symbol - 1;
		if (end_index > max_index) {
			end_index = max_index;
			moredata = FALSE;
		}

		kmm_MAI = kmm_freq_hop(frame_number, kmm_MA, kmm_HSN, kmm_MAIO);
		kmm_RFCN = (kmm_rem(kmm_MA, 2) == 0.0) ? (kmm_MAI - kmm_MA / 2) : (kmm_MAI - fix(kmm_MA / 2));
		new_venv[start_index::end_index] = new_venv[start_index::end_index] .* exp(-j * time_vector[start_index::end_index] * kfreq * kmm_RFCN * 2.0 * pi);
		frame_count += 1;
		frame_number += 1;
	}

	return new_venv;
}

//*********************************************************************************************************

defun kmm_dbugout_a(kmm_str)
{
	decl fid;
	fid = fopen("E:\\users\\kmmekech\\aeldbug.txt", "A");
	fputs(fid, kmm_str);
	fclose(fid);
}

//*********************************************************************************************************

defun kmm_dbugout_n(kmm_str)
{
	decl fid;
	fid = fopen("E:\\users\\kmmekech\\aeldbug.txt", "W");
	fputs(fid, kmm_str);
	fclose(fid);
}

//*********************************************************************************************************

defun kmm_rem(x, y)
{
	if (x == NULL || y == NULL) 
		return NULL;

	return (x - y * fix(x / y));
}

//*********************************************************************************************************

defun kmm_freq_hop(u_frame_number, u_kmm_N, u_kmm_HSN, u_kmm_MAIO)
{
	decl frame_number = round(u_frame_number);
	decl kmm_N = round(u_kmm_N);
	decl kmm_HSN = round(u_kmm_HSN);
	decl kmm_MAIO = round(u_kmm_MAIO);

	decl rntable = [48, 98, 63, 1, 36, 95, 78, 102, 94, 73,
			0, 64, 25, 81, 76, 59, 124, 23, 104, 100, 
			101, 47, 118, 85, 18, 56, 96, 86, 54, 2,
			80, 34, 127, 13, 6, 89, 57, 103, 12, 74,
			55, 111, 75, 38, 109, 71, 112, 29, 11, 88,
			87, 19, 3, 68, 110, 26, 33, 31, 8, 45,
			82, 58, 40, 107, 32, 5, 106, 92, 62, 67,
			77, 108, 122, 37, 60, 66, 121, 42, 51, 126,
			117, 114, 4, 90, 43, 52, 53, 113, 120, 72,
			16, 49, 7, 79, 119, 61, 22, 84, 9, 97,
			91, 15, 21, 24, 46, 39, 93, 105, 65, 70,
			125, 99, 17, 123];

	// determine the number of bits needed to represent kmm_N = int(log(base 2)N + 1)
	decl kmm_NBIN = 0;
	decl x = 0;

	do {
		kmm_NBIN++;
		x = 2**kmm_NBIN;
	} while (x <= kmm_N);
	
	if (kmm_HSN == 0) {
		return kmm_rem((frame_number + kmm_MAIO), kmm_N);
	}

	decl kmm_T1 = int(frame_number / (26 * 51));
	decl kmm_T1R = kmm_rem(kmm_T1, 64);
	decl kmm_T2 = kmm_rem(frame_number, 26);
	decl kmm_T3 = kmm_rem(frame_number, 51);
	decl kmm_T3p = int((kmm_T3 - 1) / 10);
	decl kmm_M = kmm_T2 + rntable[int(xor(kmm_HSN, kmm_T1R) + kmm_T3)];
	decl kmm_Mp = kmm_rem(kmm_M, 2**kmm_NBIN);
	decl kmm_Tp = kmm_rem(kmm_T3, 2**kmm_NBIN);
	decl kmm_S = 0;

	if (kmm_Mp < kmm_N) {
		kmm_S = kmm_Mp;
	} else {
		kmm_S = kmm_rem((kmm_Mp + kmm_Tp), kmm_N);
	}

	return kmm_rem((kmm_S + kmm_MAIO), kmm_N);
}

//*********************************************************************************************************

defun kmm_gsm_8psk_const_evm(vfund_ref, vfund_dist, u_symbol_rate, u_frame_start, u_sample_delay, u_path_delay, u_slot_usage)
{
    decl k;

    if ( vfund_ref == NULL || vfund_dist == NULL ) {
	print_function_error("kmm_gsm_8psk_const_evm","Missing reference and/or distorted envelope data.");
	return;
    }
    if (indep(vfund_ref,1) == NULL) {
	print_function_error("kmm_gsm_8psk_const_evm","No indepedent time data attached to reference envelope data.");
	return;
    }
    if (indep(vfund_dist,1) == NULL) {
	print_function_error("kmm_gsm_8psk_const_evm","No indepedent time data attached to distorted envelope data.");
	return;
    }
    if (u_slot_usage == NULL || sweep_size(u_slot_usage) != 8) {
	print_function_error("kmm_gsm_8psk_const_evm","Please specify which time slots to monitor.");
	return;
    }

    decl symbol_rate = u_symbol_rate;
    decl slot_usage = u_slot_usage;
    decl sample_delay = u_sample_delay == NULL ? 0 : u_sample_delay;
    decl frame_start = u_frame_start == NULL ? 0 : u_frame_start;
    decl path_delay = u_path_delay == NULL ? 0 : u_path_delay;

    if ( symbol_rate == NULL || symbol_rate <= 0)  {
	print_function_error("kmm_gsm_8psk_const_evm","The symbol rate must be greater than zero.");
	return;
    }

    if (sum(slot_usage) <= 0) {
	print_function_error("kmm_gsm_8psk_const_evm","Please specify at least one time slot to monitor.");
	return;
    }
    for (k = 0; k < 8; k++) {
	if (slot_usage[k] != 0) slot_usage[k] = 1;
    }
	
    decl slot_syms = 156.25;
    decl active_syms = 148;
    decl evm_syms = 142;
    decl frame_syms = 1250;

    // 
    decl time_vector = indep(vfund_ref);
    decl sample_period = time_vector[1] - time_vector[0];
    if (sample_period <= 0.0) {
	print_function_error("kmm_gsm_8psk_const_evm","Time step of reference envelope data must be greater than zero.");
	return;
    }
    decl samples_per_symbol = round(1 / (sample_period * symbol_rate));
    // add 8.25 symbol periods as the envelope data may end during the time gap of the last slot of the frame
    decl total_frames = (time_vector[sweep_size(time_vector) - 1] - frame_start + (8.25 * samples_per_symbol * sample_period)) / (frame_syms * samples_per_symbol * sample_period);
    decl fractional_frame_slots = int(total_frames * 8.0)%8;
    decl total_slots = int(total_frames * 8.0);
    decl active_slots = int(total_frames) * sum(slot_usage);
    if (fractional_frame_slots > 0) {
	for (k = 0; k < fractional_frame_slots; k++) {
	    if (slot_usage[k] > 0) {
		active_slots += 1;
	    }
	}
    }

    decl tail_sym_samps = 3 * samples_per_symbol;
    decl incr = 1/symbol_rate;
    decl dummy_samp;
    decl dummy_real;
    decl dummy_imag;
    decl start_index;
    decl slot_start_index;
    decl slot_end_index;
    decl slot_start_time;
    decl slot_end_time;
    decl slot_count = 0;
    decl slotnum = 1.0*[0::(active_slots - 1)];
    decl symnum = 1.0*[0::(evm_syms - 1)];
    decl kconst = create(2, "Complex", {"slotnum", "symnum"}, {"Real", "Real"}, 1, 1);
    decl kconstind1 = indep(kconst, "slotnum");
    decl kconstind2 = indep(kconst, "symnum");
    decl slottime = sample_period * [0::(samples_per_symbol * active_syms)];
    decl ktraj = create(2, "Complex", {"slotnum", "slottime"}, {"Real", "Real"}, 1, 1);
    decl ktrajind1 = indep(ktraj, "slotnum");
    decl ktrajind2 = indep(ktraj, "slottime");

    for (k = 0; k < active_slots; k++) {
	kconstind1[k] = slotnum[k];
	ktrajind1[k] = slotnum[k];
    }
    slot_count = 0;
    start_index = round(frame_start/sample_period);
    dummy_samp = 0;
    for (k = 0; k < total_slots; k++) {
	if (slot_usage[k%8] > 0) {
		slot_start_index = start_index + (slot_syms * samples_per_symbol * k);
		if (sample_delay != 0.0) {
			slot_end_index = slot_start_index + (active_syms * samples_per_symbol);
		} else {
			slot_end_index = slot_start_index + ((active_syms - 1) * samples_per_symbol);
		}
		ktraj[slot_count,::] = [vfund_ref[slot_start_index::slot_end_index]];
		dummy_real = interp(real(vfund_ref), time_vector[slot_start_index + tail_sym_samps] + sample_delay, time_vector[slot_end_index - tail_sym_samps], incr);
		dummy_imag = interp(imag(vfund_ref), time_vector[slot_start_index + tail_sym_samps] + sample_delay, time_vector[slot_end_index - tail_sym_samps], incr);
		kconst[slot_count,::] = [dummy_real[::] + j * dummy_imag[::]];
		dummy_samp = [dummy_samp,[dummy_real[::] + j * dummy_imag[::]]];
		slot_count++;
	}
    }

    for (k = 0; k < evm_syms; k++) {
	kconstind2[k] = symnum[k];
    }
    for (k = 0; k < (samples_per_symbol * active_syms + 1); k++) {
	ktrajind2[k] = slottime[k];
    }
    decl ref_constellation = kconst;
    decl ref_trajectory = ktraj;
    decl vfund_ref_samp = dummy_samp[1::(sweep_size(dummy_samp) - 1)] + 0.0;

    time_vector = indep(vfund_dist);
    // add 8.25 symbol periods as the envelope data may end during the time gap of the last slot of the last frame
    total_frames = (time_vector[sweep_size(time_vector) - 1] - (frame_start + path_delay) + (8.25 * samples_per_symbol * sample_period)) / (frame_syms * samples_per_symbol * sample_period);
    fractional_frame_slots = round(((total_frames * 8.0) - int(total_frames * 8.0)) * 8.0);
    total_slots = int(total_frames * 8.0);
    active_slots = int(total_frames) * sum(slot_usage);
    if (fractional_frame_slots > 0) {
	for (k = 0; k < fractional_frame_slots; k++) {
	    if (slot_usage[k] > 0) {
		active_slots += 1;
	    }
	}
    }

    slotnum = 1.0*[0::(active_slots - 1)];
    symnum = 1.0*[0::(evm_syms - 1)];
    kconst = create(2, "Complex", {"slotnum", "symnum"}, {"Real", "Real"}, 1, 1);
    kconstind1 = indep(kconst, "slotnum");
    kconstind2 = indep(kconst, "symnum");

    slottime = sample_period * [0::(samples_per_symbol * active_syms)];
    ktraj = create(2, "Complex", {"slotnum", "slottime"}, {"Real", "Real"}, 1, 1);
    ktrajind1 = indep(ktraj, "slotnum");
    ktrajind2 = indep(ktraj, "slottime");

    for (k = 0; k < active_slots; k++) {
	kconstind1[k] = slotnum[k];
	ktrajind1[k] = slotnum[k];
    }

    slot_count = 0;
    start_index = round((frame_start + path_delay)/sample_period);
    dummy_samp = 0;
    for (k = 0; k < total_slots; k++) {
	if (slot_usage[k%8] > 0) {
		slot_start_index = start_index + (slot_syms * samples_per_symbol * k);
		if (sample_delay != 0.0) {
			slot_end_index = slot_start_index + (active_syms * samples_per_symbol);
		} else {
			slot_end_index = slot_start_index + ((active_syms - 1) * samples_per_symbol);
		}
		ktraj[slot_count,::] = [vfund_dist[slot_start_index::slot_end_index]];
		dummy_real = interp(real(vfund_dist), time_vector[slot_start_index + tail_sym_samps] + sample_delay, time_vector[slot_end_index - tail_sym_samps], incr);
		dummy_imag = interp(imag(vfund_dist), time_vector[slot_start_index + tail_sym_samps] + sample_delay, time_vector[slot_end_index - tail_sym_samps], incr);
		kconst[slot_count,::] = [dummy_real[::] + j * dummy_imag[::]];
		dummy_samp = [dummy_samp,[dummy_real[::] + j * dummy_imag[::]]];
		slot_count++;
	}
    }

    for (k = 0; k < evm_syms; k++) {
	kconstind2[k] = symnum[k];
    }
    for (k = 0; k < (samples_per_symbol * active_syms + 1); k++) {
	ktrajind2[k] = slottime[k];
    }

    decl dist_trajectory = ktraj;
    decl vfund_dist_samp = dummy_samp[1::(sweep_size(dummy_samp) - 1)] + 0.0;


    decl rn = sweep_size(vfund_ref_samp);
    decl dn = sweep_size(vfund_dist_samp);
    if (rn != dn) {
	if (rn > dn) {
		vfund_ref_samp = vfund_ref_samp[0::(dn - 1)];
	} else {
		vfund_dist_samp = vfund_dist_samp[0::(rn - 1)];
	}
    }
    decl vfund_dist_samp_comp = vfund_dist_samp + 0.0;

    // find mean phase difference and compensate, if necessary
    // in other words, the function always returns the phase difference between the reference constellation and 
    //  the uncompensated distorted constellation - if no phase compensation figure is passed to the function
    //  then the distorted constellation is compensated by the mean phase difference, if a phase compensation 
    //  figure is passed to the function, the distorted constellation is compensated using only this figure

    decl phase_delta = phaserad(vfund_dist_samp) - phaserad(vfund_ref_samp);
    decl phase_unwrapped1= if (phase_delta < -pi) then (phase_delta + 2 * pi) else phase_delta;
    decl phase_unwrapped = if (phase_unwrapped1 > pi) then phase_unwrapped1 -2 * pi else phase_unwrapped1;
    decl mean_phase_delta = mean(phase_unwrapped);
    vfund_dist_samp_comp *= exp(-j * mean_phase_delta);

    // find mean dc offset between reference and distorted constellations and compensate, unless
    // user directed compensation has already been carried out
    decl divchk = mean(abs(real(vfund_ref_samp)));
    if (divchk <= 0.0) divchk = 1.0;
    decl rel_dc_x_ideal = mean(real(vfund_ref_samp)) / divchk;
    divchk =  mean(abs(imag(vfund_ref_samp)));
    if (divchk <= 0.0) divchk = 1.0;
    decl rel_dc_y_ideal = mean(imag(vfund_ref_samp)) / divchk;
    divchk = mean(abs(real(vfund_dist_samp)));
    if (divchk <= 0.0) divchk = 1.0;
    decl rel_dc_x_dist = mean(real(vfund_dist_samp)) / divchk;
    divchk = mean(abs(imag(vfund_dist_samp)));
    if (divchk <= 0.0) divchk = 1.0;
    decl rel_dc_y_dist = mean(imag(vfund_dist_samp)) / divchk;
    decl mean_dc_delta = (rel_dc_x_ideal - rel_dc_x_dist) + j * (rel_dc_y_ideal - rel_dc_y_dist);
    vfund_dist_samp_comp += (rel_dc_x_ideal - rel_dc_x_dist) * mean(abs(real(vfund_dist_samp))) + 
	 		j * (rel_dc_y_ideal - rel_dc_y_dist) * mean(abs(imag(vfund_dist_samp)));

    // determine scaling (gain/compression) difference between reference and distorted constellations
    // and compensate, unless user directed compensation has already been carried out
    divchk = mean(mag(vfund_dist_samp));
    if (divchk <= 0.0) divchk = 1.0;
    decl mean_gaincomp = mean(mag(vfund_ref_samp)) / divchk;
    vfund_dist_samp_comp *= mean_gaincomp;
  
    for (k = 0; k < (sweep_size(vfund_dist_samp_comp) / evm_syms); k++) {	
	kconst[k,::] = vfund_dist_samp_comp[int(k * evm_syms)::int((k + 1) * evm_syms - 1)];
    }
    decl dist_constellation = kconst;

    decl evm = mag(vfund_dist_samp_comp - vfund_ref_samp);
    decl evm_rms = sqrt(mean(evm**2)); 
    decl avgrefmag = mean(mag(vfund_ref_samp));
    if (avgrefmag < 1e-20) avgrefmag = 1.0;
    decl evm_rms_percent = 100 * evm_rms / avgrefmag;
    decl max_evm_percent = 100 * max(evm) / avgrefmag;
    decl mag_err_percent = 100 * mean(abs(mag(vfund_dist_samp_comp) - mag(vfund_ref_samp))) / avgrefmag;
    decl phase_err_deg = mean_phase_delta * 180 / pi;
    decl iq_origin_offset_dB = 10 * log(mag(mean_dc_delta) + 1e-20);

    return list(ref_constellation, ref_trajectory, dist_constellation, dist_trajectory, evm_rms_percent,
		max_evm_percent, evm, mag_err_percent, phase_err_deg, iq_origin_offset_dB);

}

//*********************************************************************************************************

defun kmm_gsm_gmsk_const_evm_v2(vfund_ref, vfund_dist, u_receive_filter, u_symbol_rate, u_frame_start, u_sample_delay, u_path_delay, u_slot_usage, u_TSC_number)
{
    decl k;

    if ( vfund_ref == NULL || vfund_dist == NULL ) {
	print_function_error("kmm_gsm_gmsk_const_evm_v2","Missing reference and/or distorted envelope data.");
	return;
   }
    if (indep(vfund_ref,1) == NULL) {
	print_function_error("kmm_gsm_gmsk_const_evm_v2","No indepedent time data attached to reference envelope data.");
	return;
    }
    if (indep(vfund_dist,1) == NULL) {
	print_function_error("kmm_gsm_gmsk_const_evm_v2","No indepedent time data attached to distorted envelope data.");
	return;
    }
    if (u_slot_usage == NULL || sweep_size(u_slot_usage) != 8) {
	print_function_error("kmm_gsm_gmsk_const_evm_v2","Please specify which time slots to monitor.");
	return;
    }

    decl symbol_rate = u_symbol_rate;
    decl slot_usage = u_slot_usage;
    decl receive_filter = u_receive_filter == NULL ? 0 : round(u_receive_filter);
    decl sample_delay = u_sample_delay == NULL ? 0.0 : real(u_sample_delay);
    decl frame_start = u_frame_start == NULL ? 0.0 : real(u_frame_start);
    decl path_delay = u_path_delay == NULL ? 0.0 : real(u_path_delay);
    decl TSC_number = u_TSC_number == NULL ? 0 : round(u_TSC_number);

    if ( symbol_rate == NULL || symbol_rate <= 0)  {
	print_function_error("kmm_gsm_gmsk_const_evm_v2","The symbol rate must be greater than zero.");
	return;
    }

    if (sum(mag(slot_usage)) <= 0) {
	print_function_error("kmm_gsm_gmsk_const_evm_v2","Please specify which of the eight time slots to monitor.");
	return;
    }

    for (k = 0; k < 8; k++) {
	if (slot_usage[k] != 0) slot_usage[k] = 1;
    }
    if (TSC_number < 0 || TSC_number > 7) TSC_number = 0;
    decl slot_syms = 156.25;
    decl active_syms = 148;
    decl evm_syms = 142;
    decl frame_syms = 1250;
    decl TSC = kmm_get_gmsk_TSC(TSC_number);
    decl prior_data_bit = 0;
    decl TSC_enc = TSC + 0;
    for (k = 0; k < sweep_size(TSC); k++) {
	if (k == 0) 
		TSC_enc[k] = (prior_data_bit != TSC[k]) ? 1 : 0;
	else 
		TSC_enc[k] = (TSC[k] != TSC[k-1]) ? 1 : 0;
    }   
    decl TSC_ph = pi / 2 * (1.0 - 2.0 * TSC_enc);
    decl init_phase = pi / 4;
    TSC_ph = cum_sum(TSC_ph) + init_phase;
    decl TSC_syms = TSC_ph * (1 + j);
    for (k = 0; k < sweep_size(TSC_ph); k++) {
	TSC_syms[k] = cos(TSC_ph[k]) + j * sin(TSC_ph[k]);
    }


    decl time_vector = indep(vfund_ref);
    decl sample_period = time_vector[1] - time_vector[0];
    if (sample_period <= 0.0) {
	print_function_error("kmm_gsm_gmsk_const_evm_v2","Time step of reference envelope data must be greater than zero.");
	return;
    }
    decl samples_per_symbol = round(1 / (sample_period * symbol_rate));
    decl incr = 1.0 / symbol_rate;
    decl tail_sym_samps = 3 * samples_per_symbol;

    // filter both the reference and distorted envelopes, if selected
    decl vref;
    decl vdist;
    decl filter_delay = 0.0;
    decl rate_index = 1;
    if (samples_per_symbol == 16) {
	rate_index = 3;
    } else {
	if (samples_per_symbol == 8) {
		rate_index = 2;
	}
    }
    decl filter_coef;
    receive_filter = 0;
    switch (receive_filter) {
	case 1:
		filter_coef = kmm_filtcoef(1 + rate_index);
		vref = kmm_filt(vfund_ref, filter_coef);
		vdist = kmm_filt(vfund_dist, filter_coef);
		filter_delay = int(sweep_size(filter_coef) / 2);
		break;
	case 2:
		filter_coef = kmm_filtcoef(4 + rate_index);
		vref = kmm_filt(vfund_ref, filter_coef);
		vdist = kmm_filt(vfund_dist, filter_coef);
		filter_delay = int(sweep_size(filter_coef) / 2);
		break;
	default:
		vref = vfund_ref + 0.0;
		vdist = vfund_dist + 0.0;
   } 

    frame_start = frame_start + (filter_delay * sample_period);
    decl start_index = round(frame_start / sample_period);
    decl first_slot = 0;
    for (first_slot = 0; first_slot < 8; first_slot++) {
	if (slot_usage[first_slot] > 0.0) {
		break;
	}
    }

    decl slot_start_index = start_index + (slot_syms * samples_per_symbol * first_slot);
    decl slot_end_index = slot_start_index + (slot_syms * samples_per_symbol); 
    if (slot_end_index > (sweep_size(time_vector) - 1)) {
	print_function_error("kmm_gsm_gmsk_const_evm_v2","A minimum of one complete slot of data is not available.");
	return;
    }

    decl TSC_wav = [1::26 * samples_per_symbol] * (1.0 + j * 1.0) * 0.0;
    decl kxcorr;
    decl peakxcorr = [0.0, 0.0];
    decl peakxcorr_index = [0, 0];
    for (k = 0; k < 2; k++) {
	TSC_wav = kmm_init_TSC_wav(TSC, k, samples_per_symbol);
	kxcorr = mag(kmm_cross_corr([vref[slot_start_index::slot_end_index]], TSC_wav));
	peakxcorr_index[k] = max_index(kxcorr);
        peakxcorr[k] = kxcorr[peakxcorr_index[k]];
    }
    decl kpeak = (peakxcorr[0] >= peakxcorr[1]) ? peakxcorr_index[0] : peakxcorr_index[1];
    kpeak = round((kpeak + 1) / samples_per_symbol);
	// the peak cross correlation should be at index 695 
	// the kmm_cross_corr function: assumes that both sequences start at index 0, and it is the second
	//  sequence/argument (TSC_Syms) that is conjugated and slid over the first - thus, the index for a
	//  correctly aligned frame_start is 25(partial overlapping) + 3 (tail bits) + 58 (encoded bits) + 
	//  1 (so the TSC is completely overlapped) x 8 samples/symbol, less 1 (the first output is index 0)
	//  which equals 695
	// the peak index is converted to the nearest symbol period, as the user adjusts the symbol clock
	//  over range of a symbol period - i.e. the degree of granularity of the cross-correlation should
	//  not exceed that of the symbol clock - 3 + 58 + 26 = 87 symbols

    frame_start = frame_start + ((kpeak - 87) * samples_per_symbol * sample_period);
    if (frame_start > time_vector[sweep_size(time_vector) - 1])
	frame_start = time_vector[sweep_size(time_vector) - 1];
    start_index = round(frame_start / sample_period);

    // add 8.25 symbol periods as the envelope data may end during the time gap of the last slot of the frame
    decl total_frames = (time_vector[sweep_size(time_vector) - 1] - frame_start + (8.25 * samples_per_symbol * sample_period)) / (frame_syms * samples_per_symbol * sample_period);
    decl fractional_frame_slots = kmm_rem(int(total_frames * 8.0), 8);
    decl total_slots = int(total_frames * 8.0);
    decl active_slots = int(total_frames) * sum(slot_usage);
    if (fractional_frame_slots > 0) {
	for (k = 0; k < fractional_frame_slots; k++) {
	    if (slot_usage[k] > 0) {
		active_slots += 1;
	    }
	}
    }

    if (active_slots < 1) {
	print_function_error("kmm_gsm_gmsk_const_evm_v2", "A minimum of one complete slot of data is not available.");
	return;
    }

    decl slotnum = 1.0*[0::(active_slots - 1)];
    decl symnum = 1.0*[0::(evm_syms - 1)];
    decl kconst = create(2, "Complex", {"slotnum", "symnum"}, {"Real", "Real"}, 1, 1);
    decl kconstind1 = indep(kconst, "slotnum");
    decl kconstind2 = indep(kconst, "symnum");

    decl slottime = sample_period * [0::(samples_per_symbol * active_syms)];
    decl ktraj = create(2, "Complex", {"slotnum", "slottime"}, {"Real", "Real"}, 1, 1);
    decl ktrajind1 = indep(ktraj, "slotnum");
    decl ktrajind2 = indep(ktraj, "slottime");

    for (k = 0; k < active_slots; k++) {
	kconstind1[k] = slotnum[k];
	ktrajind1[k] = slotnum[k];
    }

    decl dummy_real;
    decl dummy_imag;
    decl slot_count = 0;
    decl dummy_samp = 0;
    for (k = 0; k < total_slots; k++) {
	if (slot_usage[kmm_rem(k,8)] > 0) {
		slot_start_index = start_index + (slot_syms * samples_per_symbol * k);
		slot_end_index = slot_start_index + (active_syms * samples_per_symbol);
		ktraj[slot_count,::] = [vfund_ref[(slot_start_index - filter_delay)::(slot_end_index - filter_delay)]];
		dummy_real = interp(real(vref), time_vector[slot_start_index] + sample_delay, time_vector[slot_end_index], incr);
		dummy_imag = interp(imag(vref), time_vector[slot_start_index] + sample_delay, time_vector[slot_end_index], incr);
		kconst[slot_count,::] = [dummy_real[3::144] + j * dummy_imag[3::144]];
		dummy_samp = [dummy_samp,[dummy_real[3::144] + j * dummy_imag[3::144]]];
		slot_count++;
	}
    }

    for (k = 0; k < evm_syms; k++) {
	kconstind2[k] = symnum[k];
    }

    for (k = 0; k < (samples_per_symbol * active_syms + 1); k++) {
	ktrajind2[k] = slottime[k];
    }
    decl ref_constellation = kconst;
    decl ref_trajectory = ktraj;
    decl vref_samp = dummy_samp[1::(sweep_size(dummy_samp) - 1)] + 0.0;

    time_vector = indep(vfund_ref);
    frame_start = frame_start + path_delay;
    start_index = round(frame_start / sample_period);
    slot_start_index = start_index + (slot_syms * samples_per_symbol * first_slot);
    slot_end_index = slot_start_index + (slot_syms * samples_per_symbol); 
    if (slot_end_index > (sweep_size(time_vector) - 1)) {
	print_function_error("kmm_gsm_gmsk_const_evm_v2","A minimum of one complete slot of data is not available.");
	return;
    }

    for (k = 0; k < 2; k++) {
	TSC_wav = kmm_init_TSC_wav(TSC, k, samples_per_symbol);
	kxcorr = mag(kmm_cross_corr([vdist[slot_start_index::slot_end_index]], TSC_wav));
	peakxcorr_index[k] = max_index(kxcorr);
        peakxcorr[k] = kxcorr[peakxcorr_index[k]];
    }
    kpeak = (peakxcorr[0] >= peakxcorr[1]) ? peakxcorr_index[0] : peakxcorr_index[1];
    kpeak = round((kpeak + 1) / samples_per_symbol);

    frame_start = frame_start + ((kpeak - 87) * samples_per_symbol * sample_period);
    if (frame_start > time_vector[sweep_size(time_vector) - 1])
	frame_start = time_vector[sweep_size(time_vector) - 1];
    start_index = round(frame_start / sample_period);

    time_vector = indep(vdist);
    // add 8.25 symbol periods as the envelope data may end during the time gap of the last slot of the last frame
    total_frames = (time_vector[sweep_size(time_vector) - 1] - frame_start + (8.25 * samples_per_symbol * sample_period)) / (frame_syms * samples_per_symbol * sample_period);
    fractional_frame_slots = kmm_rem(int(total_frames * 8.0), 8);
    total_slots = int(total_frames * 8.0);
    active_slots = int(total_frames) * sum(slot_usage);
    if (fractional_frame_slots > 0) {
	for (k = 0; k < fractional_frame_slots; k++) {
	    if (slot_usage[k] > 0) {
		active_slots += 1;
	    }
	}
    }
// what about the active_slots = 0 case?
    slotnum = 1.0*[0::(active_slots - 1)];
    symnum = 1.0*[0::(evm_syms - 1)];
    kconst = create(2, "Complex", {"slotnum", "symnum"}, {"Real", "Real"}, 1, 1);
    kconstind1 = indep(kconst, "slotnum");
    kconstind2 = indep(kconst, "symnum");

    slottime = sample_period * [0::(samples_per_symbol * active_syms)];
    ktraj = create(2, "Complex", {"slotnum", "slottime"}, {"Real", "Real"}, 1, 1);
    ktrajind1 = indep(ktraj, "slotnum");
    ktrajind2 = indep(ktraj, "slottime");

    for (k = 0; k < active_slots; k++) {
	kconstind1[k] = slotnum[k];
	ktrajind1[k] = slotnum[k];
    }

    slot_count = 0;
    dummy_samp = 0;
    for (k = 0; k < total_slots; k++) {
	if (slot_usage[kmm_rem(k,8)] > 0) {
		slot_start_index = start_index + (slot_syms * samples_per_symbol * k);
		slot_end_index = slot_start_index + (active_syms * samples_per_symbol);
		ktraj[slot_count,::] = [vfund_dist[(slot_start_index - filter_delay)::(slot_end_index - filter_delay)]];
		dummy_real = interp(real(vdist), time_vector[slot_start_index] + sample_delay, time_vector[slot_end_index], incr);
		dummy_imag = interp(imag(vdist), time_vector[slot_start_index] + sample_delay, time_vector[slot_end_index], incr);
		kconst[slot_count,::] = [dummy_real[3::144] + j * dummy_imag[3::144]];
		dummy_samp = [dummy_samp,[dummy_real[3::144] + j * dummy_imag[3::144]]];
		slot_count++;
	}
    }

    for (k = 0; k < evm_syms; k++) {
	kconstind2[k] = symnum[k];
    }
    for (k = 0; k < (samples_per_symbol * active_syms + 1); k++) {
	ktrajind2[k] = slottime[k];
    }

    decl dist_trajectory = ktraj;
    decl vdist_samp = dummy_samp[1::(sweep_size(dummy_samp) - 1)] + 0.0;

    decl rn = sweep_size(vref_samp);
    decl dn = sweep_size(vdist_samp);
    if (rn != dn) {
	if (rn > dn) {
		vref_samp = vref_samp[0::(dn - 1)];
	} else {
		vdist_samp = vdist_samp[0::(rn - 1)];
	}
    }
    decl vdist_samp_comp = vdist_samp + 0.0;

    // find mean phase difference and compensate, if necessary
    // in other words, the function always returns the phase difference between the reference constellation and 
    //  the uncompensated distorted constellation - if no phase compensation figure is passed to the function
    //  then the distorted constellation is compensated by the mean phase difference, if a phase compensation 
    //  figure is passed to the function, the distorted constellation is compensated using only this figure

    decl phase_delta = phaserad(vdist_samp) - phaserad(vref_samp);
    decl phase_unwrapped1= if (phase_delta < -pi) then (phase_delta + 2 * pi) else phase_delta;
    decl phase_unwrapped = if (phase_unwrapped1 > pi) then phase_unwrapped1 -2 * pi else phase_unwrapped1;
    decl mean_phase_delta = mean(phase_unwrapped);
    vdist_samp_comp *= exp(-j * mean_phase_delta);

    // find mean dc offset between reference and distorted constellations and compensate
    decl divchk = if (mean(abs(real(vref_samp))) > 0.0) then mean(abs(real(vref_samp))) else 1.0;
    decl rel_dc_x_ideal = mean(real(vref_samp)) / divchk;

    divchk = if (mean(abs(imag(vref_samp))) > 0.0) then mean(abs(imag(vref_samp))) else 1.0;
    decl rel_dc_y_ideal = mean(imag(vref_samp)) / divchk;

    divchk = if (mean(abs(real(vdist_samp))) > 0.0) then mean(abs(real(vdist_samp))) else 1.0;
    decl rel_dc_x_dist = mean(real(vdist_samp)) / divchk;

    divchk = if (mean(abs(imag(vdist_samp))) > 0.0) then mean(abs(imag(vdist_samp))) else 1.0;
    decl rel_dc_y_dist = mean(imag(vdist_samp)) / divchk;

    decl mean_dc_delta = (rel_dc_x_ideal - rel_dc_x_dist) + j * (rel_dc_y_ideal - rel_dc_y_dist);
    vdist_samp_comp += (rel_dc_x_ideal - rel_dc_x_dist) * mean(abs(real(vdist_samp))) + 
	 		j * (rel_dc_y_ideal - rel_dc_y_dist) * mean(abs(imag(vdist_samp)));

    // determine scaling (gain/compression) difference between reference and distorted constellations
    // and compensate
    divchk = if (mean(mag(vdist_samp)) > 0.0) then mean(mag(vdist_samp)) else 1.0;
    decl mean_gaincomp = mean(mag(vref_samp)) / divchk;
    vdist_samp_comp *= mean_gaincomp;

    for (k = 0; k < (sweep_size(vdist_samp_comp) / evm_syms); k++) {	
	kconst[k,::] = vdist_samp_comp[int(k * evm_syms)::int((k + 1) * evm_syms - 1)];
    }
    decl dist_constellation = kconst;

    decl evm = mag(vdist_samp_comp - vref_samp);
    decl evm_rms = sqrt(mean(evm**2)); 
    decl avgrefmag = mean(mag(vref_samp));
    if (avgrefmag < 1e-20) avgrefmag = 1.0;
    decl evm_rms_percent = 100 * evm_rms / avgrefmag;
    decl max_evm_percent = 100 * max(evm) / avgrefmag;
    decl mag_err_percent = 100 * mean(abs(mag(vdist_samp_comp) - mag(vref_samp))) / avgrefmag;
    decl phase_err_deg = mean_phase_delta * 180 / pi;
    decl iq_origin_offset_dB = 10 * log(mag(mean_dc_delta) + 1e-20);

    return list(ref_constellation, ref_trajectory, dist_constellation, dist_trajectory, evm_rms_percent,
		max_evm_percent, evm, mag_err_percent, phase_err_deg, iq_origin_offset_dB);
}

//*********************************************************************************************************

defun kmm_gsm_8psk_const_evm_v2(vfund_ref, vfund_dist, u_receive_filter, u_symbol_rate, u_frame_start, u_sample_delay, u_path_delay, u_slot_usage, u_TSC_number)
{
    decl k;

    if ( vfund_ref == NULL || vfund_dist == NULL ) {
	print_function_error("kmm_gsm_8psk_const_evm_v2","Missing reference and/or distorted envelope data.");
	return;
   }
    if (indep(vfund_ref,1) == NULL) {
	print_function_error("kmm_gsm_8psk_const_evm_v2","No indepedent time data attached to reference envelope data.");
	return;
    }
    if (indep(vfund_dist,1) == NULL) {
	print_function_error("kmm_gsm_8psk_const_evm_v2","No indepedent time data attached to distorted envelope data.");
	return;
    }
    if (u_slot_usage == NULL || sweep_size(u_slot_usage) != 8) {
	print_function_error("kmm_gsm_8psk_const_evm_v2","Please specify which time slots to monitor.");
	return;
    }

    decl symbol_rate = u_symbol_rate;
    decl slot_usage = u_slot_usage;
    decl receive_filter = u_receive_filter == NULL ? 0 : round(u_receive_filter);
    decl sample_delay = u_sample_delay == NULL ? 0.0 : real(u_sample_delay);
    decl frame_start = u_frame_start == NULL ? 0.0 : real(u_frame_start);
    decl path_delay = u_path_delay == NULL ? 0.0 : real(u_path_delay);
    decl TSC_number = u_TSC_number == NULL ? 0 : round(u_TSC_number);

    if ( symbol_rate == NULL || symbol_rate <= 0)  {
	print_function_error("kmm_gsm_8psk_const_evm_v2","The symbol rate must be greater than zero.");
	return;
    }

    if (sum(slot_usage) <= 0) {
	print_function_error("kmm_gsm_8psk_const_evm_v2","Please specify which of the eight time slots to monitor.");
	return;
    }

    for (k = 0; k < 8; k++) {
	if (slot_usage[k] != 0) slot_usage[k] = 1;
    }
    if (TSC_number < 0 || TSC_number > 7) TSC_number = 0;
    decl slot_syms = 156.25;
    decl active_syms = 148;
    decl evm_syms = 142;
    decl frame_syms = 1250;
    decl PSK_phase = [3*pi/4, pi, pi/2, pi/4, 3*pi/2, 5 * pi / 4, 7 * pi / 4, 0.0];
    decl TSC = kmm_get_8psk_TSC(TSC_number);
    decl TSC_syms = TSC * (1 + j);
    decl xint;
    for (k = 0; k < sweep_size(TSC); k++) {
	xint = round(TSC[k]);
	TSC_syms[k] = cos(PSK_phase[xint] + (3/8) * pi * k) + j * sin(PSK_phase[xint] + (3/8) * pi * k);
    }

    decl time_vector = indep(vfund_ref);
    decl sample_period = time_vector[1] - time_vector[0];
    if (sample_period <= 0.0) {
	print_function_error("kmm_gsm_8psk_const_evm_v2","Time step of reference envelope data must be greater than zero.");
	return;
    }
    decl samples_per_symbol = round(1 / (sample_period * symbol_rate));
    decl incr = 1.0 / symbol_rate;
    decl tail_sym_samps = 3 * samples_per_symbol;

    // filter both the reference and distorted envelopes, if selected
    decl vref;
    decl vdist;
    decl filter_delay = 0.0;
    decl rate_index = 1;
    if (samples_per_symbol == 16) {
	rate_index = 3;
    } else {
	if (samples_per_symbol == 8) {
		rate_index = 2;
	}
    }
    decl filter_coef;
    switch (receive_filter) {
	case 1:
		filter_coef = kmm_filtcoef(1 + rate_index);
		vref = kmm_filt(vfund_ref, filter_coef);
		vdist = kmm_filt(vfund_dist, filter_coef);
		filter_delay = int(sweep_size(filter_coef) / 2);
		break;
	case 2:
		filter_coef = kmm_filtcoef(4 + rate_index);
		vref = kmm_filt(vfund_ref, filter_coef);
		vdist = kmm_filt(vfund_dist, filter_coef);
		filter_delay = int(sweep_size(filter_coef) / 2);
		break;
	default:
		vref = vfund_ref + 0.0;
		vdist = vfund_dist + 0.0;
   } 

    frame_start = frame_start + (filter_delay * sample_period);
    decl start_index = round(frame_start / sample_period);
    decl first_slot = 0;
    for (first_slot = 0; first_slot < 8; first_slot++) {
	if (slot_usage[first_slot] > 0.0) {
		break;
	}
    }
    decl slot_start_index = start_index + (slot_syms * samples_per_symbol * first_slot);
    decl slot_end_index = slot_start_index + (slot_syms * samples_per_symbol); 
    if (slot_end_index > (sweep_size(time_vector) - 1)) {
	print_function_error("kmm_gsm_8psk_const_evm_v2","A minimum of one complete slot of data is not available.");
	return;
    }
    decl dummy_real = interp(real(vref), time_vector[slot_start_index] + sample_delay, time_vector[slot_end_index], incr);
    decl dummy_imag = interp(imag(vref), time_vector[slot_start_index] + sample_delay, time_vector[slot_end_index], incr);
    decl kxcorr = mag(kmm_cross_corr((dummy_real + j * dummy_imag), TSC_syms));
    decl kpeak = max_index(kxcorr);
	// the peak cross correlation should be at index 86
	// the kmm_cross_corr function: assumes that both sequences start at index 0, and it is the second
	//  sequence/argument (TSC_Syms) that is conjugated and slid over the first - thus, the index for a
	//  correctly aligned frame_start is 25(partial overlapping) + 3 (tail bits) + 58 (encoded bits) + 
	//  1 (so the TSC is completely overlapped) - 1 (the first output is index 0) gives 86

    frame_start = frame_start + ((kpeak - 86) * samples_per_symbol * sample_period);
    start_index = round(frame_start / sample_period);

    // add 8.25 symbol periods as the envelope data may end during the time gap of the last slot of the frame
    decl total_frames = (time_vector[sweep_size(time_vector) - 1] - frame_start + (8.25 * samples_per_symbol * sample_period)) / (frame_syms * samples_per_symbol * sample_period);
    decl fractional_frame_slots = kmm_rem(int(total_frames * 8.0), 8);
    decl total_slots = int(total_frames * 8.0);
    decl active_slots = int(total_frames) * sum(slot_usage);
    if (fractional_frame_slots > 0) {
	for (k = 0; k < fractional_frame_slots; k++) {
	    if (slot_usage[k] > 0) {
		active_slots += 1;
	    }
	}
    }

    if (active_slots < 1) {
	print_function_error("kmm_gsm_8psk_const_evm_v2", "A minimum of one complete slot of data is not available.");
	return;
    }

    decl slotnum = 1.0*[0::(active_slots - 1)];
    decl symnum = 1.0*[0::(evm_syms - 1)];
    decl kconst = create(2, "Complex", {"slotnum", "symnum"}, {"Real", "Real"}, 1, 1);
    decl kconstind1 = indep(kconst, "slotnum");
    decl kconstind2 = indep(kconst, "symnum");

    decl slottime = sample_period * [0::(samples_per_symbol * active_syms)];
    decl ktraj = create(2, "Complex", {"slotnum", "slottime"}, {"Real", "Real"}, 1, 1);
    decl ktrajind1 = indep(ktraj, "slotnum");
    decl ktrajind2 = indep(ktraj, "slottime");

    for (k = 0; k < active_slots; k++) {
	kconstind1[k] = slotnum[k];
	ktrajind1[k] = slotnum[k];
    }

    decl slot_count = 0;
    decl dummy_samp = 0;
    for (k = 0; k < total_slots; k++) {
	if (slot_usage[kmm_rem(k,8)] > 0) {
		slot_start_index = start_index + (slot_syms * samples_per_symbol * k);
		slot_end_index = slot_start_index + (active_syms * samples_per_symbol);
		ktraj[slot_count,::] = [vfund_ref[(slot_start_index - filter_delay)::(slot_end_index - filter_delay)]];
		dummy_real = interp(real(vref), time_vector[slot_start_index] + sample_delay, time_vector[slot_end_index], incr);
		dummy_imag = interp(imag(vref), time_vector[slot_start_index] + sample_delay, time_vector[slot_end_index], incr);
		kconst[slot_count,::] = [dummy_real[3::144] + j * dummy_imag[3::144]];
		dummy_samp = [dummy_samp,[dummy_real[3::144] + j * dummy_imag[3::144]]];
		slot_count++;
	}
    }

    for (k = 0; k < evm_syms; k++) {
	kconstind2[k] = symnum[k];
    }

    for (k = 0; k < (samples_per_symbol * active_syms + 1); k++) {
	ktrajind2[k] = slottime[k];
    }
    decl ref_constellation = kconst;
    decl ref_trajectory = ktraj;
    decl vref_samp = dummy_samp[1::(sweep_size(dummy_samp) - 1)] + 0.0;

    time_vector = indep(vfund_ref);
    frame_start = frame_start + path_delay;
    start_index = round(frame_start / sample_period);
    slot_start_index = start_index + (slot_syms * samples_per_symbol * first_slot);
    slot_end_index = slot_start_index + (slot_syms * samples_per_symbol); 
    if (slot_end_index > (sweep_size(time_vector) - 1)) {
	print_function_error("kmm_gsm_8psk_const_evm_v2","A minimum of one complete slot of data is not available.");
	return;
    }
    dummy_real = interp(real(vdist), time_vector[slot_start_index] + sample_delay, time_vector[slot_end_index], incr);
    dummy_imag = interp(imag(vdist), time_vector[slot_start_index] + sample_delay, time_vector[slot_end_index], incr);
    kxcorr = mag(kmm_cross_corr((dummy_real + j * dummy_imag), TSC_syms));
    kpeak = max_index(kxcorr);

    frame_start = frame_start + ((kpeak - 86) * samples_per_symbol * sample_period);
    start_index = round(frame_start / sample_period);

    time_vector = indep(vdist);
    // add 8.25 symbol periods as the envelope data may end during the time gap of the last slot of the last frame
    total_frames = (time_vector[sweep_size(time_vector) - 1] - frame_start + (8.25 * samples_per_symbol * sample_period)) / (frame_syms * samples_per_symbol * sample_period);
    fractional_frame_slots = kmm_rem(int(total_frames * 8.0), 8);
    total_slots = int(total_frames * 8.0);
    active_slots = int(total_frames) * sum(slot_usage);
    if (fractional_frame_slots > 0) {
	for (k = 0; k < fractional_frame_slots; k++) {
	    if (slot_usage[k] > 0) {
		active_slots += 1;
	    }
	}
    }

    slotnum = 1.0*[0::(active_slots - 1)];
    symnum = 1.0*[0::(evm_syms - 1)];
    kconst = create(2, "Complex", {"slotnum", "symnum"}, {"Real", "Real"}, 1, 1);
    kconstind1 = indep(kconst, "slotnum");
    kconstind2 = indep(kconst, "symnum");

    slottime = sample_period * [0::(samples_per_symbol * active_syms)];
    ktraj = create(2, "Complex", {"slotnum", "slottime"}, {"Real", "Real"}, 1, 1);
    ktrajind1 = indep(ktraj, "slotnum");
    ktrajind2 = indep(ktraj, "slottime");

    for (k = 0; k < active_slots; k++) {
	kconstind1[k] = slotnum[k];
	ktrajind1[k] = slotnum[k];
    }

    slot_count = 0;
    dummy_samp = 0;
    for (k = 0; k < total_slots; k++) {
	if (slot_usage[kmm_rem(k,8)] > 0) {
		slot_start_index = start_index + (slot_syms * samples_per_symbol * k);
		slot_end_index = slot_start_index + (active_syms * samples_per_symbol);
		ktraj[slot_count,::] = [vfund_dist[(slot_start_index - filter_delay)::(slot_end_index - filter_delay)]];
		dummy_real = interp(real(vdist), time_vector[slot_start_index] + sample_delay, time_vector[slot_end_index], incr);
		dummy_imag = interp(imag(vdist), time_vector[slot_start_index] + sample_delay, time_vector[slot_end_index], incr);
		kconst[slot_count,::] = [dummy_real[3::144] + j * dummy_imag[3::144]];
		dummy_samp = [dummy_samp,[dummy_real[3::144] + j * dummy_imag[3::144]]];
		slot_count++;
	}
    }

    for (k = 0; k < evm_syms; k++) {
	kconstind2[k] = symnum[k];
    }
    for (k = 0; k < (samples_per_symbol * active_syms + 1); k++) {
	ktrajind2[k] = slottime[k];
    }

    decl dist_trajectory = ktraj;
    decl vdist_samp = dummy_samp[1::(sweep_size(dummy_samp) - 1)] + 0.0;

    decl rn = sweep_size(vref_samp);
    decl dn = sweep_size(vdist_samp);
    if (rn != dn) {
	if (rn > dn) {
		vref_samp = vref_samp[0::(dn - 1)];
	} else {
		vdist_samp = vdist_samp[0::(rn - 1)];
	}
    }
    decl vdist_samp_comp = vdist_samp + 0.0;

    // find mean phase difference and compensate, if necessary
    // in other words, the function always returns the phase difference between the reference constellation and 
    //  the uncompensated distorted constellation - if no phase compensation figure is passed to the function
    //  then the distorted constellation is compensated by the mean phase difference, if a phase compensation 
    //  figure is passed to the function, the distorted constellation is compensated using only this figure

    decl phase_delta = phaserad(vdist_samp) - phaserad(vref_samp);
    decl phase_unwrapped1= if (phase_delta < -pi) then (phase_delta + 2 * pi) else phase_delta;
    decl phase_unwrapped = if (phase_unwrapped1 > pi) then phase_unwrapped1 -2 * pi else phase_unwrapped1;
    decl mean_phase_delta = mean(phase_unwrapped);
    vdist_samp_comp *= exp(-j * mean_phase_delta);

    // find mean dc offset between reference and distorted constellations and compensate
    decl divchk = if (mean(abs(real(vref_samp))) > 0.0) then mean(abs(real(vref_samp))) else 1.0;
    decl rel_dc_x_ideal = mean(real(vref_samp)) / divchk;

    divchk = if (mean(abs(imag(vref_samp))) > 0.0) then mean(abs(imag(vref_samp))) else 1.0;
    decl rel_dc_y_ideal = mean(imag(vref_samp)) / divchk;

    divchk = if (mean(abs(real(vdist_samp))) > 0.0) then mean(abs(real(vdist_samp))) else 1.0;
    decl rel_dc_x_dist = mean(real(vdist_samp)) / divchk;

    divchk = if (mean(abs(imag(vdist_samp))) > 0.0) then mean(abs(imag(vdist_samp))) else 1.0;
    decl rel_dc_y_dist = mean(imag(vdist_samp)) / divchk;

    decl mean_dc_delta = (rel_dc_x_ideal - rel_dc_x_dist) + j * (rel_dc_y_ideal - rel_dc_y_dist);
    vdist_samp_comp += (rel_dc_x_ideal - rel_dc_x_dist) * mean(abs(real(vdist_samp))) + 
	 		j * (rel_dc_y_ideal - rel_dc_y_dist) * mean(abs(imag(vdist_samp)));

    // determine scaling (gain/compression) difference between reference and distorted constellations
    // and compensate
    divchk = if (mean(mag(vdist_samp)) > 0.0) then mean(mag(vdist_samp)) else 1.0;
    decl mean_gaincomp = mean(mag(vref_samp)) / divchk;
    vdist_samp_comp *= mean_gaincomp;

    for (k = 0; k < (sweep_size(vdist_samp_comp) / evm_syms); k++) {	
	kconst[k,::] = vdist_samp_comp[int(k * evm_syms)::int((k + 1) * evm_syms - 1)];
    }
    decl dist_constellation = kconst;

    decl evm = mag(vdist_samp_comp - vref_samp);
    decl evm_rms = sqrt(mean(evm**2)); 
    decl avgrefmag = mean(mag(vref_samp));
    if (avgrefmag < 1e-20) avgrefmag = 1.0;
    decl evm_rms_percent = 100 * evm_rms / avgrefmag;
    decl max_evm_percent = 100 * max(evm) / avgrefmag;
    decl mag_err_percent = 100 * mean(abs(mag(vdist_samp_comp) - mag(vref_samp))) / avgrefmag;
    decl phase_err_deg = mean_phase_delta * 180 / pi;
    decl iq_origin_offset_dB = 10 * log(mag(mean_dc_delta) + 1e-20);

    return list(ref_constellation, ref_trajectory, dist_constellation, dist_trajectory, evm_rms_percent,
		max_evm_percent, evm, mag_err_percent, phase_err_deg, iq_origin_offset_dB);
}

//*********************************************************************************************************

defun kmm_init_TSC_wav(TSC, u_prior_data_bit, u_sampspersym)
{
	decl k;
	decl prior_data_bit = (u_prior_data_bit != 0) ? 1 : 0;
	decl spsym = 4;
	if (u_sampspersym > 6) {
		if (u_sampspersym > 12) {
			spsym = 16;
		} else {
			spsym = 8;
		}
	}

	decl TSC_enc = TSC * 0;
	decl len_TSC = sweep_size(TSC);
	if (prior_data_bit != TSC[0]) {
		TSC_enc[0] = 1;
	}
	for (k = 1; k < len_TSC; k++) {
		if (TSC[k-1] != TSC[k])  {
			TSC_enc[k] = 1;
		}
	}

	decl TSC_nrz = 1.0 - 2.0 * TSC_enc;
	decl TSC_quad = pi / 2.0 * cum_sum(TSC_nrz);
	decl TSC_quad_upsamp = [1::(sweep_size(TSC_quad) * spsym)] * 0.0;
	for (k = 0; k < sweep_size(TSC_quad_upsamp); k++) {
		TSC_quad_upsamp[k] = TSC_quad[int(k/spsym)];
	}

	decl foft = kmm_init_foft(spsym);
	decl ROM = kmm_LUT_init(foft);
	decl TSC_ph_wav = [1::(26 * spsym)] * 0.0;
	TSC_ph_wav[0 * spsym::1 * spsym - 1] = 	TSC_nrz[0] * foft[2 * spsym::3 * spsym - 1] +
						TSC_nrz[1] * foft[1 * spsym::2 * spsym - 1] +
						TSC_nrz[2] * foft[0 * spsym::1 * spsym - 1];
	TSC_ph_wav[1 * spsym::2 * spsym - 1] = 	TSC_nrz[0] * foft[3 * spsym::4 * spsym - 1] + 
						TSC_nrz[1] * foft[2 * spsym::3 * spsym - 1] +
						TSC_nrz[2] * foft[1 * spsym::2 * spsym - 1] +
						TSC_nrz[3] * foft[0 * spsym::1 * spsym - 1];

	decl addr;
	for (k = 2; k < 24; k++) {
		addr = 16 * TSC_enc[k + 2] + 8 * TSC_enc[k + 1] + 4 * TSC_enc[k] + 2 * TSC_enc[k - 1] + TSC_enc[k - 2];
		TSC_ph_wav[k * spsym::(k + 1) * spsym - 1] = ROM[addr * spsym::(addr + 1) * spsym - 1] + 0.0;
	}
	TSC_ph_wav[24 * spsym::25 * spsym - 1]=	TSC_nrz[22] * foft[4 * spsym::5 * spsym - 1] + 
						TSC_nrz[23] * foft[3 * spsym::4 * spsym - 1] +
						TSC_nrz[24] * foft[2 * spsym::3 * spsym - 1] +
						TSC_nrz[25] * foft[1 * spsym::2 * spsym - 1]; 
	TSC_ph_wav[25 * spsym::26 * spsym - 1]=	TSC_nrz[23] * foft[4 * spsym::5 * spsym - 1] +
						TSC_nrz[24] * foft[3 * spsym::4 * spsym - 1] +
						TSC_nrz[25] * foft[2 * spsym::3 * spsym - 1];

	decl zeropad = [1::(3 * spsym)] * 0.0;
	decl dummy = TSC_quad_upsamp[0::(sweep_size(TSC_quad_upsamp) - 3 * spsym - 1)];
	TSC_ph_wav = TSC_ph_wav + [zeropad, dummy];
	return ([cos(TSC_ph_wav) + j * sin(TSC_ph_wav)]);	
}

//*********************************************************************************************************

defun kmm_init_foft(sampspersym)
{
	decl foft;
	switch (sampspersym) {
		case 8:
			foft = [0.00000041899218, 0.00000162297829, 0.00000585310743, 0.00001956920982,
				0.00006097899240, 0.00017647215422, 0.00047667620327, 0.00119849644107,
				0.00281820179554, 0.00618612863857, 0.01273427717446, 0.02456029268739,
				0.04458453169025, 0.07618136483280, 0.12309502754889, 0.18827647749270,
				0.27387216634036, 0.37955344595273, 0.50345044984375, 0.64060044194259,
				0.78525920657074, 0.92992503786382, 1.06709522377618, 1.19102293427795,
				1.29674139446110, 1.38237645062846, 1.44759522004611, 1.49454123852120,
				1.52616370204944, 1.54620669507255, 1.55804531130944, 1.56460130101569,
				1.56797371427937, 1.56959579886323, 1.57031877959398, 1.57061950842628,
				1.57073521985993, 1.57077671382158, 1.57079045978201, 1.57079469973208];
			break;
		case 16:
			foft = [0.00000041899218, 0.00000083230537, 0.00000162297829, 0.00000311449314,
				0.00000585310743, 0.00001080030909, 0.00001956920982, 0.00003489613600,
				0.00006097899240, 0.00010466395546, 0.00017647215422, 0.00029288078189,
				0.00047667620327, 0.00076240249524, 0.00119849644107, 0.00185505133192,
				0.00281820179554, 0.00421016030889, 0.00618612863857, 0.00895404756507,
				0.01273427717446, 0.01782417953132, 0.02456029268739, 0.03336220185296,
				0.04458453169025, 0.05870431417975, 0.07618136483280, 0.09755754830288,
				0.12309502754889, 0.15323734703366, 0.18827647749270, 0.22856665707074,
				0.27387216634036, 0.32427106151477, 0.37955344595273, 0.43959897146149,
				0.50345044984375, 0.57069826425211, 0.64060044194259, 0.71260192914406,
				0.78525920657074, 0.85791825918936, 0.92992503786382, 0.99983580292027,
				1.06709522377618, 1.13096094007653, 1.19102293427795, 1.24632336741371,
				1.29674139446110, 1.34206655827588, 1.38237645062846, 1.41743470838947,
				1.44759522004611, 1.47314961380515, 1.49454123852120, 1.51203198177628,
				1.52616370204944, 1.53739622665725, 1.54620669507255, 1.55294979561792,
				1.55804531130944, 1.56182996042828, 1.56460130101569, 1.56657984585545,
				1.56797371427937, 1.56893825247233, 1.56959579886323, 1.57003258183002,
				1.57031877959398, 1.57050289124855, 1.57061950842628, 1.57069145039450,
				1.57073521985993, 1.57076135504187, 1.57077671382158, 1.57078550158167,
				1.57079045978201, 1.57079320468394, 1.57079469973208, 1.57079549233598];
			break;
		default:
			foft = [0.00000041899218, 0.00000585310743, 0.00006097899240, 0.00047667620327,
				0.00281820179554, 0.01273427717446, 0.04458453169025, 0.12309502754889,
				0.27387216634036, 0.50345044984375, 0.78525920657074, 1.06709522377618,
				1.29674139446110, 1.44759522004611, 1.52616370204944, 1.55804531130944,
				1.56797371427937, 1.57031877959398, 1.57073521985993, 1.57079045978201];	
	}
	return foft;
}

//*********************************************************************************************************

defun kmm_LUT_init(foft)
{
	decl spsym = int(sweep_size(foft) / 5);
	decl bt_bits = [0, 0, 0, 0, 0, 
			0, 0, 0, 0, 1, 
			0, 0, 0, 1, 0, 
			0, 0, 0, 1, 1, 
			0, 0, 1, 0, 0,
			0, 0, 1, 0, 1,
			0, 0, 1, 1, 0,
			0, 0, 1, 1, 1,
			0, 1, 0, 0, 0,
			0, 1, 0, 0, 1,
			0, 1, 0, 1, 0,
			0, 1, 0, 1, 1,
			0, 1, 1, 0, 0,
			0, 1, 1, 0, 1,
			0, 1, 1, 1, 0,
			0, 1, 1, 1, 1,
			1, 0, 0, 0, 0,
			1, 0, 0, 0, 1,
			1, 0, 0, 1, 0,
			1, 0, 0, 1, 1,
			1, 0, 1, 0, 0,
			1, 0, 1, 0, 1,
			1, 0, 1, 1, 0,
			1, 0, 1, 1, 1,
			1, 1, 0, 0, 0,
			1, 1, 0, 0, 1,	
			1, 1, 0, 1, 0,
			1, 1, 0, 1, 1,
			1, 1, 1, 0, 0,
			1, 1, 1, 0, 1,
			1, 1, 1, 1, 0,
			1, 1, 1, 1, 1];

	//
	// Note the mapping: a low (0) input bit maps to +1, a high (1) input bit maps to -1
	//
	decl bt = 1.0 - (2.0 * bt_bits);

	// Build LUT table using the above 32 bit patterns - bt[y*5] is assumed to be the most recent bit
	//  input to the GMSK modulator, with bt[y*5+4] being the oldest
	decl ROM = [1::(32 * spsym)] * 0.0;
	decl y;
	for (y = 0; y < 32; y++) {
		ROM[y * spsym::(y + 1) * spsym - 1] = 	bt[y * 5 + 0] * foft[0 * spsym::1 * spsym - 1] +
							bt[y * 5 + 1] * foft[1 * spsym::2 * spsym - 1] +
							bt[y * 5 + 2] * foft[2 * spsym::3 * spsym - 1] +
							bt[y * 5 + 3] * foft[3 * spsym::4 * spsym - 1] +
							bt[y * 5 + 4] * foft[4 * spsym::5 * spsym - 1];
	}
	return ROM;
}

//*********************************************************************************************************

defun kmm_gsm_evm(ref_syms, dist_syms)
{

    decl k;

    if (ref_syms == NULL || dist_syms == NULL ) {
	print_function_error("kmm_gsm_const_evm", "Missing reference and/or distorted symbol data.");
	return;
    }
    if (sweep_dim(ref_syms) != 2 || sweep_dim(dist_syms) != 2) {
	print_function_error("kmm_gsm_const_evm", "Reference and/or distorted symbol data does not have two independents.");
	return;
    }

    // sweep_size should return a matrix of two elements - the first being the size of the outer independent, the
    //  second being the size of the inner independent
    decl ref_syms_dim = sweep_size(ref_syms);
    decl dist_syms_dim = sweep_size(dist_syms);

    if (ref_syms_dim(2) != 142 || dist_syms_dim(2) != 142) {
	print_function_error("kmm_gsm_const_evm", "Reference and/or distorted symbol data does not have 142 symbols per slot.");
	return;
    }

    decl slot_num = min([ref_syms_dim(1), dist_syms_dim(1)]);
    decl comp_dist_syms = dist_syms + 0.0;
    decl ref_vec = 0;
    decl dist_vec = 0;
    decl comp_dist_vec;
    decl temp;
    for (k = 0; k < slot_num; k++) {
	temp = [ref_syms[k,::]];
	ref_vec = [ref_vec, temp];
	temp = [dist_syms[k,::]];
	dist_vec = [dist_vec, temp];
    }
    ref_vec = ref_vec[1::(sweep_size(ref_vec) - 1)];
    dist_vec = dist_vec[1::(sweep_size(dist_vec) - 1)];
    comp_dist_vec = dist_vec + 0.0;

    // find mean phase difference and compensate, if necessary
    // in other words, the function always returns the phase difference between the reference constellation and 
    //  the uncompensated distorted constellation - if no phase compensation figure is passed to the function
    //  then the distorted constellation is compensated by the mean phase difference, if a phase compensation 
    //  figure is passed to the function, the distorted constellation is compensated using only this figure

    decl phase_delta = phaserad(dist_vec) - phaserad(ref_vec);
    decl phase_unwrapped1= if (phase_delta < -pi) then (phase_delta + 2 * pi) else phase_delta;
    decl phase_unwrapped = if (phase_unwrapped1 > pi) then phase_unwrapped1 -2 * pi else phase_unwrapped1;
    decl mean_phase_delta = mean(phase_unwrapped);
    comp_dist_vec *= exp(-j * mean_phase_delta);
    comp_dist_syms *= exp(-j * mean_phase_delta); 

    // find mean dc offset between reference and distorted constellations and compensate
    decl divchk = if (mean(abs(real(ref_vec))) > 0.0) then mean(abs(real(ref_vec))) else 1.0;
    decl rel_dc_x_ideal = mean(real(ref_vec)) / divchk;

    divchk = if (mean(abs(imag(ref_vec))) > 0.0) then mean(abs(imag(ref_vec))) else 1.0;
    decl rel_dc_y_ideal = mean(imag(ref_vec)) / divchk;

    divchk = if (mean(abs(real(dist_vec))) > 0.0) then mean(abs(real(dist_vec))) else 1.0;
    decl rel_dc_x_dist = mean(real(dist_vec)) / divchk;

    divchk = if (mean(abs(imag(dist_vec))) > 0.0) then mean(abs(imag(dist_vec))) else 1.0;
    decl rel_dc_y_dist = mean(imag(dist_vec)) / divchk;

    decl mean_dc_delta = (rel_dc_x_ideal - rel_dc_x_dist) + j * (rel_dc_y_ideal - rel_dc_y_dist);
    comp_dist_vec += (rel_dc_x_ideal - rel_dc_x_dist) * mean(abs(real(dist_vec))) + 
	 		j * (rel_dc_y_ideal - rel_dc_y_dist) * mean(abs(imag(dist_vec)));
    comp_dist_syms += (rel_dc_x_ideal - rel_dc_x_dist) * mean(abs(real(dist_vec))) + 
	 		j * (rel_dc_y_ideal - rel_dc_y_dist) * mean(abs(imag(dist_vec)));


    // determine scaling (gain/compression) difference between reference and distorted constellations
    // and compensate
    divchk = if (mean(mag(dist_vec)) > 0.0) then mean(mag(dist_vec)) else 1.0;
    decl mean_gaincomp = mean(mag(ref_vec)) / divchk;
    comp_dist_vec *= mean_gaincomp;
    comp_dist_syms *= mean_gaincomp;

    decl evm = mag(comp_dist_vec - ref_vec);
    decl evm_rms = sqrt(mean(evm**2)); 
    decl maxmag = max(mag(ref_vec));
    if (maxmag < 1e-20) maxmag = 1.0;
    decl evm_rms_percent = 100 * evm_rms / maxmag;
    decl max_evm_percent = 100 * max(evm) / maxmag;
    decl mag_err_percent = 100 * mean(abs(mag(comp_dist_vec) - mag(ref_vec))) / maxmag;
    decl phase_err_deg = mean_phase_delta * 180 / pi;
    decl iq_origin_offset_dB = 10 * log(mag(mean_dc_delta) + 1e-20);

    return list(comp_dist_syms, evm_rms_percent, max_evm_percent, evm, mag_err_percent, phase_err_deg, 
		iq_origin_offset_dB);
}

//*********************************************************************************************************

defun kmm_gsm_gmsk_evm(dist_syms)
{

    decl k;

    if (dist_syms == NULL ) {
	print_function_error("kmm_gsm_gmsk_evm", "No distorted symbol data.");
	return;
    }
    if (sweep_dim(dist_syms) != 2) {
	print_function_error("kmm_gsm_gmsk_evm", "Distorted symbol data does not have two independents.");
	return;
    }

    // sweep_size should return a matrix of two elements - the first being the size of the outer independent, the
    //  second being the size of the inner independent
    decl dist_syms_dim = sweep_size(dist_syms);

    if (dist_syms_dim(2) != 142) {
	print_function_error("kmm_gsm_gmsk_evm", "Distorted symbol data does not have 142 symbols per slot.");
	return;
    }

    decl slot_num = dist_syms_dim(1);
    decl comp_dist_syms = dist_syms + 0.0;
    decl dist_vec = 0;
    decl temp;
    for (k = 0; k < slot_num; k++) {
	temp = [dist_syms[k,::]];
	dist_vec = [dist_vec, temp];
    }
    dist_vec = dist_vec[1::(sweep_size(dist_vec) - 1)];
    decl comp_dist_vec = dist_vec + 0.0;

    decl ref_vec = dist_vec + 0.0;
    // slice the constellation to determine the ideal constellation points
    for (k = 0; k < sweep_size(dist_vec); k++) {
	ref_vec[k] = ((real(dist_vec[k]) >= 0.0) ? 1.0 : -1.0) + j * ((imag(dist_vec[k]) >= 0.0) ? 1.0 : -1.0);
    }    

    // find mean phase difference and compensate, if necessary
    // in other words, the function always returns the phase difference between the reference constellation and 
    //  the uncompensated distorted constellation - if no phase compensation figure is passed to the function
    //  then the distorted constellation is compensated by the mean phase difference, if a phase compensation 
    //  figure is passed to the function, the distorted constellation is compensated using only this figure

    decl phase_delta = phaserad(dist_vec) - phaserad(ref_vec);
    decl phase_unwrapped1= if (phase_delta < -pi) then (phase_delta + 2 * pi) else phase_delta;
    decl phase_unwrapped = if (phase_unwrapped1 > pi) then phase_unwrapped1 -2 * pi else phase_unwrapped1;
    decl mean_phase_delta = mean(phase_unwrapped);
    comp_dist_vec *= exp(-j * mean_phase_delta);
    comp_dist_syms *= exp(-j * mean_phase_delta); 

    // find mean dc offset between reference and distorted constellations and compensate
    decl divchk = if (mean(abs(real(ref_vec))) > 0.0) then mean(abs(real(ref_vec))) else 1.0;
    decl rel_dc_x_ideal = mean(real(ref_vec)) / divchk;

    divchk = if (mean(abs(imag(ref_vec))) > 0.0) then mean(abs(imag(ref_vec))) else 1.0;
    decl rel_dc_y_ideal = mean(imag(ref_vec)) / divchk;

    divchk = if (mean(abs(real(dist_vec))) > 0.0) then mean(abs(real(dist_vec))) else 1.0;
    decl rel_dc_x_dist = mean(real(dist_vec)) / divchk;

    divchk = if (mean(abs(imag(dist_vec))) > 0.0) then mean(abs(imag(dist_vec))) else 1.0;
    decl rel_dc_y_dist = mean(imag(dist_vec)) / divchk;

    decl mean_dc_delta = (rel_dc_x_ideal - rel_dc_x_dist) + j * (rel_dc_y_ideal - rel_dc_y_dist);
    comp_dist_vec += (rel_dc_x_ideal - rel_dc_x_dist) * mean(abs(real(dist_vec))) + 
	 		j * (rel_dc_y_ideal - rel_dc_y_dist) * mean(abs(imag(dist_vec)));
    comp_dist_syms += (rel_dc_x_ideal - rel_dc_x_dist) * mean(abs(real(dist_vec))) + 
	 		j * (rel_dc_y_ideal - rel_dc_y_dist) * mean(abs(imag(dist_vec)));


    // determine scaling (gain/compression) difference between reference and distorted constellations
    // and compensate
    divchk = if (mean(mag(dist_vec)) > 0.0) then mean(mag(dist_vec)) else 1.0;
    decl mean_gaincomp = mean(mag(ref_vec)) / divchk;
    comp_dist_vec *= mean_gaincomp;
    comp_dist_syms *= mean_gaincomp;

    decl evm = mag(comp_dist_vec - ref_vec);
    decl evm_rms = sqrt(mean(evm**2)); 
    decl maxmag = max(mag(ref_vec));
    if (maxmag < 1e-20) maxmag = 1.0;
    decl evm_rms_percent = 100 * evm_rms / maxmag;
    decl max_evm_percent = 100 * max(evm) / maxmag;
    decl mag_err_percent = 100 * mean(abs(mag(comp_dist_vec) - mag(ref_vec))) / maxmag;
    decl phase_err_deg = mean_phase_delta * 180 / pi;
    decl iq_origin_offset_dB = 10 * log(mag(mean_dc_delta) + 1e-20);

    return list(comp_dist_syms, evm_rms_percent, max_evm_percent, evm, mag_err_percent, phase_err_deg, 
		iq_origin_offset_dB);
}

//*********************************************************************************************************

defun kmm_symbol_extract(ideal_symbols, u_symbol_rate, u_tstart)
{
    if (ideal_symbols == NULL) {
	print_function_error("kmm_symbol_extract", "No ideal symbol data.");
	return;
    }
    if (indep(ideal_symbols,"time") == NULL) {
	print_function_error("kmm_symbol_extract", "No indepedent time data attached to ideal symbol data.");
	return;
    }
    decl symbol_rate = u_symbol_rate == NULL ? 0.0 : real(u_symbol_rate);
    if (symbol_rate == NULL || symbol_rate <= 0)  {
	print_function_error("kmm_symbol_extract", "The symbol rate must be greater than zero.");
	return;
    }
    decl tstart = u_tstart == NULL ? 0.0 : real(u_tstart);

    decl start_index = round(tstart * symbol_rate);
    decl end_index = sweep_size(ideal_symbols) - 1;
    end_index = int((end_index - start_index) / 8) + start_index;
    decl time_vector = indep(ideal_symbols);
    decl kmm_timestep = time_vector[1] - time_vector[0];
    if (kmm_timestep <= 0.0 || kmm_timestep == NULL) {
	print_function_error("kmm_symbol_extract","The time step must be greater than zero.");
	return;
    }
    decl incr = round((1.0 / symbol_rate) / kmm_timestep);

    return ideal_symbols[start_index::incr::end_index];
}

//*********************************************************************************************************

defun kmm_gsm_8psk_symbol_extract(ideal_symbols, u_symbol_rate, u_frame_start, u_slot_usage, u_TSC_number)
{
    decl k;

    if (ideal_symbols == NULL) {
	print_function_error("kmm_gsm_symbol_extract", "No ideal symbol data.");
	return;
    }
    if (indep(ideal_symbols,"time") == NULL) {
	print_function_error("kmm_gsm_symbol_extract", "No indepedent time data attached to ideal symbol data.");
	return;
    }

    decl symbol_rate = u_symbol_rate;
    if (symbol_rate == NULL || symbol_rate <= 0.0)  {
	print_function_error("kmm_gsm_symbol_extract", "The symbol rate must be greater than zero.");
	return;
    }

    decl frame_start = u_frame_start == NULL ? 0.0 : real(u_frame_start);

    if (u_slot_usage == NULL || sweep_size(u_slot_usage) != 8) {
	print_function_error("kmm_gsm_8psk_const_evm_v2", "Please specify which of the eight time slots to monitor.");
	return;
    }
    decl slot_usage = u_slot_usage;
    for (k = 0; k < 8; k++) {
	if (slot_usage[k] != 0) slot_usage[k] = 1;
    }
    if (sum(slot_usage) <= 0) {
	print_function_error("kmm_gsm_8psk_const_evm_v2", "Please specify at least one time slot to monitor.");
	return;
    }

    decl TSC_number = u_TSC_number == NULL ? 0 : round(u_TSC_number);
    if (TSC_number < 0 || TSC_number > 7) TSC_number = 0;

    decl slot_syms = 156.25;
    decl active_syms = 148;
    decl evm_syms = 142;
    decl frame_syms = 1250;
    decl PSK_phase = [3*pi/4, pi, pi/2, pi/4, 3*pi/2, 5 * pi / 4, 7 * pi / 4, 0.0];
    decl TSC = kmm_get_8psk_TSC(TSC_number);
    decl TSC_syms = TSC * (1 + j);
    decl xint;
    for (k = 0; k < sweep_size(TSC); k++) {
	xint = TSC[k];
	TSC_syms[k] = cos(PSK_phase[xint] + (3/8) * pi * k) + j * sin(PSK_phase[xint] + (3/8) * pi * k);
    }

    // first reduce the spaced out baseband symbol stream into symbol samples only
    decl time_vector = indep(ideal_symbols);
    decl sample_period = time_vector[1] - time_vector[0];
    if (sample_period <= 0.0) {
	print_function_error("kmm_gsm_8psk_extract_symbols", "Time step of ideal symbol data must be greater than zero.");
	return;
    }
    decl samples_per_symbol = round(1 / (sample_period * symbol_rate));
    decl symbol_period = 1.0 / symbol_rate;
    decl tail_sym_samps = 3 * samples_per_symbol;

    // the ideal symbols have zero magnitude between each ideal symbol (i.e. the ideal symbol data is an impulse
    //  symbol stream, with zeros between each symbol) 
    // look at the magnitude of the first 25 symbols at each possible offset to determine the correct offset at
    //  of the ideal symbol data
    decl start_index = round(frame_start / sample_period);
    decl first_slot;
    for (first_slot = 0; first_slot < 8; first_slot++) {
	if (slot_usage[first_slot] > 0.0) {
		break;
	}
    }
    decl slot_start_index = start_index + (slot_syms * samples_per_symbol * first_slot);
    decl slot_end_index = slot_start_index + (slot_syms * samples_per_symbol); 
    decl offset_mags = 0.0;
    for (k = 0; k < samples_per_symbol; k++) {
	offset_mags = [offset_mags, sum(mag(ideal_symbols[(slot_start_index + k)::samples_per_symbol::(slot_end_index + k)]))];
    }

    decl koffset = max_index(offset_mags[1::(sweep_size(offset_mags) - 1)]);
    decl slot_symbols = ideal_symbols[(slot_start_index + koffset)::samples_per_symbol::(slot_end_index + koffset)];
    decl kxcorr = kmm_cross_corr(slot_symbols, TSC_syms);
    decl kpeak = max_index(kxcorr);
	// the peak cross correlation should be at index 86
	// the kmm_cross_corr function: assumes that both sequences start at index 0, and it is the second
	//  sequence/argument (TSC_Syms) that is conjugated and slid over the first - thus, the index for a
	//  correctly aligned frame_start is 25(partial overlapping) + 3 (tail bits) + 58 (encoded bits) + 
	//  1 (so the TSC is completely overlapped) - 1 (the first output is index 0) gives 86

    frame_start = frame_start + (((kpeak - 86) * samples_per_symbol + koffset) * sample_period);
    start_index = round(frame_start / sample_period);

    // add 8.25 symbol periods as the envelope data may end during the time gap of the last slot of the frame
    decl total_frames = (time_vector[sweep_size(time_vector) - 1] - frame_start + (8.25 * samples_per_symbol * sample_period)) / (frame_syms * samples_per_symbol * sample_period);
    decl fractional_frame_slots = kmm_rem(int(total_frames * 8.0), 8);
    decl total_slots = int(total_frames * 8.0);
    decl active_slots = int(total_frames) * sum(slot_usage);
    if (fractional_frame_slots > 0) {
	for (k = 0; k < fractional_frame_slots; k++) {
	    if (slot_usage[k] > 0) {
		active_slots += 1;
	    }
	}
    }

   if (active_slots < 1) {
	print_function_error("kmm_gsm_8psk_extract_symbols","At least one complete slot of data must be available.");
	return;
    }

    decl slotnum = 1.0*[0::(active_slots - 1)];
    decl symnum = 1.0*[0::(evm_syms - 1)];
    decl kconst = create(2, "Complex", {"slotnum", "symnum"}, {"Real", "Real"}, 1, 1);
    decl kconstind1 = indep(kconst, "slotnum");
    decl kconstind2 = indep(kconst, "symnum");
    for (k = 0; k < active_slots; k++) {
	kconstind1[k] = slotnum[k];
    }

    decl slot_count = 0;
    for (k = 0; k < total_slots; k++) {
	if (slot_usage[kmm_rem(k,8)] > 0) {
		slot_start_index = start_index + (slot_syms * samples_per_symbol * k);
		slot_end_index = slot_start_index + ((active_syms - 1) * samples_per_symbol);
		kconst[slot_count,::] = [ideal_symbols[(slot_start_index + tail_sym_samps)::samples_per_symbol::(slot_end_index - tail_sym_samps)]];
		slot_count++;
	}
    }
   for (k = 0; k < evm_syms; k++) {
	kconstind2[k] = symnum[k];
    }

    return kconst;
}

//*********************************************************************************************************

defun kmm_get_gmsk_TSC(u_TSC_number)
{
    decl TSC_number = u_TSC_number == NULL ? 0 : round(u_TSC_number);
    decl TSC;
    switch(TSC_number) {
	case 0:
		TSC = [0,0,1,0,0,1,0,1,1,1,0,0,0,0,1,0,0,0,1,0,0,1,0,1,1,1];
		break;
	case 1:
		TSC = [0,0,1,0,1,1,0,1,1,1,0,1,1,1,1,0,0,0,1,0,1,1,0,1,1,1];
		break;
	case 2:
		TSC = [0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,0,0,1,0,0,0,0,1,1,1,0];
		break;
	case 3:
		TSC = [0,1,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,1,0,0,0,1,1,1,1,0];
		break;
	case 4:
		TSC = [0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1];
		break;
	case 5:
		TSC = [0,1,0,0,1,1,1,0,1,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,0];
		break;
	case 6:
		TSC = [1,0,1,0,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1];
		break;
	case 7:
		TSC = [1,1,1,0,1,1,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,1,1,1,0,0];
		break;
	default:
		TSC = [7,7,1,7,7,1,7,1,1,1,7,7,7,7,1,7,7,7,1,7,7,1,7,1,1,1];
    }

    return TSC;
}

//*********************************************************************************************************

defun kmm_get_8psk_TSC(u_TSC_number)
{
    decl TSC_number = u_TSC_number == NULL ? 0 : round(u_TSC_number);
    decl TSC;
    switch(TSC_number) {
	case 0:
		TSC = [7,7,1,7,7,1,7,1,1,1,7,7,7,7,1,7,7,7,1,7,7,1,7,1,1,1];
		break;
	case 1:
		TSC = [7,7,1,7,1,1,7,1,1,1,7,1,1,1,1,7,7,7,1,7,1,1,7,1,1,1];
		break;
	case 2:
		TSC = [7,1,7,7,7,7,1,1,1,7,1,1,1,7,1,7,7,1,7,7,7,7,1,1,1,7];
		break;
	case 3:
		TSC = [7,1,7,7,7,1,1,1,1,7,1,1,7,1,7,7,7,1,7,7,7,1,1,1,1,7];
		break;
	case 4:
		TSC = [7,7,7,1,1,7,1,7,1,1,1,7,7,1,7,7,7,7,7,1,1,7,1,7,1,1];
		break;
	case 5:
		TSC = [7,1,7,7,1,1,1,7,1,7,1,1,7,7,7,7,7,1,7,7,1,1,1,7,1,7];
		break;
	case 6:
		TSC = [1,7,1,7,7,1,1,1,1,1,7,1,1,7,7,7,1,7,1,7,7,1,1,1,1,1];
		break;
	case 7:
		TSC = [1,1,1,7,1,1,1,1,7,7,7,1,7,7,1,7,1,1,1,7,1,1,1,1,7,7];
		break;
	default:
		TSC = [7,7,1,7,7,1,7,1,1,1,7,7,7,7,1,7,7,7,1,7,7,1,7,1,1,1];
    }

    return TSC;
}

//*********************************************************************************************************

defun kmm_spectrum_shift(signal, u_freq, u_phase)
{
    if (signal == NULL) {
	print_function_error("kmm_spectrum_shift","No signal data.");
	return;
    }
    decl kfreq = u_freq == NULL ? 0.0 : u_freq;
    decl kphase = u_phase == NULL ? 0.0 : u_phase;

    decl time_vector = indep(signal);
    if (time_vector == NULL) {
	print_function_error("kmm_spectrum_shift","No time information attached to signal vector.");
	return;
    }

    decl shifted_signal = signal .* exp(j * (time_vector * 2.0 * pi * kfreq + kphase / 180.0 * pi));

    return shifted_signal;
}


//*********************************************************************************************************

defun kmm_conv(vec1, vec2)
{
    if (vec1 == NULL || vec2 == NULL) {
	print_function_error("kmm_conv","Missing one or both input vectors.");
	return;
    }
    decl lenv1 = sweep_size(vec1);
    decl lenv2 = sweep_size(vec2);
    decl kvec1, kvec2, klenv1, klenv2;

    if (lenv1 < lenv2) {
	kvec1 = vec2 + 0.0;
	kvec2 = vec1[lenv1-1::-1::0] + 0.0;
	klenv1 = lenv2;
	klenv2 = lenv1;
    } else {
	kvec1 = vec1 + 0.0;
	kvec2 = vec2[lenv2-1::-1::0] + 0.0;
	klenv1 = lenv1;
	klenv2 = lenv2;
    }

    decl klim1 = klenv1 - 1;
    decl klim2 = klenv2 - 1;
    decl klim3 = klenv1 + klenv2 - 2;
    decl result = ([0::klim3] + j * [0::klim3]) * 0.0;
    decl temp1, temp2, temp3;
    decl ki, kj;

    // handle trivial cases
    if (klim2 == 0) {
	result = kvec1 * kvec2;
	return result;
    }
   
    temp2 = kvec1[0::klim1] * kvec2[0];
    temp3 = ([1::klim2] + j * [1::klim2]) * 0.0;
    result += [temp2, temp3];

    for (ki = 1; ki < klim2 ; ki++) {
	temp1 = ([1::ki] + j * [1::ki]) * 0.0;
	temp2 = kvec1[0::klim1] * kvec2[ki];
	temp3 = ([1::klim2-ki] + j * [1::klim2-ki]) * 0.0;
	result += [temp1, temp2, temp3];
    }

    if (klim2 > 2) {
        temp1 = ([1::klim2] + j * [1::klim2]) * 0.0;
        temp2 = kvec1[0::klim1] * kvec2[klim2];
        result += [temp1, temp2];
    }

// alternative algorithm - slow!!!!!
//    for (ki = 0; ki < klim2; ki++) 
//	for (kj = 0; kj <= ki; kj++) 
//	    result[ki] += kvec2[kj] * kvec1[ki - kj];
//
//    for (ki = klim2; ki < klenv1; ki++) 
//	for (kj = 0; kj < klenv2; kj++)
//	    result[ki] += kvec2[kj] * kvec1[ki - kj];
//
//    for (ki = klenv1; ki < klim3; ki++) 
//	for (kj = ki - klenv1 + 1; kj < klenv2; kj++)
//	    result[ki] += kvec2[kj] * kvec1[ki - kj];

    return  result;
}

//*********************************************************************************************************

defun kmm_filt(vec1, vec2)
{
	//  The length of the output vector is equal to the length of the longest of the two
	//  input vectors - this is a truncated convolution of the two input vectors

    if (vec1 == NULL || vec2 == NULL) {
	print_function_error("kmm_conv","Missing an input vector.");
	return;
    }
    decl lenv1 = sweep_size(vec1);
    decl lenv2 = sweep_size(vec2);
    decl kvec1, kvec2, klenv1, klenv2;

    if (lenv1 < lenv2) {
	kvec1 = vec2 + 0.0;
	if (lenv1 > 1) {
	    kvec2 = vec1[lenv1-1::-1::0] + 0.0;
	} else {
	    kvec2 = vec1 + 0.0;
	}
	klenv1 = lenv2;
	klenv2 = lenv1;
    } else {
	kvec1 = vec1 + 0.0;
        if (lenv2 > 1) {
	    kvec2 = vec2[lenv2-1::-1::0] + 0.0;
	} else {
	    kvec2 = vec2 + 0.0;
	}
	klenv1 = lenv1;
	klenv2 = lenv2;
    }

    decl klim1 = klenv1 - 1;
    decl klim2 = klenv2 - 1;
    decl result;
    decl temp1, temp2;
    decl ki, kj;

    // handle trivial cases
    if (klim2 == 0) {
	return (kvec1 * kvec2);
    }

    result = ([0::klim1] + j * [0::klim1]) * 0.0;
    result += kvec1[0::klim1] * kvec2[0];
    for (ki = 1; ki < klim2 ; ki++) {
        temp1 = ([1::ki] + j * [1::ki]) * 0.0;
	temp2 = kvec1[0::klim1 - ki] * kvec2[ki];
	result += [temp1, temp2];
    }
    return  result;
}

//*********************************************************************************************************

defun kmm_cross_corr(vec1, vec2)
{
    if (vec1 == NULL || vec2 == NULL) {
	print_function_error("kmm_cross_corr","Missing one or both input vectors.");
	return;
    }
    decl lenv1 = sweep_size(vec1);
    decl lenv2 = sweep_size(vec2);
    decl kvec1, kvec2, klenv1, klenv2;

    if (lenv1 < lenv2) {
	kvec1 = [vec2];
	kvec2 = conj(vec1);
	klenv1 = lenv2;
	klenv2 = lenv1;
    } else {
	kvec1 = [vec1];
	kvec2 = conj(vec2);
	klenv1 = lenv1;
	klenv2 = lenv2;
    }

    decl klim1 = klenv1 - 1;
    decl klim2 = klenv2 - 1;
    decl klim3 = klenv1 + klenv2 - 2;
    decl result = ([0::klim3] + j * [0::klim3]) * 0.0;
    decl temp1, temp2, temp3;
    decl ki, kj;

    // handle trivial cases
    if (klim2 == 0) {
	result = kvec1 * kvec2;
	return result;
    }
   
    temp2 = kvec1 * kvec2[klim2];
    temp3 = [1::klim2] * (1 + j) * 0.0;
    result += [temp2, temp3];

    for (ki = 1; ki < klim2 ; ki++) {
	temp1 = [1::ki] * (1 + j) * 0.0;
	temp2 = kvec1 * kvec2[klim2 - ki];
	temp3 = [1::(klim2-ki)] * (1 + j) * 0.0;
	result += [temp1, temp2, temp3];
    }

    if (klim2 > 2) {
        temp1 = [1::klim2] * (1 + j) * 0.0;
        temp2 = kvec1 * kvec2[0];
        result += [temp1, temp2];
    }

    return  result;
}


//*********************************************************************************************************

defun kmm_filtcoef(filtnum)
{
    decl coef;  

    switch(int(filtnum)) {
	case 1:
	    // This is a 181st order equiripple LPF with passband frequency of 0.6144 MHz, passband
	    //  ripple of 0.085 dB, stopband at 0.7371 MHz at 50 dB suppression.  The sampling 
	    //  frequency is 9.8304. 
	    coef = [1.480526217436000E-03, -6.035676902158600E-04, -7.487886074317290E-04, 
		-9.753021437642220E-04, -1.207640477594870E-03, -1.375302437370200E-03, 
		-1.418096908346940E-03, -1.299894266109510E-03, -1.009082235106860E-03, 
		-5.712047795785370E-04, -4.174611047321780E-05, 5.002603210151890E-04, 
		9.639354993422110E-04, 1.262329585148790E-03, 1.331036849743680E-03, 
		1.141046934295960E-03, 7.090779447893610E-04, 9.861019108679060E-05, 
		-5.883183876839390E-04, -1.226534216753540E-03, -1.689012994600280E-03, 
		-1.871520848793660E-03, -1.714200992124740E-03, -1.216801032183510E-03, 
		-4.443310521323180E-04, 4.801456843768940E-04, 1.393932332396850E-03, 
		2.122194656326960E-03, 2.510444119305930E-03, 2.456045619534670E-03, 
		1.931819898637160E-03, 9.979442862414440E-04, -2.024926787794890E-04, 
		-1.463868622923010E-03, -2.552063919540440E-03, -3.246483903501570E-03, 
		-3.383510296631750E-03, -2.891851084479360E-03, -1.813760699450810E-03, 
		-3.060033882401190E-04, 1.380613063769860E-03, 2.941433474971750E-03, 
		4.071044640050860E-03, 4.521375481023560E-03, 4.152935456862210E-03, 
		2.969929351010080E-03, 1.130729786131240E-03, -1.069624816374170E-03, 
		-3.244481947041340E-03, -4.980868510343540E-03, -5.915401673624560E-03, 
		-5.806483297980800E-03, -4.589571848923120E-03, -2.403401512867110E-03, 
		4.193876064331580E-04, 3.399036532109920E-03, 5.986218790751960E-03, 
		7.659164562362360E-03, 8.023357770103380E-03, 6.895989259991420E-03, 
		4.357904195913050E-03, 7.615209971973970E-04, -3.311025439253430E-03, 
		-7.135307314133730E-03, -9.965893534276700E-03, -1.117198523856290E-02, 
		-1.036444526198300E-02, -7.490172263759850E-03, -2.874731520999300E-03, 
		2.799305349253150E-03, 8.579733104453190E-03, 1.338850006578070E-02, 
		1.620168094768850E-02, 1.623826401118900E-02, 1.312605844281750E-02, 
		7.015357193093870E-03, -1.383079031273560E-03, -1.084792746166970E-02, 
		-1.978408551348130E-02, -2.643083615705130E-02, -2.911406185066170E-02, 
		-2.650600672510250E-02, -1.785333354986300E-02, -3.136898147467440E-03, 
		1.686445958270110E-02, 4.062055397409040E-02, 6.600488142620110E-02, 
		9.054002475776580E-02, 1.117011242668360E-01, 1.272357187296430E-01, 
		1.354550040853540E-01, 1.354550040853540E-01, 1.272357187296430E-01, 
		1.117011242668360E-01, 9.054002475776580E-02, 6.600488142620110E-02, 
		4.062055397409040E-02, 1.686445958270110E-02, -3.136898147467440E-03, 
		-1.785333354986300E-02, -2.650600672510250E-02, -2.911406185066170E-02, 
		-2.643083615705130E-02, -1.978408551348130E-02, -1.084792746166970E-02, 
		-1.383079031273560E-03, 7.015357193093870E-03, 1.312605844281750E-02, 
		1.623826401118900E-02, 1.620168094768850E-02, 1.338850006578070E-02, 
		8.579733104453190E-03, 2.799305349253150E-03, -2.874731520999300E-03, 
		-7.490172263759850E-03, -1.036444526198300E-02, -1.117198523856290E-02, 
		-9.965893534276700E-03, -7.135307314133730E-03, -3.311025439253430E-03, 
		7.615209971973970E-04, 4.357904195913050E-03, 6.895989259991420E-03, 
		8.023357770103380E-03, 7.659164562362360E-03, 5.986218790751960E-03, 
		3.399036532109920E-03, 4.193876064331580E-04, -2.403401512867110E-03, 
		-4.589571848923120E-03, -5.806483297980800E-03, -5.915401673624560E-03, 
		-4.980868510343540E-03, -3.244481947041340E-03, -1.069624816374170E-03, 
		1.130729786131240E-03, 2.969929351010080E-03, 4.152935456862210E-03, 
		4.521375481023560E-03, 4.071044640050860E-03, 2.941433474971750E-03, 
		1.380613063769860E-03, -3.060033882401190E-04, -1.813760699450810E-03, 
		-2.891851084479360E-03, -3.383510296631750E-03, -3.246483903501570E-03, 
		-2.552063919540440E-03, -1.463868622923010E-03, -2.024926787794890E-04, 
		9.979442862414440E-04, 1.931819898637160E-03, 2.456045619534670E-03, 
		2.510444119305930E-03, 2.122194656326960E-03, 1.393932332396850E-03, 
		4.801456843768940E-04, -4.443310521323180E-04, -1.216801032183510E-03, 
		-1.714200992124740E-03, -1.871520848793660E-03, -1.689012994600280E-03, 
		-1.226534216753540E-03, -5.883183876839390E-04, 9.861019108679060E-05, 
		7.090779447893610E-04, 1.141046934295960E-03, 1.331036849743680E-03, 
		1.262329585148790E-03, 9.639354993422110E-04, 5.002603210151890E-04, 
		-4.174611047321780E-05, -5.712047795785370E-04, -1.009082235106860E-03, 
		-1.299894266109510E-03, -1.418096908346940E-03, -1.375302437370200E-03, 
		-1.207640477594870E-03, -9.753021437642220E-04, -7.487886074317290E-04, 
		-6.035676902158600E-04, 1.480526217436000E-03];
	    break;
	case 2:
		//  This is a 44th order FIR filter that implements a receive filter to 
		//  eliminate ISI on a received GSM 8-PSK signal - 4 samples per symbol
		coef = [1.47478679242698E-02, 1.30180762135002E-02, -2.59693488052942E-03,
			-1.86886205838505E-02, -1.84301163005152E-02, 1.59290562571793E-03, 
			2.46765008848270E-02, 2.64728966185564E-02, -1.64625122944170E-03, 
			-3.92545231858231E-02, -4.92153941318734E-02, -9.91398994825257E-03, 
			5.86963178086561E-02, 1.01237554784347E-01, 6.72801762115508E-02, 
			-4.22753417582943E-02, -1.61722428601907E-01, -1.97761910085354E-01, 
			-9.59386008336843E-02, 1.11826303002963E-01, 3.17495339569120E-01, 
			4.02952079895321E-01, 3.17489974454372E-01, 1.11809805548301E-01, 
			-9.59704224166022E-02, -1.97803977507195E-01, -1.61760085829972E-01, 
			-4.22929193355027E-02, 6.72882983790084E-02, 1.01262375942860E-01, 
			5.87201535045995E-02, -9.90544831338717E-03, -4.92240828136400E-02, 
			-3.92705651175501E-02, -1.65682920621798E-03, 2.64738620754728E-02, 
			2.46852298036295E-02, 1.60061454841952E-03, -1.84293773250279E-02, 
			-1.86938058855573E-02, -2.60225048347017E-03, 1.30174103240028E-02, 
			1.47517052169543E-02, 3.55399816558396E-03, -8.54765062370833E-03];
	    break;
	case 3:
		//  This is a 88th order FIR filter that implements a receive filter to 
		//  eliminate ISI on a received GSM 8-PSK signal - 8 samples per symbol
		coef = [6.28252355563327E-03, 9.13379997914076E-03, 9.86379909606592E-03, 
			8.06163950730823E-03, 3.95048700518632E-03, -1.60932002749299E-03, 
			-7.28467721159463E-03, -1.15745433893463E-02, -1.31892860261015E-02, 
			-1.14133290559221E-02, -6.35562950137996E-03, 9.87854558784297E-04, 
			8.89493493951809E-03, 1.52832566587508E-02, 1.82101605468444E-02, 
			1.63942019047489E-02, 9.62957516912632E-03, -1.02172695658508E-03, 
			-1.33321556903090E-02, -2.43128159650627E-02, -3.08548370141016E-02, 
			-3.04795818264658E-02, -2.20305459714769E-02, -6.13684568024191E-03, 
			1.46852810694800E-02, 3.63558825094224E-02, 5.39513738730687E-02, 
			6.27006769710207E-02, 5.90640672105246E-02, 4.16660453825426E-02, 
			1.18660851277347E-02, -2.61881070556701E-02, -6.60814495713729E-02, 
			-1.00165653097155E-01, -1.20934085117168E-01, -1.22482852280419E-01, 
			-1.01770628505826E-01, -5.94148665558548E-02, 1.57593141263665E-04, 
			6.92665513925186E-02, 1.38164371489473E-01, 1.96648401390977E-01, 
			2.35807314109287E-01, 2.49576102031974E-01, 2.35805923011149E-01, 
			1.96645048306923E-01, 1.38158096859900E-01, 6.92563260993526E-02, 
			1.42694557051098E-04, -5.94345173214849E-02, -1.01794257009983E-01, 
			-1.22508809563376E-01, -1.20960032817928E-01, -1.00188924938295E-01, 
			-6.60995175411514E-02, -2.61990545842936E-02, 1.18631849770371E-02, 
			4.16709301330832E-02, 5.90753097614780E-02, 6.27159334775138E-02, 
			5.39678058624371E-02, 3.63706677591722E-02, 1.46961098868244E-02, 
			-6.13138759398947E-03, -2.20307812711120E-02, -3.04847644069368E-02, 
			-3.08633800266126E-02, -2.43226688927505E-02, -1.33412458151048E-02, 
			-1.02837119628299E-03, 9.62637086851789E-03, 1.63946099615894E-02, 
			1.82135815157674E-02, 1.52885269542787E-02, 8.90063567347829E-03, 
			9.92646633573464E-04, -6.35271930587672E-03, -1.14127299529050E-02, 
			-1.31908436050627E-02, -1.15776157106435E-02, -7.28833335863118E-03, 
			-1.61258707400917E-03, 3.94838962606318E-03, 8.06113167345309E-03, 
			9.86487171994889E-03, 9.13605480321787E-03, 6.28530298151893E-03, 
			2.20181639251877E-03, -2.00457166223954E-03];
		break;
	case 4:
	    //  This is a 176th order FIR filter that implements a receive filter to 
            //  eliminate ISI on a received GSM 8-PSK signal - 16 samples per symbol
		coef = [2.46475724262358E-03, 3.57838422343912E-03, 4.51458694235788E-03,
			5.20233519355633E-03, 5.58365707112597E-03, 5.61808024929273E-03, 
			5.28612749502953E-03, 4.59159638570838E-03, 3.56242031266511E-03, 
			2.24999079033183E-03, 7.26915186072386E-04, -9.16716321868418E-04, 
			-2.57838158782272E-03, -4.14922986477752E-03, -5.52089309423203E-03, 
			-6.59259973770791E-03, -7.27814811512292E-03, -7.51228500983517E-03, 
			-7.25605232762482E-03, -6.50070994473476E-03, -5.26991487071135E-03, 
			-3.61993208259858E-03, -1.63776587901861E-03, 5.62773948647464E-04, 
			2.84692671393931E-03, 5.06648486199982E-03, 7.06856031777610E-03, 
			8.70512902927908E-03, 9.84279804481641E-03, 1.03721988519211E-02, 
			1.02164047827553E-02, 9.33780085814419E-03, 7.74290116039211E-03, 
			5.48470915674289E-03, 2.66234568205046E-03, -5.82179044168474E-04, 
			-4.07000710881322E-03, -7.59407526931439E-03, -1.09299792436054E-02, 
			-1.38485305631294E-02, -1.61293506155155E-02, -1.75747535046617E-02, 
			-1.80231161406657E-02, -1.73609252253766E-02, -1.55327287763251E-02, 
			-1.25483041466816E-02, -8.48648206296581E-03, -3.49523131755641E-03, 
			2.21219663895500E-03, 8.36504988628091E-03, 1.46465496204484E-02, 
			2.07086020103594E-02, 2.61890942384367E-02, 3.07309483723667E-02, 
			3.40019738012321E-02, 3.57144741783982E-02, 3.56435344763650E-02, 
			3.36429413439540E-02, 2.96577757985085E-02, 2.37328584866644E-02, 
			1.60164182555312E-02, 6.75858564871301E-03, -3.69542722718954E-03, 
			-1.49173235215224E-02, -2.64124815166286E-02, -3.76408009656098E-02, 
			-4.80407245363923E-02, -5.70553297583492E-02, -6.41592464605863E-02, 
			-6.88850758411196E-02, -7.08479755836093E-02, -6.97671329079248E-02, 
			-6.54829724898219E-02, -5.79691335507422E-02, -4.73384914173659E-02, 
			-3.38427817970404E-02, -1.78656968131122E-02, 9.03552852182699E-05, 
			1.94233165121342E-02, 3.94555642535425E-02, 5.94619473939528E-02, 
			7.87004961740608E-02, 9.64443810017536E-02, 1.12013618247187E-01, 
			1.24805018730223E-01, 1.34318947832713E-01, 1.40181611661011E-01, 
			1.42161794368040E-01, 1.40181237102262E-01, 1.34318155674776E-01, 
			1.24803726331046E-01, 1.12011710024716E-01, 9.64417178991448E-02, 
			7.86969273311404E-02, 5.94573232851187E-02, 3.94497504539937E-02, 
			1.94162072062002E-02, 8.18856355384302E-05, -1.78755402588211E-02, 
			-3.38539533772254E-02, -4.73508818702933E-02, -5.79825691490612E-02, 
			-6.54972179646857E-02, -6.97818981097978E-02, -7.08629256065901E-02, 
			-6.88998441314218E-02, -6.41734502497750E-02, -5.70685870185719E-02, 
			-4.80526715565786E-02, -3.76511096002189E-02, -2.64208751648563E-02, 
			-1.49235909546638E-02, -3.69943349175005E-03, 6.75689187079101E-03, 
			1.60170012592312E-02, 2.37355963452160E-02, 2.96624653443711E-02, 
			3.36493070949566E-02, 3.56512410603937E-02, 3.57231416229297E-02, 
			3.40111949022978E-02, 3.07403072495208E-02, 2.61981851237712E-02, 
			2.07170473134846E-02, 1.46540163575785E-02, 8.37126365709443E-03, 
			2.21695247395692E-03, -3.49206174206923E-03, -8.48494714563335E-03, 
			-1.25483731074009E-02, -1.55342963029004E-02, -1.73638196903282E-02, 
			-1.80271108746062E-02, -1.75795804605943E-02, -1.61347156456637E-02, 
			-1.38541294620650E-02, -1.09355136914521E-02, -7.59926783686614E-03, 
			-4.07461455996151E-03, -5.86003285023060E-04, 2.65944951083858E-03, 
			5.48282777669764E-03, 7.74206158805025E-03, 9.33797213281730E-03, 
			1.02175027673446E-02, 1.03740937219004E-02, 9.84532394394902E-03, 
			8.70809526763029E-03, 7.07176342308738E-03, 5.06972077214220E-03, 
			2.85000241613352E-03, 5.65517928213696E-04, -1.63549492587000E-03, 
			-3.61823869733660E-03, -5.26886272719977E-03, -6.50032032254183E-03, 
			-7.25630514155676E-03, -7.51312222515840E-03, -7.27947924490847E-03, 
			-6.59430900818199E-03, -5.52284778175217E-03, -4.15128925803459E-03, 
			-2.58040601302267E-03, -9.18575686808633E-04, 7.25333823137290E-04, 
			2.24877704336935E-03, 3.56163599843485E-03, 4.59127296310070E-03, 
			5.28626549057177E-03, 5.61865062245529E-03, 5.58460435651091E-03, 
			5.20358215455649E-03, 4.51604038820772E-03, 3.57994158312886E-03, 
			2.46631345769068E-03, 1.25417952513271E-03, 2.52052237038024E-05];
		break;
	case 5:
		// windowed RC FIR receive filter for EDGE - see EDGE_RC_Window_RCFilter ADS
		// component - 4 samples per symbol - 30th order - 7.5 symbols
		coef = [0.000000000000000E+00, 2.532600072905060E-03, 6.255149696105850E-03,
			-6.069107141718640E-04, -3.033903819733090E-02, -8.331103859250570E-02,
			-1.397456508704710E-01, -1.636815480215440E-01, -1.201219556760560E-01,
			2.910925536008380E-03, 1.865241014426310E-01, 4.056646413651200E-01,
			6.293563278976120E-01, 8.226687915027710E-01, 9.536630282377270E-01,
			1.000000000000000E+00, 9.536630282377460E-01, 8.226687915027870E-01,
			6.293563278976260E-01, 4.056646413651280E-01, 1.865241014426360E-01,
			2.910925536009240E-03, -1.201219556760570E-01, -1.636815480215470E-01,
			-1.397456508704740E-01, -8.331103859250700E-02, -3.033903819733130E-02,
			-6.069107141717890E-04, 6.255149696106020E-03, 2.532600072905120E-03,
			0.000000000000000E+00];
		break;
	case 6:
		// windowed RC FIR receive filter for EDGE - see EDGE_RC_Window_RCFilter ADS
		// component - 8 samples per symbol - 60th order - 7.5 symbols
		coef = [0.000000000000000E+00, 6.744429157543910E-04, 2.532599567487290E-03,
			4.837898675424280E-03, 6.255148345668070E-03, 5.044874890981020E-03,
			-6.069105377199470E-04, -1.217076937958670E-02, -3.033903261972330E-02,
			-5.465825688424180E-02, -8.331102681771570E-02, -1.131112977460300E-01,
			-1.397456386807250E-01, -1.582516742491740E-01, -1.636815459881800E-01,
			-1.518600876052710E-01, -1.201219723959110E-01, -6.790485971651370E-02,
			2.910890123291700E-03, 8.866557672348450E-02, 1.865240557090720E-01,
			2.934202925671710E-01, 4.056645964798900E-01, 5.191110151077320E-01,
			6.293562938212620E-01, 7.319593611317040E-01, 8.226687729915290E-01,
			8.976448088018660E-01, 9.536630230415510E-01, 9.882870220187200E-01,
			1.000000000000000E+00, 9.882870220187390E-01, 9.536630230415700E-01,
			8.976448088018840E-01, 8.226687729915450E-01, 7.319593611317200E-01,
			6.293562938212750E-01, 5.191110151077440E-01, 4.056645964798980E-01,
			2.934202925671790E-01, 1.865240557090760E-01, 8.866557672348790E-02,
			2.910890123292450E-03, -6.790485971651360E-02, -1.201219723959120E-01,
			-1.518600876052730E-01, -1.636815459881840E-01, -1.582516742491760E-01,
			-1.397456386807270E-01, -1.131112977460320E-01, -8.331102681771700E-02,
			-5.465825688424270E-02, -3.033903261972370E-02, -1.217076937958680E-02,
			-6.069105377198600E-04, 5.044874890981210E-03,	6.255148345668260E-03,
			4.837898675424420E-03, 2.532599567487350E-03, 6.744429157544090E-04,
			0.000000000000000E+00];
		break;
	case 7:
		// windowed RC FIR receive filter for EDGE - see EDGE_RC_Window_RCFilter ADS
		// component - 16 samples per symbol - 120th order - 7.5 symbols
		coef = [0.000000000000000E+00, 1.687710249789260E-04, 6.744460490953750E-04,
			1.486336357508310E-03, 2.532610755098220E-03, 3.700332111739890E-03,
			4.837918876864940E-03, 5.760082996699140E-03, 6.255172792555180E-03,
			6.094723242972430E-03, 5.044892790306770E-03, 2.879351425332030E-03,
			-6.069146150295340E-04, -5.583495144938780E-03, -1.217081262444920E-02,
			-2.042743503989390E-02, -3.033913020627690E-02, -4.181030711190530E-02,
			-5.465841812277220E-02, -6.861179369535980E-02, -8.331125213816010E-02,
			-9.831567573755000E-02, -1.131115772630360E-01, -1.271265045046310E-01,
			-1.397459527627670E-01, -1.503332841398420E-01, -1.582519960793260E-01,
			-1.628895474734670E-01, -1.636818456627240E-01, -1.601374275269220E-01,
			-1.518603369705630E-01, -1.385707121467590E-01, -1.201221496540830E-01,
			-9.651500869096260E-02, -6.790495287587630E-02, -3.460619643512200E-02,
			2.910881627711210E-03, 4.411180405118770E-02, 8.866564302191800E-02, 
			1.362572467524980E-01, 1.865241806772650E-01, 2.390603734952790E-01, 
			2.934204565525380E-01, 3.491247425288640E-01, 4.056647785832050E-01, 
			4.625093992340340E-01, 5.191111954860070E-01, 5.749133092186730E-01, 
			6.293564557663200E-01, 6.818860730544000E-01, 7.319594927067920E-01, 
			7.790530272610330E-01, 8.226688680589540E-01, 8.623416905214280E-01, 
			8.976448673425860E-01, 9.281961955956120E-01, 9.536630507456880E-01, 
			9.737668890051540E-01, 9.882870292056940E-01, 9.970636562437930E-01, 
			1.000000000000000E+00, 9.970636562438120E-01, 9.882870292057130E-01, 
			9.737668890051730E-01, 9.536630507457070E-01, 9.281961955956300E-01, 
			8.976448673426040E-01, 8.623416905214450E-01, 8.226688680589700E-01, 
			7.790530272610490E-01, 7.319594927068080E-01, 6.818860730544150E-01, 
			6.293564557663330E-01, 5.749133092186860E-01, 5.191111954860190E-01, 
			4.625093992340450E-01, 4.056647785832130E-01, 3.491247425288730E-01, 
			2.934204565525460E-01, 2.390603734952860E-01, 1.865241806772700E-01, 
			1.362572467525020E-01, 8.866564302192140E-02, 4.411180405119070E-02, 
			2.910881627712040E-03, -3.460619643512070E-02, -6.790495287587610E-02, 
			-9.651500869096260E-02, -1.201221496540840E-01, -1.385707121467600E-01, 
			-1.518603369705650E-01, -1.601374275269240E-01, -1.636818456627270E-01, 
			-1.628895474734690E-01, -1.582519960793280E-01, -1.503332841398440E-01, 
			-1.397459527627690E-01, -1.271265045046330E-01, -1.131115772630380E-01, 
			-9.831567573755130E-02, -8.331125213816130E-02, -6.861179369536070E-02, 
			-5.465841812277300E-02, -4.181030711190580E-02, -3.033913020627720E-02, 
			-2.042743503989410E-02, -1.217081262444920E-02, -5.583495144938710E-03, 
			-6.069146150294140E-04, 2.879351425332210E-03, 5.044892790306980E-03, 
			6.094723242972630E-03, 6.255172792555370E-03, 5.760082996699310E-03, 
			4.837918876865080E-03, 3.700332111740000E-03, 2.532610755098290E-03, 
			1.486336357508360E-03, 6.744460490953930E-04, 1.687710249789300E-04, 
			0.000000000000000E+00];
		break;
	default:
	    coef = [-0.02671871185186,-0.02671871185186,-0.03131657336036,-0.03513493132653,
		-0.03616193801025,-0.03243366802238,-0.02308841004573,-0.00839819805998, 
		0.01059179343037, 0.03208587248081, 0.05367493279900, 0.07237904357437, 
		0.08544732263773, 0.09043119988701, 0.08599633949606, 0.07197409567520, 
		0.04968161719728, 0.02191263931530,-0.00758519857386,-0.03418964024042,
		-0.05362545112499,-0.06207719550442,-0.05744869563707,-0.03944096957569,
		-0.01000740390519, 0.02666324346521, 0.06497595461134, 0.09805083272766, 
		0.11956437575562, 0.12391877934968, 0.10812532850091, 0.07192392083037, 
		0.01852918741923,-0.04538430655640,-0.11075376868863,-0.16629352009196,
		-0.20106078513105,-0.20469906238535,-0.17022649614174,-0.09422856514621, 
		0.02169113635235, 0.17088353651264, 0.34250290097358, 0.52167763156590, 
		0.69241902289217, 0.83791623310893, 0.94411688455071, 1.00000000000000, 
		1.00000000000000, 0.94411688455071, 0.83791623310893, 0.69241902289217, 
		0.52167763156590, 0.34250290097358, 0.17088353651264, 0.02169113635235,
		-0.09422856514621,-0.17022649614174,-0.20469906238535,-0.20106078513105,
		-0.16629352009196,-0.11075376868863,-0.04538430655640, 0.01852918741923, 
		0.07192392083037, 0.10812532850091, 0.12391877934968, 0.11956437575562, 
		0.09805083272766, 0.06497595461134, 0.02666324346521,-0.01000740390519,
		-0.03944096957569,-0.05744869563707,-0.06207719550442,-0.05362545112499,
		-0.03418964024042,-0.00758519857386, 0.02191263931530, 0.04968161719728, 
		0.07197409567520, 0.08599633949606, 0.09043119988701, 0.08544732263773, 
		0.07237904357437, 0.05367493279900, 0.03208587248081, 0.01059179343037,
		-0.00839819805998,-0.02308841004573,-0.03243366802238,-0.03616193801025,
		-0.03513493132653,-0.03131657336036,-0.02671871185186,-0.02671871185186];
	    break;
    }

    return coef;
}

//*********************************************************************************************************

defun kmm_lagrange_interp(u_data, u_tstart, u_tstop, u_tincr)
{
    decl tstart = u_tstart == NULL ? 0 : u_tstart;
    decl tstop = u_tstop == NULL ? 0 : u_tstop;
    decl tincr = u_tincr == NULL ? 0 : u_tincr;

    if (tstop < tstart) {
	print_function_error("kmm_lagrange_interp","tstart must be equal to or greater than tstop.");
	return;
    }

    if (tincr <= 0.0) {
	print_function_error("kmm_lagrange_interp","tincr must be greater than zero.");
	return;
    }

    decl data = u_data + 0.0;
    decl data_size = sweep_size(data);
    decl tdata = indep(u_data);

    if (data == NULL || data_size < 2)  {
	print_function_error("kmm_lagrange_interp","Insufficient number of data points.");
	return;
    }

    if (tstart < tdata[0]) {
        print_function_error("kmm_lagrange_interp", "tstart before start time of data.");
        return;
    }

    if (tstop > tdata[data_size - 1]) {
        print_function_error("kmm_lagrange_interp", "tstop beyond end time of data.");
        return;
    }

    // this interpolator uses 4 samples to determine a single interpolation point
    decl ksize, ka, kb;
    ksize = data_size - 3;
    decl f1_data = data[0::ksize-1] + 0.0;
    decl f2_data = data[0::ksize-1] + 0.0;
    decl f3_data = data[0::ksize-1] + 0.0;
    decl f1_coef = {0.166666666666666, -0.5, 0.5, -0.166666666666666};
    decl f2_coef = {0.0, 0.5, -1.0, 0.5};
    decl f3_coef = {-0.166666666666666, 1.0, -0.5, -0.333333333333333};  
    if (data_size > 3) {
        for (ka = 0; ka < ksize; ka++) {
	    f1_data[ka] = data;

	}

    }

    decl func_out = 10.0;
    return func_out;

}






//*********************************************************************************************************
//
// ***** DO NOT DELETE THE FOLLOWING!!!!! *****
//
// This obviously isn't a C++ file, but the C++ editing mode works.
//
// Local Variables:
// mode: c++
// header-comment-character: ?*
// header-prefix: "/* -*-C++-*-"
// header-suffix: "*/"
// End:
//
//


//
// ***** DO NOT DELETE THE FOLLOWING!!!!! *****
//
// This obviously isn't a C++ file, but the C++ editing mode works.
//
// Local Variables:
// mode: c++
// header-comment-character: ?*
// header-prefix: "/* -*-C++-*-"
// header-suffix: "*/"
// End:
//
//

