// Copyright Keysight Technologies 1997 - 2015  
// 
/***********************************************/
/* convert ADS designs to iff file             */
/***********************************************/

/*************************************************************************
 **************************** ADS 2002  **********************************
 *************************************************************************
 *  02/25/02    - mdm.
 *      - Add copyright string.
 *      - Changed function: iff_build_wire_list(.) to accommodate the case
 *        where there are tee's (not just pins) connected to wires.
 *        Ref. ATM Framewrk_Lks.1367.
 *  02/26/02    - mdm.
 *      - Fixed error in iffGetPinWireLabel(.). This code was broken-out
 *        of a previous function and had a flaw where a wire name would
 *        be deduced from visits to an instance's pin list. This could
 *        lead to connection dependent results.
 */

/////////////////////////////////////////////////////////////////////////////
//
// IFF for MDS has a bug in Layout where the artcomp rotation is
// switched depending on the state of the current instance.
//
//                           MDS    S4
//       DESIGN   INSTANCE   FLIP  FLIP
//       ------   --------   ----  ----
//         F         F        F     F
//         T         T        F     T
//         T         F        T     F
//         F         T        T     T
//
// The following allows IFF to support the "bug" mode of flipping.
//
/////////////////////////////////////////////////////////////////////////////


/* MTB - 4/26/01 Per ATM issue Framewrk_Lks.1285, changing this 
   IffSupportMdsFlipBug to FALSE by default. */
decl IffSupportMdsFlipBug = FALSE;

decl IffAddCommentsToIff = FALSE;

decl LineRule = 1;
decl ShadeRule = 1; // TODO: Remove this global variable. Use iff_get_ShadeRule_value(context, shape)

decl LibraryAddPartFile;
LibraryAddPartFile = "libraryadd.ael";

decl IFILE_VER, SEP_CHAR;
SEP_CHAR = chr(255);         /* 377 octal */
IFILE_VER = 2;

decl AREA_UNIT, NO_UNIT;
AREA_UNIT  = -2; 
NO_UNIT    = -1;

decl TopDesignName, TopDesignCode, TopDesignPath;
decl UserUnits, UserMksScale, drawpageUserUnits;
decl DesignList, SymbolList;
decl OutputList, NumOutputLines;
decl DefaultLibraryPath, PortStack;
decl ObjectPathList;
decl layoutUnits;
decl currentColor, currentFill;
decl currentLineRule = 2; // TODO: Remove this global variable. Use iff_get_lineRule_value(context, shape)
decl defaultMaskName;
decl repType, ProjectName;
decl InstID, InstX, InstY, InstAngle, InstIsLeaf, InstTransform;

decl TransferTypeName;
decl MGCxferDirectory = "";
decl MGCschIffFileName = "";
decl MGClayIffFileName = "";
decl MGCpromptForUserMessage = FALSE;

decl IffOverwriteFile = TRUE;
decl IffExportProjectList;
decl IffExportHierOption;
decl IffWorkSpaceCellList;

// The data_dialog() needs some data too work correctly. If
// no data present it never calls the callback.
decl MGCuserMessage = " ";

InstID = 1;

decl iffOpenWinInst;
decl iffOpenWinInstId;
decl iffOpenedWindow;

decl IffLineThickProp = "line_thickness_prop";

decl IffBadNamedConnList;
decl IffReNamedNodeList;


decl IffBadPinNameProperty = "IFF_PIN_NAME";
decl IffBadInstNameProperty = "IFF_INSTANCE_NAME";

decl IffIgnoreDeactivatedComponents = FALSE;
decl IffStoreSchemAnnotPos = FALSE;
decl IffPrefixLibNameToCellName = FALSE; //libName_cellName
// HPEESOF_FULL_PATH property only makes sense for library components imported from the other CAD tool
decl IffIgnorePathProperty = TRUE;
decl IffAdsProperties = TRUE;

decl IffSubDesignAsLeaf = FALSE;

decl IffUsePortNameAsNet = TRUE;
decl IffOverwriteExistingDesign = FALSE;

defun iff_get_get_top_design_context()
{
    return de_get_current_design_context();
}


/////////////////////////////////////////////////////////////////////////////
// Forward definitions
/////////////////////////////////////////////////////////////////////////////

defun param_value_dm_class(paramHandle){};
defun iff_display_status_dialog(){};

/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
defun iff_comment_char( ch )
{
  return( ch == "!" || ch == ";" || ch == "*" );
}

/////////////////////////////////////////////////////////////////////////////
// This function returns the name of the current design without any path 
// information.
/////////////////////////////////////////////////////////////////////////////
defun iff_current_design_name()
{
    decl context = de_get_current_design_context();
    return(db_get_appropriate_base_name(context));
}

defun iff_get_short_design_name(context)
{
    decl name;
    if(IffPrefixLibNameToCellName)
    {
        name = db_get_appropriate_base_name(context);
    }
    else
    {
        decl designName = db_get_design_name(context);
        decl libName, cellName, viewName;
        de_parse_lib_cell_view_name(designName, &libName, &cellName, &viewName);
        name = cellName;
    }
    return name;
}

/////////////////////////////////////////////////////////////////////////////
// Map the ADS Pattern index into a IFF pattern string.
/////////////////////////////////////////////////////////////////////////////
defun mapPattern(index)
{
  decl	pattern;

  if(index == 0)		// pat1
    pattern = "solid";    
  else if(index == 1)		// pat2
    pattern = "solid";    
  else if(index == 2)		// pat3
    pattern = "solid";    
  else if(index == 3)		// pat4
    pattern = "solid";    
  else if(index == 4)		// pat5
    pattern = "solid";    
  else if(index == 5)		// pat6
    pattern = "solid";    
  else if(index == 6)		// pat7
    pattern = "90 deg thin";    
  else if(index == 7)		// pat8
    pattern = "0 deg thin";    
  else if(index == 8)		// pat9
    pattern = "solid";    
  else if(index == 9)		// pat10
    pattern = "solid";    
  else if(index == 10)		// pat11
    pattern = "solid";    
  else if(index == 11)		// pat12
    pattern = "solid";    
  else if(index == 12)		// pat13
    pattern = "solid";    
  else if(index == 13)		// pat14
    pattern = "solid";    
  else if(index == 14)		// pat15
    pattern = "solid";    
  else if(index == 15)		// pat17
    pattern = "30 deg thick";    
  else if(index == 16)		// pat18
    pattern = "solid";    
  else if(index == 17)		// pat19
    pattern = "solid";    
  else if(index == 18)		// pat20
    pattern = "solid";    
  else if(index == 19)		// arrows_ctr
    pattern = "solid";    
  else if(index == 20)		// arrows_ll
    pattern = "30 deg thin";    
  else if(index == 21)		// arrows_lr
    pattern = "150 deg thin";   
  else if(index == 22)		// arrows_ul
    pattern = "150 deg thin";    
  else if(index == 23)		// arrows_ur
    pattern = "30 deg thin";    
  else if(index == 24)		// boxes_dark
    pattern = "squares";    
  else if(index == 25)		// boxes_light
    pattern = "squares";    
  else if(index == 26)		// chainlink_inv
    pattern = "solid";    
  else if(index == 27)		// chainlink_norm
    pattern = "solid";    
  else if(index == 28)		// circles_conc
    pattern = "solid";    
  else if(index == 29)		// circles_small
    pattern = "solid";   
  else if(index == 30)		// diag_dark
    pattern = "120 deg thin";    
  else if(index == 31)		// diag_dark2
    pattern = "60 deg thin";    
  else if(index == 32)		// diag_med
    pattern = "60 deg thick";    
  else if(index == 33)		// diag_mix_dark
    pattern = "60 deg thick";    
  else if(index == 34)		// diag_mix_light
    pattern = "60 deg thick";    
  else if(index == 35)		// fancy1
    pattern = "solid";    
  else if(index == 36)		// fancy2
    pattern = "solid";    
  else if(index == 37)		// fancy3
    pattern = "solid";    
  else if(index == 38)		// fancy4
    pattern = "solid";    
  else if(index == 39)		// radar_ul
    pattern = "shadow boxes";    
  else if(index == 40)		// metal_light
    pattern = "solid";    
  else if(index == 41)		// panes_inv
    pattern = "squares";    
  else if(index == 42)		// panes_norm
    pattern = "squares";    
  else if(index == 43)		// parque_inv
    pattern = "solid";    
  else if(index == 44)		// parque_norm
    pattern = "solid";    
  else if(index == 45)		// pyramid
    pattern = "solid";    
  else if(index == 46)		// quilt
    pattern = "honeycomb";    
  else if(index == 47)		// radar_ll
    pattern = "solid";    
  else if(index == 48)		// radar_lr
    pattern = "solid";    
  else if(index == 49)		// radar_ul
    pattern = "shadow boxes";    
  else if(index == 50)		// radar_ur
    pattern = "solid";    
  else if(index == 51)		// random_dark
    pattern = "solid";    
  else if(index == 52)		// random_dark2
    pattern = "solid";    
  else if(index == 53)		// random_light
    pattern = "solid";    
  else if(index == 54)		// random_light2
    pattern = "solid";    
  else if(index == 55)		// solid
    pattern = "solid";    
  else if(index == 56)		// triang_down
    pattern = "solid";    
  else if(index == 57)		// triang_inv
    pattern = "solid";    
  else if(index == 58)		// triang_left
    pattern = "solid";    
  else if(index == 59)		// triang_norm
    pattern = "solid";    
  else if(index == 60)		// triang_right
    pattern = "solid";    
  else if(index == 61)		// triang_up
    pattern = "solid";    
  else if(index == 62)		// waves_left
    pattern = "solid";    
  else if(index == 63)		// waves_right
    pattern = "solid";    
  else if(index == 64)		// weave_dark
    pattern = "solid";    
  else if(index == 65)		// weave_light
    pattern = "solid";    
  else if(index == 66)		// zigzag_1
    pattern = "solid";    
  else if(index == 67)		// zigzag_2
    pattern = "solid";    
  else if(index == 68)		// zigzag_3
    pattern = "solid";    
  else if(index == 69)		// zigzag_4
    pattern = "solid";    
  else if(index == 70)		// one
    pattern = "plus signs";    
  else if(index == 71)		// two
    pattern = "plus signs";    
  else if(index == 72)		// three
    pattern = "plus signs";    
  else if(index == 73)		// four
    pattern = "plus signs";    
  else if(index == 74)		// five
    pattern = "plus signs";    
  else if(index == 75)		// six
    pattern = "plus signs";    
  else if(index == 76)		// seven
    pattern = "plus signs";    
  else if(index == 77)		// seven
    pattern = "plus signs";    
  else 
    pattern = "solid"; 

  return(pattern);
}

/////////////////////////////////////////////////////////////////////////////
// Unmap the IFF pattern back to a ADS pattern index.
/////////////////////////////////////////////////////////////////////////////
defun iff_unMapPattern(pattern)
{
  decl	index;

  if( pattern == "solid" )      
    index = 0;                        // pat1
  else if( pattern == "squares" )
    index = 24;		               // boxes_dark
  else if( pattern == "shadow boxes" )
    index = 39;		               // radar_ul
  else if( pattern == "plus signs" )
    index = 70;		               // one
  else if( pattern == "honeycomb" )
    index = 46;		               // quilt
  else if( pattern == "0 deg thin" )
    index = 7;		               // pat8
  else if( pattern == "30 deg thin" )
    index = 20;		               // arrows_ll
  else if( pattern == "60 deg thin" )
    index = 31;		               // diag_dark2
  else if( pattern == "90 deg thin" )     
    index = 6;		               // pat7
  else if( pattern == "120 deg thin" )
    index = 30;		               // diag_dark
  else if( pattern == "150 deg thin" )
    index = 21;		               // arrows_lr
  else if( pattern == "0 deg thick" )
    index = 14;		               // pat15
  else if( pattern == "30 deg thick" )
    index = 15;		               // pat17
  else if( pattern == "60 deg thick" )
    index = 32;		               // diag_med
  else if( pattern == "90 deg thick" )
    index = 33;		               // diag_mix_dark
  else if( pattern == "120 deg thick" )
    index = 34;		               // diag_mix_light
  else if( pattern == "150 deg thick" )
    index = 35;		               // fancy1
  else
    index = 0;                         // pat1

  return(index);
}

defun mapColor(index)
{
  decl	color;

  if(index == 0)		// black
    color = "black";    
  if(index == 1)		// red
    color = "red";    
  else if(index == 2)		// yellow
    color = "yellow";    
  else if(index == 3)		// green
    color = "green";    
  else if(index == 4)		// cyan
    color = "cyan";    
  else if(index == 5)		// blue
    color = "blue";    
  else if(index == 6)		// magenta
    color = "magenta";    
  else if(index == 7)		// gray
    color = "black";    
  else if(index == 8)		// white
    color = "white";    
  else if(index == 9)		// medium blue
    color = "blue";    
  else if(index == 10)		// DarkSlateGrey
    color = "black";    
  else if(index == 11)		// DimGrey
    color = "black";    
  else if(index == 12)		// SlateGrey
    color = "black";    
  else if(index == 13)		// MidnightBlue
    color = "Dk Blue";    
  else if(index == 14)		// NavyBlue
    color = "Dk Blue";    
  else if(index == 15)		// DarkSlateBlue
    color = "Dk Blue";    
  else if(index == 16)		// SlateBlue
    color = "blue";    
  else if(index == 17)		// MediumSlateBlue
    color = "blue";    
  else if(index == 18)		// medium blue
    color = "blue";    
  else if(index == 19)		// RoyalBlue
    color = "aqua";    
  else if(index == 20)		// blue
    color = "blue";    
  else if(index == 21)		// DodgerBlue
    color = "aqua";   
  else if(index == 22)		// SteelBlue
    color = "blue";    
  else if(index == 23)		// DarkGreen
    color = "Dk Green";    
  else if(index == 24)		// DarkOliveGreen
    color = "Dk Green";    
  else if(index == 25)		// SeaGreen
    color = "Dk Green";    
  else if(index == 26)		// ForestGreen
    color = "Dk Green";    
  else if(index == 27)		// OliveDrab
    color = "Dk Green";    
  else if(index == 28)		// IndianRed
    color = "brown";    
  else if(index == 29)		// SaddleBrown
    color = "brown";    
  else if(index == 30)		// sienna
    color = "brown";    
  else if(index == 31)		// firebrick
    color = "brown";    
  else if(index == 32)		// brown
    color = "brown";    
  else if(index == 33)		// OrangeRed
    color = "orange";    
  else if(index == 34)		// red
    color = "red";    
  else if(index == 35)		// DeepPink
    color = "mauve";    
  else if(index == 36)		// maroon
    color = "brown";    
  else if(index == 37)		// MediumVioletRed
    color = "mauve";    
  else if(index == 38)		// VioletRed
    color = "mauve";    
  else if(index == 39)		// magenta
    color = "magenta";    
  else if(index == 40)		// DarkOrchid
    color = "purple";    
  else if(index == 41)		// snow1
    color = "white";    
  else if(index == 42)		// snow2
    color = "white";    
  else if(index == 43)		// AntiqueWhite1
    color = "tan";    
  else if(index == 44)		// LemonChiffon1
    color = "tan";    
  else if(index == 45)		// ivory1
    color = "white";    
  else if(index == 46)		// honeydew1
    color = "white";    
  else if(index == 47)		// LavenderBlush1
    color = "tan";    
  else if(index == 48)		// LavenderBlush2
    color = "tan";    
  else if(index == 49)		// MistyRose1
    color = "tan";    
  else if(index == 50)		// MistyRose2
    color = "tan";    
  else if(index == 51)		// azure1
    color = "white";    
  else if(index == 52)		// azure2
    color = "white";    
  else if(index == 53)		// DodgerBlue2
    color = "blue";    
  else if(index == 54)		// SteelBlue1
    color = "aqua";    
  else if(index == 55)		// DeepSkyBlue1
    color = "aqua";    
  else if(index == 56)		// SkyBlue1
    color = "aqua";    
  else if(index == 57)		// LightSkyBlue1
    color = "aqua";    
  else if(index == 58)		// slateGray2
    color = "aqua";    
  else if(index == 59)		// LightSteelBlue1
    color = "aqua";    
  else if(index == 60)		// LightBlue1
    color = "white";    
  else if(index == 61)		// LightCyan1
    color = "cyan";    
  else if(index == 62)		// PaleTurquoise1
    color = "cyan";    
  else if(index == 63)		// CadetBlue1
    color = "cyan";    
  else if(index == 64)		// CadetBlue2
    color = "cyan";    
  else if(index == 65)		// turquoise1
    color = "cyan";    
  else if(index == 66)		// cyan1
    color = "cyan";    
  else if(index == 67)		// DarkSlateGray1
    color = "cyan";    
  else if(index == 68)		// aquamarine2
    color = "green";    
  else if(index == 69)		// DarkSeaGreen1
    color = "green";    
  else if(index == 70)		// DarkSeaGreen2
    color = "green";    
  else if(index == 71)		// SeaGreen1
    color = "green";    
  else if(index == 72)		// PaleGreen1
    color = "green";    
  else if(index == 73)		// SpringGreen1
    color = "green";    
  else if(index == 74)		// green1
    color = "green";    
  else if(index == 75)		// chartreuse1
    color = "green";    
  else if(index == 76)		// OliveDrab1
    color = "green";    
  else if(index == 77)		// DarkOliveGreen1
    color = "green";    
  else if(index == 78)		// khaki1
    color = "yellow";    
  else if(index == 79)		// LightGoldenrod1
    color = "yellow";    
  else if(index == 80)		// yellow1
    color = "yellow";    
  else if(index == 81)		// gold1
    color = "yellow";    
  else if(index == 82)		// goldenrod1
    color = "yellow";    
  else if(index == 83)		// sienna2
    color = "orange";    
  else if(index == 84)		// wheat2
    color = "tan";    
  else if(index == 85)		// chocolate1
    color = "orange";    
  else if(index == 86)		// brown1
    color = "red";    
  else if(index == 87)		// LightSalmon1
    color = "tan";    
  else if(index == 88)		// orange1
    color = "orange";    
  else if(index == 89)		// coral2
    color = "brown";   
  else if(index == 90)		// red2
    color = "red";    
  else if(index == 91)		// DeepPink1
    color = "mauve";    
  else if(index == 92)		// HotPink1
    color = "mauve";    
  else if(index == 93)		// pink1
    color = "mauve";    
  else if(index == 94)		// LightPink1
    color = "mauve";    
  else if(index == 95)		// PaleVioletRed1
    color = "mauve";    
  else if(index == 96)		// maroon1
    color = "mauve";    
  else if(index == 97)		// VioletRed1
    color = "mauve";    
  else if(index == 98)		// magenta1
    color = "magenta";    
  else if(index == 99)		// orchid1
    color = "magenta";    
  else if(index == 100)		// plum1
    color = "magenta";    
  else if(index == 101)		// thistle1
    color = "white";    
  else if(index == 102)		// gray52
    color = "black";  
  else if(index == 103)		// gray62
    color = "black";   
  else if(index == 104)		// gray72
    color = "black";    
  else if(index == 105)		// gray82
    color = "black";   
  else
    color = "black";    

  return(color);
}

// Get the nearest color match for the given RGB color (signed) value
defun oa_mapColor(RGB)
{
    decl color;

    if( RGB == 0x00000000 || RGB < 0x00000075 )   // black: index == 0;   RGB- 0 0 0
        color = "black";   //if( (RGB == 0) || (RGB < 125) )
    else if( RGB == 75 || (RGB > 0x00000075 && RGB < 0x000000F1) )   // NavyBlue
        color = "Dk Blue";
    else if(RGB == 0x000000FF || (RGB > 0x000000F1 && RGB < 0x000000FF))  // blue: RGB - 00 00 FF or > 00 00 F5
        color = "blue";
    else if (RGB == 0x0000D300 || (RGB > 0x00000F00 && RGB < 0x0000D300))    // Dk green: index == 25   RGB- 0 108 0
        color = "Dk green";
    else if ( RGB == 0x0000FF00 || (RGB > 0x0000D300 && RGB < 0x0000FF00))    // green: index == 3   RGB- 0 255 0
        color = "green";
    else if( RGB == 0x00F10000 || (RGB > 0x00750000 && RGB < 0x00F10000) )    // brown: index == 89   RGB- 128 0 0
        color = "brown";
    else if( RGB == 0x00FFFF00 || (RGB > 0x00F1F100 && RGB < 0x00FFFF00) )    // yellow: index == 2   RGB- 255 255 0
        color = "yellow";
    else if( RGB == 0x00FF00FF || (RGB > 0x00F100F1 && RGB < 0x00FF00FF)) // magenta: index == 100   RGB- 255 0 255
        color = "magenta";
    else if( RGB == 0x00FFC8B4 || (RGB > 0x00F77575 && RGB < 0x00FFC8B4) ) // tan: index == 84   RGB- 250 128 114
        color = "tan";
    else if( RGB == 0x00FFF100 || (RGB > 0x00F1A500 && RGB < 0x00FFF100)) // orange: index == 83   RGB- 255 165 0
        color = "orange";
    else if( RGB == 0x0000FFFF || (RGB > 0x0000F5F5 && RGB < 0x0000FFFF) )    // aqua: index == 59   RGB- 0 255 255
        color = "aqua";
    else if (RGB == 0x00FFFFFF || (RGB > 0x00F5F5F5 && RGB < 0x00FFFFFF))    // white: index == 45   RGB- 255 255 255
        color = "white";
    else
        color = "purple";

    return (color);
}

// Get the nearest color index for the given RGB color (signed) value
defun oa_mapIndex(RGB)
{
    decl index;

    if( RGB == 0x00000000 || RGB < 0x00000075 )   // black: RGB- 00 00 00 or < 00-00-75
        index = 0;
    else if( RGB == 75 || (RGB > 0x00000075 && RGB < 0x000000F1) )   // NavyBlue: RGB >= 00 00 75 && < 00 00 151
        index = 13;
    else if(RGB == 0x000000FF || (RGB > 0x000000F1 && RGB < 0x000000FF))  // blue: RGB - 00 00 FF or > 00 00 F5
        index = 20;
    else if (RGB == 0x0000D300 || (RGB > 0x00000F00 && RGB < 0x0000D300))    // Dk green: index == 25   RGB- 0 108 0
        index = 25;
    else if ( RGB == 0x0000FF00 || (RGB > 0x0000D300 && RGB < 0x0000FF00))    // green: RGB- 0 255 0 or > 00 135 00
        index = 3;
    else if( RGB == 0x00F10000 || (RGB > 0x00750000 && RGB < 0x00F10000) )    // brown: RGB- 128 0 0
        index = 89;
    else if(RGB == 0x00FF0000 || (RGB > 0x00F10000 && RGB < 0x00FF0000))    // brown1/ Red
        index = 86; 
    else if( RGB == 0x00FFFF00 || (RGB > 0x00F1F100 && RGB < 0x00FFFF00) )    // yellow: RGB- 255 255 0
        index = 2;
    else if( RGB == 0x00FF00FF || (RGB > 0x00F100F1 && RGB < 0x00FF00FF)) // magenta: RGB- 255 0 255
        index = 100;
    else if( RGB == 0x00FFF100 || (RGB > 0x00F1A500 && RGB < 0x00FFF100)) // orange: RGB- 255 165 0
        index = 83;
    else if( RGB == 0x00FFC8B4 || (RGB > 0x00F77575 && RGB < 0x00FFC8B4) ) // tan:  RGB- 250 128 114
        index = 84;
    else if( RGB == 0x0000FFFF || (RGB > 0x0000F5F5 && RGB < 0x0000FFFF) )    // aqua/cyan: RGB- 0 255 255 or > 0 155 155
        index = 59;
    else if (RGB == 0x00FFFFFF || (RGB > 0x00F5F5F5 && RGB < 0x00FFFFFF))    // white: RGB- 255 255 255 or > 245 245 245
        index = 45;
    else
        index = 40; // purple

    return (index);
}


//////////////////////////////////////////////////////////////////////
// Map the IFF color string to a ADS color number
//////////////////////////////////////////////////////////////////////
// TODO: REname this function
defun iff_unMapColor(color)
{
  decl	index;

  if( color == "black" )
    index = 0;		// black
  else if( color == "red" )
    index = 1;		// red
  else if( color == "yellow" )
    index = 2;		// yellow
  else if( color == "green" )
    index = 3;		// green
  else if( color == "cyan" )
    index = 4;		// cyan
  else if( color == "blue" )
    index = 5;		// blue
  else if( color == "white" )
    index = 8;		// white
  else if(color == "Dk Blue")
      index = 11; // Dark blue
  else if( color == "dk blue" )
    index = 13;		// MidnightBlue
  else if( color == "aqua" )
    index = 68;		// aquamarine2
  else if( color == "dk green" )
    index = 23;		// DarkGreen
  else if( color == "brown" )
    index = 32;		// brown
  else if( color == "orange" )
    index = 33;		// OrangeRed
  else if( color == "mauve" )
    index = 37;		// MediumVioletRed
  else if( color == "magenta" )
    index = 39;		// magenta
  else if( color == "purple" )
    index = 40;		// DarkOrchid
  else if( color == "tan" )
    index = 84;		// AntiqueWhite1
  else
    index = 0;

  return(index);
}

defun setDefaultMaskName(tmp) 
{
    defaultMaskName = tmp;
}

defun setCurrentColor(tmp) 
{
    currentColor = mapColor(tmp);
}

defun setCurrentFill(tmp) 
{
    //if (tmp = PLOT_OUTLINE)
    if (tmp == 0)
      currentFill = "OUTLINE";
    //ef (tmp == PLOT_FILLED)
    else if (tmp == 1)
      currentFill = "FILL";
    else 
      currentFill = "FILLOUTLINE";
}

defun getCurrentFill(tmp) 
{
    decl layerFill;
    if (tmp == 0)
      layerFill = "OUTLINE";
    else if (tmp == 1)
      layerFill = "FILL";
    else 
      layerFill = "FILLOUTLINE";

    return layerFill;
}

//////////////////////////////////////////////////////////////////////
// Simple function to normalize angle into a specified range
//////////////////////////////////////////////////////////////////////
defun iff_normalize_angle(connAngle, minAngle, maxAngle)
{
  while( connAngle >= maxAngle )
    connAngle = connAngle - 360;
  while( connAngle < minAngle )
    connAngle = connAngle + 360;
  return( connAngle );
}

// 0 Solid
// 1 Dot
// 2 Double Dot
// 3 Short Dash
// 4 Short Dot Dash
// 5 Long Dash
// 6 Long Dot Dash
defun getCurrentLineRule(lineType, lineThickness)
{
    if (is_string(lineThickness))
        lineThickness=val(lineThickness);

    decl currentLineRule = 2;
    if (lineType == 0)
    {
        if (lineThickness > 4)
            currentLineRule = 4;
        else
            currentLineRule = lineThickness;
    }
    else if (lineThickness == 2)
    {
        if (lineType == 6)
            currentLineRule = 6;    // Center
        else 
            currentLineRule = 8;    // Hidden
    }
    else if (lineThickness > 2)
    {
        currentLineRule = 12;     // Cutting
    }
    else
    {
        currentLineRule = 5;      // Dash, 0.1
    }
    return currentLineRule;
}

defun quoted_string(strg)
{
    strg = strcat("\"", strg);
    strg = strcat(strg, "\"");
    return(strg);
}

//given a list ("x",y,z), output a string "prm("x",y,z)"
defun fmt_param_tokens(valueList)
{
    decl newValue, paramValue;

    paramValue = "prm(";
    while(valueList)
    {
	//print_value(car(valueList));
        paramValue = strcat(paramValue, car(valueList));
	valueList = cdr(valueList);
	if(valueList)
	    paramValue = strcat(paramValue,",");
    }

    paramValue = strcat(paramValue,")");
    return(paramValue);
}

defun param_value_dm_null_class(paramHandle)
{
    if( IffDebugMessageLevel > 15 )
      print_value("Begin: param_value_dm_null_class");

    // currently not in use

    if( IffDebugMessageLevel > 15 )
      print_value("End:   param_value_dm_null_class");
    return(NULL);
}

defun param_value_dm_list_class(paramHandle)
{
    decl paramList, paramValue, tmpValue;

    if( IffDebugMessageLevel > 15 )
      print_value("Begin: param_value_dm_list_class");

    paramList = db_get_parm_attribute(paramHandle, PARM_VALUE_LIST);

    if(! paramList)
      {
	if( IffDebugMessageLevel > 15 )
	  print_value("End:   param_value_dm_list_class");
	
        return(NULL);
      }

    paramValue = "list(";

    while(paramList)
    {
        tmpValue = param_value_dm_class(paramList);
	if(tmpValue != NULL)
	    paramValue = strcat(paramValue, tmpValue);
        paramList = db_next_parm(paramList); 
	if(paramList && tmpValue != NULL)
	    paramValue = strcat(paramValue, ",");
    }
    paramValue = strcat(paramValue, ")");

    if( IffDebugMessageLevel > 15 )
      print_value("End:   param_value_dm_list_class");

    return(paramValue);
}

defun param_value_dm_named_list_class(paramHandle)
{
    decl formName, paramList, paramValue, tmpValue;

    if( IffDebugMessageLevel > 15 )
      print_value("Begin: param_value_dm_named_list_class");

    formName = db_get_parm_attribute(paramHandle,PARM_FORM_NAME);
    formName = quoted_string(formName);

    paramList = db_get_parm_attribute(paramHandle, PARM_VALUE_LIST);

    paramValue = list(formName);
    while(paramList)
    {
        tmpValue = param_value_dm_class(paramList);
	if(tmpValue != NULL)
	     paramValue = append(paramValue, list(tmpValue));
        paramList = db_next_parm(paramList); 
    }

    paramValue = fmt_param_tokens(paramValue); 

    if( IffDebugMessageLevel > 15 )
      print_value("End:   param_value_dm_named_list_class");

    return(paramValue);
}

defun param_value_dm_string_class(paramHandle)
{
    decl formName, paramValue;

    if( IffDebugMessageLevel > 15 )
      print_value("Begin: param_value_dm_string_class");

    formName = db_get_parm_attribute(paramHandle, PARM_FORM_NAME);
    paramValue = db_get_parm_attribute(paramHandle, PARM_VALUE_SVALUE);

    if( IffDebugMessageLevel > 15 )
      print_value("End:   param_value_dm_string_class");

    return(paramValue);
}

defun param_value_dm_name_class(paramHandle)
{
    decl formName, paramValue;
    decl localIffDebugMessageLevel=IffDebugMessageLevel;
    
    if( localIffDebugMessageLevel > 15 )
      print_value("Begin: param_value_dm_name_class");

    formName = db_get_parm_attribute(paramHandle, PARM_FORM_NAME);
    // paramValue = fmt_param_tokens(list(quoted_string(formName)));
    
    if (leftstr(formName, 1) == "\"" && rightstr(formName, 1) == "\"")
    {
        paramValue=midstr(formName, 1, strlen(formName)-2);
    }
    else
    {
        paramValue=formName;        
    }

    /*  
    if( formName != "def*" && formName != "default" )
      {
	  paramValue = strcat("list(prm(\"",formName,"\",\"\"))");
      }
      */

    if( localIffDebugMessageLevel > 15 )
      print_value("End:   param_value_dm_name_class");

    return(paramValue);
}

//////////////////////////////////////////////////////////////////////
// determine paramCode and call correct function to extract value
//////////////////////////////////////////////////////////////////////
defun param_value_dm_class(paramHandle)
{
    decl localDebugMessageLevel = IffDebugMessageLevel;

    decl valueCode = db_get_param_value_code(paramHandle);

    decl paramValue = NULL;
    if (valueCode == DM_NULL_CLASS)
    {
        paramValue = param_value_dm_null_class(paramHandle);
    }
    else if (valueCode == DM_LIST_CLASS)
    {
        paramValue = param_value_dm_list_class(paramHandle);
    }
    else if (valueCode == DM_NAMED_LIST_CLASS)
    {
        paramValue = param_value_dm_named_list_class(paramHandle);
    }
    else if (valueCode == DM_STRING_CLASS)
    {
        paramValue = param_value_dm_string_class(paramHandle);
    }
    else if (valueCode == DM_NAME_CLASS)
    {
        paramValue = param_value_dm_name_class(paramHandle);
    }
    else if ( localDebugMessageLevel > 15 )
        fprintf(stderr, "Unknown valueCode\n");

    return paramValue;
}

defun print_value(value)
{
    if (IffDebugMessageLevel > 10)
    {
        fputs(stderr,identify_value(value));
    }
}

// convert list to string w/SEP_CHAR between items instead of space
// return string
defun blanks_to_sepchar(inList)
{
  decl first, longStrg;

  //print_value(list(what_file(), what_line()));
  //print_value(fmt_tokens(inList));
  first=TRUE;
  while(inList)
  {
    if(first)
    {
      longStrg = car(inList);
      first=FALSE;
    }
    else
    {
      if((car(inList) == SEP_CHAR) || (car(inList) == NULL ))
        longStrg = strcat(longStrg,SEP_CHAR);
      else 
	longStrg = strcat(strcat(longStrg,SEP_CHAR),car(inList));
    }
    inList = cdr(inList);
  }

  longStrg = strcat(longStrg,SEP_CHAR);
  return(longStrg);
}

// convert list to string w/o spaces between items
// return string
defun iff_strip_inner_blanks(inList)
{
  decl first, longStrg;

  first=TRUE;
  while(inList)
  {
    if(first)
    {
      longStrg = car(inList);
      first=FALSE;
    }
    else
      longStrg = strcat(longStrg,car(inList));
    inList = cdr(inList);
  }

  return(longStrg);
}

//////////////////////////////////////////////////////////////////////
// Check to see if the special flag is set to anything we are interested
// in. Currently we only care about ports and grounds.
//////////////////////////////////////////////////////////////////////
defun iff_analyze_special(special)
{
  if(( special & INST_GND ) || ( special & INST_PORT ))
    return(FALSE);
  else
    return(TRUE);
}

defun iff_is_ground(special)
{
  return(special & INST_GND);
}

defun iff_is_port(special)
{
  return(special & INST_PORT);
}

defun iff_is_variable(special)
{
  return(special & INST_VARIABLE);
}

// input string should look like: /iconName:iconType/...
// parse off iconName and iconType and return remainder of string
defun next_icon_pair(parentPath, iconType, iconName)
{
  decl pos;

  *iconName = NULL;
  *iconType = NULL;

  // makes sure length is longer than 1 && that first char is /
  if(strlen(parentPath)<=1 || leftstr(parentPath,1) != "/")
    return(NULL);

  // get rid of the leading /
  parentPath = rightstr(parentPath,strlen(parentPath)-1);

  // find the : separator
  pos = index(parentPath, ":");
  if(pos == -1)
    return(NULL);      // not found, path not valid

  // strip off the iconName
  *iconName = leftstr(parentPath,pos);
  parentPath = rightstr(parentPath,strlen(parentPath)-pos-1);

  // find the next / or end of string

  pos = index(parentPath, "/");
  if(pos == -1)
  {
    *iconType = parentPath;
    parentPath = NULL;
  }
  else
  {
    //strip off the iconType and leave rest of parentPath to return
    *iconType = leftstr(parentPath,pos);
    parentPath = rightstr(parentPath, strlen(parentPath)-pos);
  }

  return(parentPath);
}

// find the design name from parent path
defun parse_parent_icon_name(fileHandle, parentPath)
{
  decl startPath, iconType, iconName;

  startPath = "/";
  while(parentPath)
  {
    // returns NULL when no pairs left
    parentPath = next_icon_pair(parentPath, &iconType, &iconName);
  }
  return(iconName);
}

decl LibraryPartsList;
LibraryPartsList = NULL;

defun add_library_partition(partitionID, partitionName, symbolList)
{
    LibraryPartsList = append(LibraryPartsList,
			list(partitionID, partitionName, symbolList));
}

// traverse LibraryPartsList looking for first occurrence of symbol
defun get_library_partition(partName)
{
  decl libList, partsList;
  libList = LibraryPartsList;

  while(libList)
  {
    partsList = nthcdr(2,car(libList));
    while(partsList)
    {
      if(partName == car(partsList))
	return(car(libList));

      partsList = cdr(partsList);
    }

    libList = cdr(libList);
  }


}

///////////////////////////////////////////////////////////////////////////
// Find the properties attached to the datagroup that is associated with
// the passed in handle. Return them in a list strings in the form
// of name=value pairs.
///////////////////////////////////////////////////////////////////////////
defun oa_iff_get_shape_properties(shape)
{
    decl propHdl;
    decl propList = NULL;
    decl propName;
    decl propValue;
    decl propType;

    decl propIter = db_create_prop_iter(shape);
    for ( ; db_prop_iter_is_valid(propIter); propIter = db_prop_iter_get_next(propIter))
    {
        decl propName = db_prop_iter_get_name(propIter);
        if( propName != IffLineThickProp )
        {
            propType  = db_prop_iter_get_type(propIter);
            propValue = db_prop_iter_get_value(propIter);

            if( propList == NULL )
                propList = list(strcat(propName, "=", propValue));
            else
                propList = append(propList,list(strcat(propName,"=",propValue)));
        }
    }

    return(propList);
}

defun oa_traverse_point_list(fileHandle, context, shape, pntList, arcLastPoint, instHierTransform)
{
    decl coordX, coordY;
    decl prevX, prevY, firstX, firstY, lineList;
    decl arcLastX, arcLastY;

    if( IffDebugMessageLevel > 20 )
        print_value("Begin: traverse_point_list");

    // TODO_OA: arcLastPoint???
    if(arcLastPoint != NULL)
    {
        arcLastX=nth(0,arcLastPoint);
        arcLastY=nth(1,arcLastPoint);
    }

    decl propList = oa_iff_get_shape_properties(shape);

    decl firstPnt = TRUE;
    decl polygon = db_get_shape_primitive_polygon(shape);
    decl numPnts = db_get_primitive_polygon_num_points(polygon);
    if(de_is_layout_context(context) && (numPnts >= 2))
    {
        // Code from iff_layout_segment_as_polyline()
        // Write the polyline data 
        decl width = 0;
        decl layerNum = db_get_shape_layer(shape);
        decl layerName = db_find_layer_name_by_number(iff_get_get_top_design_context(), layerNum);
        if(!layerName)
            layerName = "default"; // defaultMaskName

        decl layerId = db_get_shape_layerid(shape);
        decl fillType = db_get_layerid_fill_mode(iff_get_get_top_design_context(), layerId);

        decl polyData = append(list("POLYLINE", layerName, 
            fillType, width, numPnts), pntList);

        if( propList != NULL )
            polyData = append(polyData, propList);

        fputs(fileHandle, blanks_to_sepchar(polyData));

        // End the polyline record
        polyData = list("POLYLINEEND");
        fputs(fileHandle, blanks_to_sepchar(polyData));
    }
    else
    {
        decl i;
        for (i = 0; i<numPnts; ++i)
        {
            decl coordPoint = db_get_primitive_polygon_point(polygon, i);
            coordPoint   = db_transform_coord(coordPoint, instHierTransform);
            coordX = db_get_x(coordPoint);
            coordY = db_get_y(coordPoint);
            if(firstPnt)
            {
                prevX = coordX;
                prevY = coordY;
                firstX = coordX;
                firstY = coordY;
                firstPnt = FALSE;
            }
            else if(!firstPnt) //else if( (!firstPnt) || ((prevX != coordX) && (prevY != coordY)))
            {
                decl ShadeRule = iff_get_ShadeRule_value(context, shape);
                decl myScale;
                if(de_is_layout_context(context))
                    myScale = UserUnits;
                else
                    myScale = UserUnits * 0.01;

                decl currentLineRule = iff_get_lineRule_value(context, shape);
                lineList = list("LINE", ShadeRule, currentLineRule,
                    prevX/myScale,prevY/myScale,
                    coordX/myScale,coordY/myScale);
                if( propList != NULL )
                    lineList = append(lineList, propList);
                if(fileHandle)
                    fputs(fileHandle, blanks_to_sepchar(lineList));
                prevX = coordX;
                prevY = coordY;
            }
        }
    }

    if( IffDebugMessageLevel > 20 )
        print_value("End: traverse_point_list");
}

/////////////////////////////////////////////////////////////////////////////
// return list of start point, end point and other point. 
// If the forLayout flag is set the currect transform is applied
// to the points (For Layout).
/////////////////////////////////////////////////////////////////////////////
defun oa_iff_arc_def(shape, forLayout, instHierTransform)
{
    decl myScale;
    if( forLayout == TRUE )
        myScale = UserUnits;
    else
        myScale = UserUnits * 0.01;

    // get another point approx near the half-way point
    decl polygon = db_get_shape_primitive_polygon(shape);
    decl numPnts = db_get_primitive_polygon_num_points(polygon);
    decl x1,y1,x2,y2,x3,y3, mdsArcData;
    decl pntCtr;
    for (pntCtr = 0; pntCtr<numPnts; ++pntCtr)
    {
        if(pntCtr==0 || pntCtr==numPnts-1)
        {
            decl coordPoint = db_get_primitive_polygon_point(polygon, pntCtr);
            if( forLayout == TRUE )
                coordPoint = db_transform_coord(coordPoint, instHierTransform);

            decl coordX = db_get_x(coordPoint)/myScale;
            decl coordY = db_get_y(coordPoint)/myScale;
            if(pntCtr==0)
            { 
                x1 = coordX;
                y1 = coordY; 
            }
            else if(pntCtr == numPnts-1)
            { 
                x2 = coordX;
                y2 = coordY; 
            }
        }
    }

    decl startPnt = db_get_arc_start(shape);
    startPnt = db_transform_coord(startPnt, instHierTransform);
    decl startX = db_get_x(startPnt)/myScale;
    decl startY = db_get_y(startPnt)/myScale;

    // TODO: Refactor this code to get end points?
    decl endX = x2;
    decl endY = y2;

    decl midPnt = db_get_arc_circumference_midpoint(shape);
    midPnt = db_transform_coord(midPnt, instHierTransform);
    decl midX = db_get_x(midPnt) / myScale;
    decl midY = db_get_y(midPnt) / myScale;

    // In ADS OA, arc is always counter clock wise with positive angle
    decl mdsArcData = list(startX, startY, endX, endY, midX, midY);

    // Include radius if not going to layout...
    if (forLayout == FALSE)
    {
        decl r = db_get_arc_radius(shape) / myScale;
        mdsArcData = append(mdsArcData, list(r));
    }

    return(mdsArcData);
}

defun oa_traverse_polyline(fileHandle, context, shape, instHierTransform)
{
    if( IffDebugMessageLevel > 20 )
        print_value("Begin: traverse_polyline");

    decl arcLastPoint = NULL; // TODO_OA: ???
    decl polygon = db_get_shape_primitive_polygon(shape);
    if(polygon)
    {
        decl numPoints = db_get_primitive_polygon_num_points(polygon);
        decl pntList = NULL;
        decl i;
        for (i = 0;i<numPoints;++i)
        {
            decl coord = db_get_primitive_polygon_point(polygon, i);
            coord = db_transform_coord(coord, instHierTransform);
            decl x = db_get_x(coord)/UserUnits;
            decl y = db_get_y(coord)/UserUnits;

            if( is_list(pntList) )
                pntList = append( pntList, list(x,y) );
            else 
                pntList = list(x,y);
        }

        if( IffDebugMessageLevel > 15 )	
            print_value(list("got point list", pntList));

        oa_traverse_point_list(fileHandle, context, shape, pntList, arcLastPoint, instHierTransform);

    }

    arcLastPoint=NULL;

    if( IffDebugMessageLevel > 20 )
        print_value("End:   traverse_polyline");
}

defun oa_traverse_rectangle_dg(fileHandle, context, shape, instHierTransform)
{
    if( IffDebugMessageLevel > 10 )
        print_value("Begin: traverse_rectangle_dg");

    decl dgBBox, rectData;
    if(!de_is_layout_context(context))
    {
        dgBBox  = db_get_shape_bbox(shape);
        decl x1 = db_get_bbox_x1(dgBBox)/UserUnits*100;
        decl y1 = db_get_bbox_y1(dgBBox)/UserUnits*100;
        decl x2 = db_get_bbox_x2(dgBBox)/UserUnits*100;
        decl y2 = db_get_bbox_y2(dgBBox)/UserUnits*100;

        decl ShadeRule = iff_get_ShadeRule_value(context, shape);
        decl currentLineRule = iff_get_lineRule_value(context, shape);
        rectData = list("BOX",ShadeRule,currentLineRule,x1,y1,x2,y2);
    }
    else    // output for layout
    {
        dgBBox  = db_get_shape_bbox(shape);

        // Get each point (now in non-rotated box form)
        decl coord_1 = db_new_coord(db_get_bbox_x1(dgBBox),db_get_bbox_y1(dgBBox));
        decl coord_2 = db_new_coord(db_get_bbox_x1(dgBBox),db_get_bbox_y2(dgBBox));
        decl coord_3 = db_new_coord(db_get_bbox_x2(dgBBox),db_get_bbox_y2(dgBBox));
        decl coord_4 = db_new_coord(db_get_bbox_x2(dgBBox),db_get_bbox_y1(dgBBox));
        // Get transformed points (these may be rotated)
        coord_1  = db_transform_coord(coord_1, instHierTransform);
        coord_2 = db_transform_coord(coord_2, instHierTransform);
        coord_3 = db_transform_coord(coord_3, instHierTransform);
        coord_4 = db_transform_coord(coord_4, instHierTransform);

        decl width = 0;
        decl layerNum = db_get_shape_layer(shape);
        decl layerName = db_find_layer_name_by_number(iff_get_get_top_design_context(), layerNum);
        if(!layerName)
            layerName = "default"; // defaultMaskName

        decl layerId = db_get_shape_layerid(shape);
        decl layerFill = db_get_layerid_fill_pattern(iff_get_get_top_design_context(), layerId);
        rectData = list("ARTPOLY", layerName, getCurrentFill(layerFill), width, 4, 
            db_get_x(coord_1)/UserUnits,db_get_y(coord_1)/UserUnits,
            db_get_x(coord_2)/UserUnits,db_get_y(coord_2)/UserUnits,
            db_get_x(coord_3)/UserUnits,db_get_y(coord_3)/UserUnits,
            db_get_x(coord_4)/UserUnits,db_get_y(coord_4)/UserUnits);

    }

    decl propList = oa_iff_get_shape_properties(shape);
    if( propList != NULL )
        rectData = append(rectData, propList);

    if(fileHandle)
        fputs(fileHandle, blanks_to_sepchar(rectData));

    if( IffDebugMessageLevel > 10 )
        print_value("End:   traverse_rectangle_dg");
}


// dcs allows only 0, 90, or 270 text rot
defun iff_text_rot(textRot)
{
  decl dcsRot;

  if(textRot<0)
    textRot += 360;

  if(textRot>0 && textRot<=45)
    dcsRot = 0;

  else if(textRot>45 && textRot<=135)
    dcsRot = 1;  // 90 degrees

  else if(textRot>135 && textRot<=225)
    dcsRot = 2;  //180 degrees

  else if(textRot>225 && textRot<=315)
    dcsRot = 3;  //270 degrees

  else dcsRot = 0;

  return(dcsRot);
}
  

defun iff_text_rule(height)
{
  decl textrule;

    if( height <= 08.30 )         textrule = 12;
//  else if( height <= 08.33 )    textrule = 12;	// Fifteen Pitch
    else if( height <= 09.90 )    textrule = 12;	// Fifteen Pitch
////else if( height <= 08.33 )    textrule = 11;	// Fifteen Pitch Bold
//  else if( height <= 10.00 )    textrule = 1;	        // Height 0.1
    else if( height <= 10.30 )    textrule = 1;	        // Height 0.1
//  else if( height <= 10.42 )    textrule = 16;	// Twelve Pitch
    else if( height <= 11.90 )    textrule = 16;	// Twelve Pitch
////else if( height <= 10.42 )    textrule = 15;	// Twelve Pitch Bold
//  else if( height <= 12.00 )    textrule = 2;	        // Height 0.12
    else if( height <= 12.40 )    textrule = 2;	        // Height 0.12
//  else if( height <= 12.50 )    textrule = 14; 	// Ten Pitch
    else if( height <= 13.00 )    textrule = 14; 	// Ten Pitch
////else if( height <= 12.50 )    textrule = 13;	// Ten Pitch Bold
////else if( height <= 12.50 )    textrule = 17; 	// Ansi 0.125
//  else if( height <= 13.10 )    textrule = 18; 	// Ansi 0.131
    else if( height <= 13.90 )    textrule = 18; 	// Ansi 0.131
//  else if( height <= 14.00 )    textrule = 19; 	// Ansi 0.14
    else if( height <= 14.90 )    textrule = 19; 	// Ansi 0.14
//  else if( height <= 15.00 )    textrule = 3;	        // Height 0.15
    else if( height <= 15.50 )    textrule = 3;	        // Height 0.15
//  else if( height <= 15.625 )   textrule = 10;	// Eight Pitch
    else if( height <= 17.40 )    textrule = 10;	// Eight Pitch
////else if( height <= 15.625 )   textrule = 9;	        // Eight Pitch Bold
//  else if( height <= 17.50 )    textrule = 4;	        // Height 0.175
    else if( height <= 17.80 )    textrule = 4;	        // Height 0.175
////else if( height <= 17.50 )    textrule = 20; 	// Ansi 0.175
//  else if( height <= 17.90 )    textrule = 21; 	// Ansi 0.179
    else if( height <= 18.70 )    textrule = 21; 	// Ansi 0.179
//  else if( height <= 18.80 )    textrule = 22; 	// Ansi 0.188
    else if( height <= 19.90 )    textrule = 22; 	// Ansi 0.188
//  else if( height <= 20.00 )    textrule = 5;	        // Height 0.2
    else if( height <= 21.60 )    textrule = 5;	        // Height 0.2
//  else if( height <= 21.70 )    textrule = 23; 	// Ansi 0.217
    else if( height <= 23.90 )    textrule = 23; 	// Ansi 0.217
//  else if( height <= 24.00 )    textrule = 6;	        // Height 0.24
    else if( height <= 24.90 )    textrule = 6;	        // Height 0.24
//  else if( height <= 25.00 )    textrule = 24; 	// Ansi 0.25
    else if( height <= 34.90 )    textrule = 24; 	// Ansi 0.25
//  else if( height <= 35.00 )    textrule = 7;	        // Height 0.35
    else if( height <= 49.90 )    textrule = 7;	        // Height 0.35
//  else if( height <= 50.00 )    textrule = 8;	        // Height 0.5
    else if( height <= 56.10 )    textrule = 8;	        // Height 0.5
//  else if( height <= 56.25 )    textrule = 25;        // Ansi 0.5625
    else if( height <= 62.40 )    textrule = 25; 	// Ansi 0.5625
//  else if( height <= 62.50 )    textrule = 26; 	// Ansi 0.625
    else if( height <= 74.90 )    textrule = 26; 	// Ansi 0.625
    else    			  textrule = 27; 	// Ansi 0.75

    return(textrule);
}

defun old_iff_text_rule(textHeight)
{
  decl textRule;

  if(textHeight < 9)
    textRule = 12;
  else if(textHeight < 10.25)
    textRule = 1;
  else if(textHeight < 11)
    textRule = 16;
  else if(textHeight < 12.25)
    textRule = 2;
  else if(textHeight < 12.75)
    textRule = 14;
  else if(textHeight < 13.5)
    textRule = 18;
  else if(textHeight < 14.5)
    textRule = 19;
  else if(textHeight < 15.5)
    textRule = 3;
  else if(textHeight < 15.75)
    textRule = 10;
  else if(textHeight < 17.75)
    textRule = 4;
  else if(textHeight < 18.5)
    textRule = 21;
  else if(textHeight < 19.25)
    textRule = 22;
  else if(textHeight < 20.25)
    textRule = 5;
  else if(textHeight < 21.75)
    textRule = 23;
  else if(textHeight < 24.5)
    textRule = 6;
  else if(textHeight < 25.5)
    textRule = 24;
  else if(textHeight < 35.5)
    textRule = 7;
  else if(textHeight < 50.5)
    textRule = 8;
  else if(textHeight < 56.55)
    textRule = 25;
  else if(textHeight < 65)
    textRule = 26;
  else textRule = 27;

  return(textRule);
}

/////////////////////////////////////////////////////////////////////////////
// Export text data group. The IFF definition for text is kind of strange
// and does not match up well with SeriesIV fonts. This is not a problem for
// single line text however, for multiline text the line spacing and text
// height do not match up at all. So if the text is multiline text we must
// break it up into single line text offset to our line spacing.
/////////////////////////////////////////////////////////////////////////////
defun oa_traverse_text_dg(fileHandle, context, shape, instHierTransform)
{
    // TODO_OA: Review vars!
    decl textHandle, textHeight, textStrg, textLoc, textSize;
    decl textData, locX, locY, textRot, textRule, lineSpac;
    decl maskName, coord, pos, tmpStr, textOffsetX, textOffsetY;
    decl PI, angRad;
    decl bbox;
    decl textJust;
    decl lineCount;
    decl tmpStrg2;

    if( IffDebugMessageLevel > 10 )
        print_value("Begin: traverse_text_dg");

    if(!fileHandle)
    {
        if( IffDebugMessageLevel > 10 )
            print_value("End:   traverse_text_dg");
        return;
    }

    PI=3.14159265;
    textRule=0;
    lineSpac="NORMAL";

    decl textStrg = db_get_shape_text_string(shape);
    decl textLoc = db_get_text_origin(shape);
    decl textRot = db_get_text_angle(shape) / 1000.0;
    decl bbox = db_get_shape_bbox(shape);

    tmpStrg2 = textStrg;
    pos = index(tmpStrg2, "\n");
    lineCount = 0;
    while( pos != -1 )
    {
        tmpStr = leftstr(tmpStrg2, pos);
        tmpStrg2 = rightstr(tmpStrg2, strlen(tmpStrg2)-pos-1);
        pos = index(tmpStrg2, "\n");
        lineCount++;
    }

    textRot = iff_normalize_angle(textRot, 0, 360);

    if(!de_is_layout_context(context))
    {
        textRot = iff_text_rot(textRot);
        decl height = db_get_text_height(shape);
        textHeight = height/UserUnits*100; // TODO_OA: Review

        textSize = strcat("0,",textHeight);
        textSize = strcat(textSize,",IN/100");
        //textSize = "0,0,IN/100";
        textRule = iff_text_rule(textHeight);

        textOffsetX = 0;
        textOffsetY = 0;
        if( textRot == 0 )
        {
            textOffsetY = textHeight*lineCount;
            locX = db_get_bbox_x1(bbox)/UserUnits*100 + textOffsetX;
            locY = db_get_bbox_y1(bbox)/UserUnits*100 + textOffsetY;
        }
        else if( textRot == 1 )
        {
            textOffsetX = -textHeight*lineCount;
            locX = db_get_bbox_x2(bbox)/UserUnits*100 + textOffsetX;
            locY = db_get_bbox_y1(bbox)/UserUnits*100 + textOffsetY;
        }
        else if( textRot == 2 )
        {
            textOffsetY = -textHeight*lineCount;
            locX = db_get_bbox_x2(bbox)/UserUnits*100 + textOffsetX;
            locY = db_get_bbox_y2(bbox)/UserUnits*100 + textOffsetY;
        }
        else if( textRot == 3 )
        {
            textOffsetX = textHeight*lineCount;
            locX = db_get_bbox_x1(bbox)/UserUnits*100 + textOffsetX;
            locY = db_get_bbox_y2(bbox)/UserUnits*100 + textOffsetY;
        }

        if( strlen(textStrg) > 0 )
        {
            //decl ShadeRule = iff_get_ShadeRule_value(context, shape); // Returns 0 ?
            decl ShadeRule = 1;
            textData = list("TEXT",ShadeRule,textRot,textRule,textSize,
                lineSpac, locX, locY, textStrg);
            fputs(fileHandle, blanks_to_sepchar(textData));
        }

    }
    else     // output for layout
    {
        decl layerNum = db_get_shape_layer(shape);
        decl layerName = db_find_layer_name_by_number(iff_get_get_top_design_context(), layerNum);
        if(!layerName)
            layerName = "default"; // defaultMaskName

        decl height = db_get_text_height(shape);
        decl textHeight = height/UserUnits;

        decl textSize = strcat("0,",textHeight);
        textSize = strcat(textSize, ",");
        textSize = strcat(textSize, layoutUnits);
        //textSize = "0,0,IN/100";

        decl angRad = textRot * PI/180;

        if( textRot <= 90 )
        {
            locX = ( db_get_bbox_x1(bbox)/UserUnits + 
                ( textHeight * sin(angRad) ));
            locY = ( db_get_bbox_y1(bbox)/UserUnits + 
                ( lineCount * textHeight * cos(angRad) ));

        }
        else if( textRot <= 180 )
        {
            locX = ( db_get_bbox_x2(bbox)/UserUnits -
                ( lineCount * textHeight * sin(angRad) ));
            locY = ( db_get_bbox_y1(bbox)/UserUnits - 
                ( textHeight * cos(angRad) ));
        }
        else if( textRot <= 270 )
        {
            locX = ( db_get_bbox_x2(bbox)/UserUnits +
                ( textHeight * sin(angRad) ));
            locY = ( db_get_bbox_y2(bbox)/UserUnits + 
                ( lineCount * textHeight * cos(angRad) ));
        }
        else // textRot <= 360
        {
            locX = ( db_get_bbox_x1(bbox)/UserUnits -
                ( lineCount *  textHeight * sin(angRad) ));
            locY = ( db_get_bbox_y2(bbox)/UserUnits - 
                ( textHeight * cos(angRad) ));
        }

        if( strlen(textStrg) > 0 )
        {
            // Font is NOT preserved!
            // decl textFont = db_get_text_font_name(shape);
            textData = list("DRTXT", layerName, locX, locY, "standard", "THIN",
                textRot,"CONSTANT", textSize, "OFF", "500", 
                textStrg);
            fputs(fileHandle, blanks_to_sepchar(textData));
        }
    }

    if( IffDebugMessageLevel > 10 )
        print_value("End:   traverse_text_dg");
}


/////////////////////////////////////////////////////////////////////////////
// Return the corner type and radius in property list format of a path
/////////////////////////////////////////////////////////////////////////////
defun oa_iff_get_path_attributes(shape)
{
    decl propList;
    decl cornerType   = db_get_path_trace_bend_type(shape);
    decl cornerRadius = db_get_path_trace_miter_radius(shape);
    if( cornerType == DB_MITERED_CORNER )
    {
        propList = list("CORNER_TYPE=MITERED_CORNER", 
            strcat("CORNER_MITER_CUTOFF=", cornerRadius));
    }
    else if( cornerType == DB_SQUARE_CORNER )
    {
        propList = list("CORNER_TYPE=SQUARE_CORNER");
    }
    else if( cornerType == DB_CURVED_CORNER )
    {
        propList = list("CORNER_TYPE=CURVED_CORNER", 
            strcat("CORNER_RADIUS=", cornerRadius/100.0));
    }

    return(propList);
}


/////////////////////////////////////////////////////////////////////////////
// Traverse the schematic polygon data group. Check to see if there
// are ARCS in the polyline data if there is then dump the info differently.
/////////////////////////////////////////////////////////////////////////////
defun oa_traverse_schematic_polygon(fileHandle, context, shape, instHierTransform)
{
    if( IffDebugMessageLevel > 20 )
        print_value("Begin: traverse_schematic_polygon");

    decl isClosed;
    decl polygon = db_get_shape_primitive_polygon(shape, &isClosed);
    decl numHoles;
    if(isClosed)
    {
        numHoles = db_get_primitive_polygon_num_holes(polygon);
    }

    decl pntList;
    if(numHoles > 0)
    {
        decl linkHolePolygon = db_get_primitive_polygon_with_linked_holes(polygon);
        pntList = iff_get_polygon_point_list(context, linkHolePolygon, instHierTransform);
    }
    else
    {
        pntList = iff_get_polygon_point_list(context, polygon, instHierTransform);
    }

    decl vertices = listlen(pntList)/2;
    if(vertices > 1)
    {
        decl ShadeRule = iff_get_ShadeRule_value(context, shape);
        decl filled = "N";
        decl polyData = append(list("POLY", ShadeRule,filled,vertices),pntList);

        decl currentLineRule = iff_get_lineRule_value(context, shape);
        if ( (currentLineRule > 0) && (currentLineRule < 4) )
            polyData = append(polyData, list(strcat("line_thickness_prop=", currentLineRule)));

        decl propList = oa_iff_get_shape_properties(shape);
        if( propList != NULL )
            polyData = append(polyData, propList);

        if(fileHandle)
            fputs(fileHandle, blanks_to_sepchar(polyData));
    }

    if( IffDebugMessageLevel > 20 )
        print_value("End:   traverse_schematic_polygon");
}

// DON'T USE IT FOR ARC
// Mainly usful for trace, path etc.
defun oa_iff_get_point_list(context, shape, instHierTransform)
{
    decl polygon;
    if(db_shape_is_wire_or_trace(shape) || db_shape_is_path(shape))
        polygon = db_get_shape_control_polygon(shape);
    else
        polygon = db_get_shape_primitive_polygon(shape);

    decl numPoints = db_get_primitive_polygon_num_points(polygon);
    decl pntList = NULL;

    decl myScale;
    if(de_is_layout_context(context))
        myScale = UserUnits;
    else
        myScale = UserUnits * 0.01;

    decl i;
    for (i = 0;i<numPoints;++i)
    {
        decl coord = db_get_primitive_polygon_point(polygon, i);
        coord = db_transform_coord(coord, instHierTransform);
        decl x = db_get_x(coord)/myScale;
        decl y = db_get_y(coord)/myScale;

        if( is_list(pntList) )
            pntList = append( pntList, list(x,y) );
        else 
            pntList = list(x,y);
    }

    return( pntList );
}


defun iff_get_polygon_point_list(context, polygon, instHierTransform)
{
    decl myScale;
    if(de_is_layout_context(context))
        myScale = UserUnits;
    else
        myScale = UserUnits * 0.01;

    decl numPoints = db_get_primitive_polygon_num_points(polygon);
    decl pntList = NULL;
    decl i;
    for (i = 0;i<numPoints;++i)
    {
        decl coord = db_get_primitive_polygon_point(polygon, i);
        coord = db_transform_coord(coord, instHierTransform);
        decl x = db_get_x(coord)/myScale;
        decl y = db_get_y(coord)/myScale;

        if( is_list(pntList) )
            pntList = append( pntList, list(x,y) );
        else 
            pntList = list(x,y);
    }

    return( pntList );
}

defun oa_traverse_layout_polygon(fileHandle, context, shape, instHierTransform)
{
    if( IffDebugMessageLevel > 5 )
        print_value("Begin: traverse_layout_polygon");

    decl isClosed;
    decl polygon = db_get_shape_primitive_polygon(shape, &isClosed);
    decl numHoles;
    if(isClosed)
    {
        numHoles = db_get_primitive_polygon_num_holes(polygon);
    }

    decl pntList;
    if(numHoles > 0)
    {
        decl linkHolePolygon = db_get_primitive_polygon_with_linked_holes(polygon);
        pntList = iff_get_polygon_point_list(context, linkHolePolygon, instHierTransform);
    }
    else if(db_primitive_polygon_has_arcs(polygon))
    {
        decl polygonWoArc = db_get_primitive_polygon_with_arcs_removed(polygon, 5000);
        pntList = iff_get_polygon_point_list(context, polygonWoArc, instHierTransform);
    }
    else
    {
        pntList = iff_get_polygon_point_list(context, polygon, instHierTransform);
    }

    if( pntList )
    {
        if( IffDebugMessageLevel > 15 )
            print_value("Found a valid polygon....");

        decl propList = oa_iff_get_shape_properties(shape);

        decl layerNum = db_get_shape_layer(shape);
        decl layerName = db_find_layer_name_by_number(iff_get_get_top_design_context(), layerNum);
        if(!layerName)
            layerName = "default"; // defaultMaskName

        decl layerId = db_get_shape_layerid(shape);
        decl layerFill = db_get_layerid_fill_pattern(iff_get_get_top_design_context(), layerId);
        decl vertices = listlen(pntList)/2;
        decl width = 0;
        if( vertices > 2 )
        {
            decl polyData = append(list("ARTPOLY", layerName,
                getCurrentFill(layerFill), width, vertices), pntList);

            if( propList != NULL )
                polyData = append(polyData, propList);

            fputs(fileHandle, blanks_to_sepchar(polyData));
        }
        else if( vertices == 2 )
        {
            decl polyData = append(list("POLYLINE", layerName, 
                getCurrentFill(layerFill), width, vertices), pntList);

            if( propList != NULL )
                polyData = append(polyData, propList);

            fputs(fileHandle, blanks_to_sepchar(polyData));

            // End the polyline record
            polyData = list("POLYLINEEND");
            fputs(fileHandle, blanks_to_sepchar(polyData));
        }
    }

    if( IffDebugMessageLevel > 5 )
        print_value("End:   traverse_layout_polygon");
}

// This function exports the polyline
defun oa_iff_layout_wire_as_polyline(fileHandle, context, shape, refPath, instHierTransform)
{
    if( IffDebugMessageLevel > 5 )
        print_value("Begin: iff_layout_wire_as_polyline");

    decl layerNum = db_get_shape_layer(shape);
    decl layerName = db_find_layer_name_by_number(iff_get_get_top_design_context(), layerNum);
    if(!layerName)
        layerName = "default"; // defaultMaskName

    decl layerId = db_get_shape_layerid(shape);
    decl layerFill = db_get_layerid_fill_pattern(iff_get_get_top_design_context(), layerId);

    decl pntList = oa_iff_get_point_list(context, shape, instHierTransform);
    if( pntList )
    {
        if( IffDebugMessageLevel > 15 )
            print_value("Found a valid wire....");

        decl vertices = listlen(pntList)/2;
        if( vertices > 1 )
        {
            decl width = db_get_path_trace_width(shape)/UserUnits;

           decl polyData=append(list("POLYLINE", layerName, 
                getCurrentFill(layerFill), width, vertices), pntList);
            fputs(fileHandle, blanks_to_sepchar(polyData));

            // Write the polygon that makes up the polyline
            if( width > 0 )  // For trace
                oa_traverse_layout_polygon(fileHandle, context, shape, instHierTransform);

            // End the polyline record
            polyData = list("POLYLINEEND");
            fputs(fileHandle, blanks_to_sepchar(polyData));
        }
    }

    if( IffDebugMessageLevel > 5 )
        print_value("End:   iff_layout_wire_as_polyline");

}

defun oa_traverse_polygon_dg(fileHandle, context, shape, instHierTransform)
{
    if( IffDebugMessageLevel > 10 )
        print_value("Begin: traverse_polygon_dg");

    if(!de_is_layout_context(context))
        oa_traverse_schematic_polygon(fileHandle, context, shape, instHierTransform);
    else
        oa_traverse_layout_polygon(fileHandle, context, shape, instHierTransform);

    if( IffDebugMessageLevel > 5 )
        print_value("End:   traverse_polygon_dg");
}

defun oa_traverse_polyline_dg(fileHandle, context, shape, instHierTransform)
{
    if( IffDebugMessageLevel > 10 )
        print_value("Begin: traverse_polyline_dg");

    oa_traverse_polyline(fileHandle, context, shape, instHierTransform);

    if( IffDebugMessageLevel > 5 )
        print_value("End:   traverse_polyline_dg");
}

/////////////////////////////////////////////////////////////////////////////
// HACK: Place pins at the start and end of the trace component. 
//       Currently this code is not correctly handing:
//
//               pin ids
//               pin rotation
/////////////////////////////////////////////////////////////////////////////
defun oa_iff_trace_pins(fileHandle, context, shape, instHierTransform)
{
    if( IffDebugMessageLevel > 5 )
        print_value("Begin: iff_trace_pins");

    decl pntList = oa_iff_get_point_list(context, shape, instHierTransform);
    if( ! pntList )
        return;

    decl coord, x, y;
    // First pin coordinates
    x = car(pntList);
    y = car(cdr(pntList));

    decl layerNum = db_get_shape_layer(shape);
    decl layerName = db_find_layer_name_by_number(context, layerNum);
    decl parentDesignName = db_get_design_name(context);
    if(!layerName && parentDesignName)
    {
        decl parentContext = de_find_design_context_from_name(parentDesignName, REP_LAY);
        layerName = db_find_layer_name_by_number(parentContext, layerNum);
    }

    if(!layerName)
        layerName = "default"; // defaultMaskName

    decl pinList = list("ARTPIN", layerName, strcat("MSMEANDER:CMP",InstID-1), 
        "PIN", x, y, "0", "POINTPIN", 1, "P1", "OFF", "1", x, y, "*");

    fputs(fileHandle, blanks_to_sepchar(pinList));

    // Second pin coordinates
    while( pntList )
    {
        x = car(pntList);
        y = car(cdr(pntList));
        pntList = cdr(cdr(pntList));
    }

    pinList = list("ARTPIN", layerName, strcat("MSMEANDER:CMP",InstID-1), 
        "PIN", x, y, "0", "POINTPIN", 2, "P2", "OFF", "1", x, y, "*");

    fputs(fileHandle, blanks_to_sepchar(pinList));

    if( IffDebugMessageLevel > 5 )
        print_value("End:   iff_trace_pins");

    return;
}


/////////////////////////////////////////////////////////////////////////////
// TRAVERSE_WIRE_DG:  This writes traces to the IFF file as MSMEANDER
// components.
/////////////////////////////////////////////////////////////////////////////
defun oa_traverse_wire_trace_dg(fileHandle, context, shape, refPath, instHierTransform)
{
    if( IffDebugMessageLevel > 5 )
        print_value("Begin: traverse_wire_dg");

    if(de_is_layout_context(context))
    {
        decl width = db_get_path_trace_width(shape)/UserUnits;
        decl widthAtt = strcat("W=", width);

        // For corner types note that RADIUS will be used as the curve
        // radius for traces with "rounded" corners, and miter ratio scaled
        // by the page resolution for traces with "chamfer" corners.
        // For mitered corners we will output the miter ratio as an
        // unscaled ratio to the MITER attribute.  
        // Note that the MITER attribute was added in ADS 2006A and for
        // backward compatibility with release of ADS prior to ADS
        // 2006A the miter ratio will also be passed as a scaled 
        // value to the RADIUS attribute (scaled by the resolution).  The
        // MITER attribute is preferable to use for mitered traces.

        decl bend = db_get_path_trace_bend_type(shape);
        decl bendAtt, miterRad, miterAtt;
        if(bend == DB_MITERED_CORNER)
        {
            bendAtt = "CORNERTYPE=chamfer";
            miterRad = db_get_path_trace_miter_radius(shape);
            miterAtt = strcat("MITER=", miterRad/100.0); //miter is a percentage
        }
        else if(bend == DB_SQUARE_CORNER)
            bendAtt = "CORNERTYPE=square";
        else if(bend == DB_CURVED_CORNER)
            bendAtt = "CORNERTYPE=rounded";

        decl radius = db_get_path_trace_miter_radius(shape)/UserUnits;
        decl radiusAtt = strcat("RADIUS=", radius);

        decl path = strcat("PATH=", refPath);
        path = strcat(path, ".");
        path = strcat(strcat(path, "CMP"), InstID);
        path = strcat(path, "|MSMEANDER");

        decl polyData = list("ARTCOMP","MSMEANDER","leaf",InstID, InstAngle,
            "F",InstX/UserUnits, InstY/UserUnits, 1, path,
            widthAtt, bendAtt, radiusAtt);
        if(bend == DB_MITERED_CORNER)
            polyData = append(polyData, list(miterAtt));

        InstID = InstID + 1;

        fputs(fileHandle, blanks_to_sepchar(polyData));

        // Write polyline
        oa_iff_layout_wire_as_polyline(fileHandle, context, shape, refPath, instHierTransform);

        // Write pins
        oa_iff_trace_pins(fileHandle, context, shape, instHierTransform);

        polyData = list("ARTCOMPEND");

        fputs(fileHandle, blanks_to_sepchar(polyData));
    }

    if( IffDebugMessageLevel > 5 )
        print_value("End:   traverse_wire_dg");
}

/////////////////////////////////////////////////////////////////////////////
// Traverse the path data group. For Layout we handle these slightly
// different. They are converted into a "MSMEANDER" component. These
// components are defined to be trace/path elements that may or may not
// have schematic representations.
/////////////////////////////////////////////////////////////////////////////
defun oa_traverse_path_dg(fileHandle, context, shape, refPath, instHierTransform)
{
    if( IffDebugMessageLevel > 10 )
        print_value("Begin: traverse_path_dg");

    if(de_is_layout_context(context))
    {
        decl layerNum = db_get_shape_layer(shape);
        decl layerName = db_find_layer_name_by_number(iff_get_get_top_design_context(), layerNum);
        if(!layerName)
            layerName = "default"; // defaultMaskName

        decl layerId = db_get_shape_layerid(shape);
        decl layerFill = db_get_layerid_fill_pattern(iff_get_get_top_design_context(), layerId);

        decl width = db_get_path_trace_width(shape)/UserUnits;

        decl pntList = oa_iff_get_point_list(context, shape, instHierTransform);
        decl numPoints = listlen(pntList);
        decl vertices = numPoints/2;

        decl polyData=append(list("POLYLINE", layerName, 
            layerFill, width, vertices), pntList);

        polyData=append(polyData, oa_iff_get_path_attributes(shape));

        decl propList = oa_iff_get_shape_properties(shape);
        if( propList != NULL )
            polyData = append(polyData, propList);

        fputs(fileHandle, blanks_to_sepchar(polyData));

        // Write the polygon that makes up the polyline
        if( width > 0 )
            oa_traverse_layout_polygon(fileHandle, context, shape, instHierTransform);

        // End the polyline record
        polyData = list("POLYLINEEND");
        fputs(fileHandle, blanks_to_sepchar(polyData));
    }
    else
        oa_traverse_schematic_polygon(fileHandle, context, shape, instHierTransform);

    if( IffDebugMessageLevel > 10 )
        print_value("End:   traverse_path_dg");
}

defun oa_traverse_const_dg(fileHandle, context, shape, instHierTransform)
{
    decl  coordHandle;
    decl startX, startY, endX, endY, constData;

    if( IffDebugMessageLevel > 10 )
        print_value("Begin: traverse_const_dg");

    decl layerNum = db_get_shape_layer(shape);
    decl layerName = db_find_layer_name_by_number(iff_get_get_top_design_context(), layerNum);
    if(!layerName)
        layerName = "default"; // defaultMaskName

    decl bbox = db_get_const_line_points(constLine);
    decl startX = db_get_bbox_x1(bbox)/UserUnits;
    decl startY = db_get_bbox_y1(bbox)/UserUnits;
    decl endX = db_get_bbox_x2(bbox)/UserUnits;
    decl endY = db_get_bbox_y2(bbox)/UserUnits;

    decl constData = list("CONST", layerName, startX, startY, endX, endY);

    decl propList = oa_iff_get_shape_properties(shape);
    if( propList != NULL )
        constData = append(constData, propList);

    if(fileHandle)
        fputs(fileHandle, blanks_to_sepchar(constData));

    if( IffDebugMessageLevel > 10 )
        print_value("End:   traverse_const_dg");
}


defun oa_traverse_ellipse_dg(fileHandle, context, shape, instHierTransform)
{
    if( IffDebugMessageLevel > 10 )
        print_value("Begin: traverse_circle_dg");

    if( IffR200Release == TRUE )
    {
        if( IffDebugMessageLevel > 20 )
            print_value("End:   traverse_poly_with_arcs");

        return;
    }

    decl xRadius = db_get_ellipse_x_radius(shape);
    decl yRadius = db_get_ellipse_y_radius(shape);
    /*decl radius = xRadius;*/
    decl centerPnt = db_get_ellipse_center(shape);
    decl centerX = db_get_x (centerPnt);
    decl centerY = db_get_y (centerPnt);

    decl startX = centerX - xRadius;
    decl startY = centerY;
    decl startPnt = db_new_coord(startX, startY);

    decl arcData;
    decl resolution, coord;
    decl fill = "N";

    decl propList = oa_iff_get_shape_properties(shape);
    if(!de_is_layout_context(context))
    {
        centerX = db_get_x(centerPnt)/UserUnits*100;
        centerY = db_get_y(centerPnt)/UserUnits*100;

        startX = db_get_x(startPnt)/UserUnits*100;
        startY = db_get_y(startPnt)/UserUnits*100;

        decl radius = sqrt((centerX-startX)*(centerX-startX)+
                    (centerY-startY)*(centerY-startY));

        decl ShadeRule = iff_get_ShadeRule_value(context, shape);
        decl currentLineRule = iff_get_lineRule_value(context, shape);
        arcData = list("CIRCLE",ShadeRule,currentLineRule,centerX,centerY,
            startX,startY,radius,fill);
        if( propList != NULL )
            arcData = append(arcData, propList);

        if(fileHandle)
            fputs(fileHandle, blanks_to_sepchar(arcData));
    }
    else    // output for layouts
    {
        coord   = db_transform_coord(startPnt, instHierTransform);
        startX  = db_get_x(coord)/UserUnits;
        startY  = db_get_y(coord)/UserUnits;

        coord   = db_transform_coord(centerPnt, instHierTransform);
        centerX = db_get_x(coord)/UserUnits;
        centerY = db_get_y(coord)/UserUnits;

        resolution = iff_get_preference( GLOBAL_ARC_RESOLUTION_P );

        decl layerNum = db_get_shape_layer(shape);
        decl layerName = db_find_layer_name_by_number(iff_get_get_top_design_context(), layerNum);
        if(!layerName)
            layerName = "default"; // defaultMaskName

        decl layerId = db_get_shape_layerid(shape);
        decl layerFill = db_get_layerid_fill_pattern(iff_get_get_top_design_context(), layerId);

        arcData = list("FCIR",layerName,centerX,centerY,startX,startY,getCurrentFill(layerFill),
            0, resolution);

        if( propList != NULL )
            arcData = append(arcData, propList);

        if(fileHandle)
            fputs(fileHandle, blanks_to_sepchar(arcData));
        arcData = list("FCIREND");
        if(fileHandle)
            fputs(fileHandle, blanks_to_sepchar(arcData));
    }

    if( IffDebugMessageLevel > 10 )
        print_value("End:   traverse_circle_dg");
}


/// Find the "line_thickness_prop" and return its value. Default to 1 if not found.
defun iff_get_line_thickness_property_value(shape)
{
    decl propValue = 1;
    decl propIter = db_create_prop_iter(shape);
    for ( ; db_prop_iter_is_valid(propIter); propIter = db_prop_iter_get_next(propIter))
    {
        decl propName = db_prop_iter_get_name(propIter);
        if (propName == IffLineThickProp)
        {
            propValue = db_prop_iter_get_value(propIter);
            break;
        }
    }
    return propValue;
}

// An integer indicating the type of line
// May be used to draw arc, box/rectangle, brace, circle, line etc.
// Valid values are 1, 2, 3, and 4.
defun iff_get_lineRule_value(context, shape)
{
    decl lineStyle = db_get_layerid_line_style(context, db_get_shape_layerid(shape));
    decl lineThicknessPropVal = iff_get_line_thickness_property_value(shape);
    return getCurrentLineRule(lineStyle, lineThicknessPropVal);
}

// Shade Rule Value - An integer indicating the color used to draw the shape
// ShadeRule - Default Color
// 1 - Black
// 2 - Red
// 3 - Cyan
// 4 - Green
// 5 - Magenta
// 6 - Blue
// 7 - Yellow
// 8 - Orange
// 9 - Dk Green
// 10 - Brown
// 11 - Dk Blue
// 12 - Tan
// 13 - Purple
// 14 - Aqua
// 15 - Mauve
// 16 - White
defun iff_get_ShadeRule_value(context, shape)
{
    decl layerColor = db_get_layerid_rgb(context, db_get_shape_layerid(shape));
    layerColor = layerColor & 0x00FFFFFF;
    decl color = oa_mapColor(val(layerColor));
    return iff_unMapColor(color);
}

defun oa_traverse_arc_dg(fileHandle, context, shape, instHierTransform)
{
    decl arcAngle = db_get_arc_angle(shape);
    if(arcAngle == 360000)
    {
        oa_traverse_ellipse_dg(fileHandle, context, shape, instHierTransform);
        return;
    }

    if( IffDebugMessageLevel > 5 )
            print_value("Begin: iff_segment_as_arc");

    if(de_is_layout_context(context))
    {
        decl layerNum = db_get_shape_layer(shape);
        decl layerName = db_find_layer_name_by_number(iff_get_get_top_design_context(), layerNum);
        if(!layerName)
            layerName = "default"; // defaultMaskName

        decl resolution = iff_get_preference( GLOBAL_ARC_RESOLUTION_P );
        decl mdsArcDef = oa_iff_arc_def(shape, TRUE, instHierTransform);
        decl arcData = list("FARC", layerName);
        arcData = append(arcData, mdsArcDef);
        arcData = append(arcData, list("OUTLINE", 0, resolution));

        if(fileHandle)
        {
            decl propList = oa_iff_get_shape_properties(shape);
            if( propList != NULL )
                arcData = append(arcData, propList);

            fputs(fileHandle, blanks_to_sepchar(arcData));

            arcData = list("FARCEND");
            fputs(fileHandle, blanks_to_sepchar(arcData));
        }
    }
    else // de_is_schematic_context(context)
    {
        decl ShadeRule = iff_get_ShadeRule_value(context, shape);
        decl currentLineRule = iff_get_lineRule_value(context, shape);
        decl mdsArcDef = oa_iff_arc_def(shape, FALSE, instHierTransform);
        decl arcData = list("ARC",ShadeRule,currentLineRule);
        arcData = append(arcData, mdsArcDef);

        decl propList = oa_iff_get_shape_properties(shape);
        if( propList != NULL )
            arcData = append(arcData, propList);

        if(fileHandle)
            fputs(fileHandle, blanks_to_sepchar(arcData));
    }

    if( IffDebugMessageLevel > 5 )
            print_value("End:   iff_segment_as_arc");
}

/////////////////////////////////////////////////////////////////////////////
// rotation codes for iff connectors
/////////////////////////////////////////////////////////////////////////////
defun iff_conn_rot(eesofRot, mx, my)
{
  decl rot;

  if(eesofRot==90000)
  {
      if(mx)
      {
	  rot = 1;
      }
      else if(my)
      {
	  rot = 3;
      }
      else
      {
	  rot = 3;
      }
  }
  else if(eesofRot==180000 || eesofRot== -180000)
  {
      if(mx)
      {
	  rot = 0;
      }
      else if(my)
      {
	  rot = 2;
      }
      else
      {
	  rot = 0;
      }
  }
  else if(eesofRot==270000 || eesofRot== -90000)
  {
      if(mx)
      {
	  rot = 3;
      }
      else if(my)
      {
	  rot = 1;
      }
      else
      {
	  rot = 1;
      }
  }
  else
  {
      if(mx)
      {
	  rot = 2;
      }
      else if(my)
      {
	  rot = 0;
      }
      else
      {
	  rot = 2;
      }
  }

  return(rot);
}

// Mapped angles of ADS OA with ADS DSN
// 
//  OA angle   DSN angle    rotation code
//     0        180           0
//   -90         90           1
//   180          0           2
//    90        -90           3
defun oa_iff_conn_rot(eesofRot)
{
    decl rot;
    if(eesofRot==0)
    {
        rot = 2;
    }
    else if(eesofRot==180000)
    {
        rot = 0;
    }
    else if(eesofRot==90000)
    {
        rot = 3;
    }
    else if(eesofRot==270000 || eesofRot== -90000)
    {
        rot = 1;
    }
    else
    {
        rot = 0;
    }

    return(rot);
}

/////////////////////////////////////////////////////////////////////////////
// rotation codes for iff components 
// iff 0 = 0 deg
//     1 = 90 
//     2 = 180
//     3 = 270
//     4 = Flip, 0 deg
//     5 = Flip, 90
//     6 = Flip, 180
//     7 = Flip, 270
/////////////////////////////////////////////////////////////////////////////
defun iff_cmp_rot(isTransform, transOrLocP, logFile)
{
  decl eesofRot = 0;
  decl mirrorX = 0;
  decl mirrorY = 0;
  if (isTransform)
  {
      eesofRot = float (db_get_transform_angle(transOrLocP));
      mirrorX = db_get_transform_mirror_x(transOrLocP);
      mirrorY = db_get_transform_mirror_y(transOrLocP);
  }

  decl rot = -1;
  if(eesofRot==90000 || eesofRot == -270000)
  {
    if(mirrorX && mirrorY)
      rot = 3;
    else if(mirrorX)
      rot = 7;
    else if(mirrorY)
      rot = 5;
    else rot = 1;
  }
  else if(eesofRot==180000 || eesofRot== -180000)
  {
    if(mirrorX && mirrorY)
      rot = 0;
    else if(mirrorX)
      rot = 6;
    else if(mirrorY)
      rot = 4;
    else rot = 2;
  }
  else if(eesofRot==270000 || eesofRot== -90000)
  {
    if(mirrorX && mirrorY)
      rot = 1;
    else if(mirrorX)
      rot = 5;
    else if(mirrorY)
      rot = 7;
    else rot = 3;
  }
  else
  {
    if(eesofRot == 0 || eesofRot == 360000 || eesofRot == -360000)
    {
      if(mirrorX && mirrorY)
        rot = 2;
      else if(mirrorX)
        rot = 4;
      else if(mirrorY)
        rot = 6;
      else rot = 0;
    }

    if(rot == -1)
    {
      iff_log_message(list("    WARNING: ",
			   TransferTypeName,
			   " supports only rotations in 90-degree increments.\n",
			   "             Item will be set to 0 rotation."));
      rot = 0;
    }
  }

  return(rot);
}

//////////////////////////////////////////////////////////////////////////////
// Return a list of rotation and flip status for the passed in transform
//////////////////////////////////////////////////////////////////////////////
defun iff_artcomp_rot(isTransform, transOrLocP, parentFlipped, importFlag)
{
  decl eesofRot = 0;
  decl mirrorX = 0;
  decl mirrorY = 0;
  if(isTransform)
  {
      eesofRot = float (db_get_transform_angle(transOrLocP));
      mirrorX = db_get_transform_mirror_x(transOrLocP);
      mirrorY = db_get_transform_mirror_y(transOrLocP);
  }

  decl rot = eesofRot;
  decl flipped = "F";
  if( mirrorX && mirrorY )
    {
      rot = eesofRot + 180000;    // Mirror X and Y just add 180 degree
    }
  else if( mirrorX )
    {
      if(importFlag)
          rot = -eesofRot;            // Reverse rotation direction 
      flipped = "T";
    }
  else if( mirrorY )
    {
      rot = eesofRot + 180000;    // Change mirror to X by adding 180
      rot = -rot;                 // Reverse rotation direction       
      flipped = "T";
    }
  
  rot = iff_normalize_angle(( rot/1000 ), 0, 360);

  if(( IffSupportMdsFlipBug ) && ( !InstIsLeaf ))
    {
      if((( parentFlipped && flipped == "F" ) || 
	  ( !parentFlipped && flipped == "T" )))
	{
	  flipped = "T";
	}
      else
	{
	  flipped = "F";
	}
    }

  return(list(rot, flipped));
}

//////////////////////////////////////////////////////////////////////
//return list of all properties EXCEPT "HPEESOF_FULL_PATH"
//                         and  EXCEPT "HPEESOF_SYMBOLPAGE_PROP*"
//return propName = propValue
//   and propName_HPEESOF_PROP_TYPE = propType
//check for HPEESOF_PROP_NAME_x=name and HPEESOF_PROP_VALUE_x=value pairs
//   and convert to name=value
//////////////////////////////////////////////////////////////////////
defun build_property_list(propIter)
{
  decl propType, propName, propValue, propList, 
       pos, iffNameList, iffValueList, newProp, propIndex;

  propList = NULL;
  iffNameList = NULL;
  iffValueList = NULL;

  for ( ; db_prop_iter_is_valid(propIter); propIter = db_prop_iter_get_next(propIter) )
  {
    propName = db_prop_iter_get_name(propIter);
    propValue = db_prop_iter_get_value(propIter); 
    if(leftstr(propName,18) == "HPEESOF_PROP_NAME_")
    {
      // these were invalid property names on input so they
      // were stored with valid names, need to change back
      // to invalid name for output
      propName = strcat(strcat(propName,"="),propValue);
      iffNameList = append(iffNameList, list(propName));
    }
    else if(leftstr(propName,19) == "HPEESOF_PROP_VALUE_")
    {
      propName = strcat(strcat(propName,"="),propValue);
      iffValueList = append(iffValueList, list(propName));
    }
    else if(propName != "HPEESOF_FULL_PATH" && propName != "HAS_SHEET" && 
        leftstr(propName,29)!="HPEESOF_SYMBOLPAGE_PROP_NAME_" &&
        leftstr(propName,30)!="HPEESOF_SYMBOLPAGE_PROP_VALUE_")
    {
      propList = append(propList,list(strcat(strcat(propName,"="),propValue)));

      // get prop type and make new user attribute if not string prop type
      propType = db_prop_iter_get_type(propIter);
      if(propType == PROPERTY_VALUE_LONG)
      {
        propType = strcat(propName, "_HPEESOF_PROP_TYPE=integer");
        propList = append(propList,(list(propType)));
      }
      else if(propType == PROPERTY_VALUE_DOUBLE)
      {
        propType = strcat(propName, "_HPEESOF_PROP_TYPE=real");
        propList = append(propList,(list(propType)));
      }
    }
  }

  // see if there were any invalid names to change back to input format
  while(iffNameList)
  {
    propName = car(iffNameList);       //HPEESOF_PROP_NAME_x=name
    pos = index(propName,"=");
    newProp = rightstr(propName,strlen(propName)-pos-1);
    newProp = strcat(newProp,"=");
    propName = leftstr(propName,pos);  //HPEESOF_PROP_NAME_x

    // parse off the 'x' and look for HPEESOF_PROP_VALUE_x
    propIndex = rightstr(propName,strlen(propName)-18);
    propValue = find_in_list(strcat("HPEESOF_PROP_VALUE_",propIndex),19+strlen(propIndex),iffValueList);

    // now we should have HPEESOF_PROP_VALUE_x=value, finish newProp
    if(propValue)
    {
      pos = index(propValue,"=");
      propValue = rightstr(propValue,strlen(propValue)-pos-1);
      newProp = strcat(newProp,propValue);

      propList = append(propList,list(newProp));
    }
    iffNameList = cdr(iffNameList);
  }

  return(propList);
}

//////////////////////////////////////////////////////////////////////
// Check to see if the IFF_PIN_NAME property exists on in the list 
// of pin properties. If it does and the name matches up to the validated
// name then restore the original IFF name before exporting into IFF
// and remove the property from the list.
//////////////////////////////////////////////////////////////////////
defun iff_check_for_bad_pin_name(pinName, propList)
{

  decl len = strlen(IffBadPinNameProperty);
  decl iffPinName;
  decl newEntry;
  decl tmpList;
  decl tmpName;

  iffPinName = *pinName;
  tmpList    = *propList;
  *propList  = NULL;

  while( tmpList != NULL )
    {
      if( leftstr(car(tmpList), len) == IffBadPinNameProperty )
	{
	  newEntry = car(tmpList);
	  iffPinName = rightstr(newEntry, strlen(newEntry)-len-1); 

	  tmpName = ifftolib_fix_name( iffPinName );
	  if( leftstr(tmpName, 1) == "_" )
	    tmpName = strcat("x", rightstr(tmpName, strlen(tmpName)-1));

	  if(( tmpName != NULL ) && ( *pinName == tmpName ))
	    {
	      newEntry = list(*pinName, iffPinName);
	      if( IffReNamedNodeList == NULL )
		IffReNamedNodeList = newEntry;
	      else
		IffReNamedNodeList = append(IffReNamedNodeList, newEntry);

	      *pinName = iffPinName;
	    }
	}
      else
	{
	  newEntry = list(car(tmpList));
	  if( propList == NULL )
	    *propList = newEntry;
	  else
	    *propList = append(*propList, newEntry);
	}
      tmpList = cdr(tmpList);
    }
}

//////////////////////////////////////////////////////////////////////
//return pinList of all pin names with logical pinNums  
//     ex: [1, "p1", 3, "p3", 2, "pin2"]  
//////////////////////////////////////////////////////////////////////

// This function is not 1:1 with DSN version
defun oa_traverse_symbol_pins(context, fileHandle, logFile)
{
    // Fix the layer for symbol pins to the value of PIN_COLOR_P
    decl ShadeRule = de_get_preference(PIN_COLOR_P);

    // decl pinMappingExists = iff_ex_map_has_pin_mapping(objectPath);

    decl portType = 50;    // DOTPIN
    decl labelSize = "ANSI100";
    decl labelOn = "F";

    decl portInd = 0;
    decl numOn = "T";
    decl numJust = "ORIGINAL";

    decl labelParallel = "T";

    IffReNamedNodeList = NULL;  // Global

    decl numX, numY;
    decl labelX, labelY;
    decl pinList=NULL;

    decl pinIter = db_create_pin_iter(context);
    for (; db_pin_iter_is_valid(pinIter);
        pinIter = db_pin_iter_get_next(pinIter))
    {
        decl portNo = db_get_pin_term_number(pinIter);
        decl snapCoordH = db_get_pin_snap_point(pinIter);
        decl portX = db_get_x(snapCoordH)/UserUnits * 100;
        decl portY = db_get_y(snapCoordH)/UserUnits * 100;
        labelX = numX = portX;
        labelY = numY = portY;

        decl pinName = db_get_pin_term_name(pinIter);
        decl portAngle = db_get_pin_angle_normalized(pinIter);
        decl portRot = oa_iff_conn_rot(portAngle);

        // Map the pins back to IFF form...
        //iff_ex_map_pin(objectPath, &pinName, &portNo);

        // If a name was not assigned then build one...
        if(pinName == NULL || pinName == "")
            pinName = strcat("P",portNo);

        decl propIter = db_create_prop_iter(pinIter);
        decl propList = build_property_list(propIter);
        iff_check_for_bad_pin_name(&pinName, &propList);

        pinList = append(pinList, list(portNo, pinName));

        decl portList = list("SYMPIN",ShadeRule,portRot,portType,portInd,
            labelSize,portX,portY,pinName,
            labelX,labelY,labelOn,labelParallel,
            portNo,numOn,numX,numY,numJust);

        /*decl pinDirection = oa_iffSetupPinDirection(pinIter);
        if (pinDirection)
        {
            portList=append(portList, list(strcat("IFF_SYMPIN_DIRECTION=", pinDirection)));
        }*/

        if( propList != NULL )
            portList = append(portList, propList);

        /*if( pinMappingExists == FALSE )
            portList  = append(portList, list(strcat(IffPinMappingName,"=")));*/

        if(fileHandle)
        {
            fputs(fileHandle, blanks_to_sepchar(portList));
            fputs(fileHandle, strcat("SYMPINEND",SEP_CHAR));
        }
    }

    return(pinList);
}


/// Check the schematic, if one exists, for ports.  If the port has a CDSiotype property, 
///   use that for the IFF_SYMPIN_DIRECTION value in preference to the pin direction field.
//
// If the port has a CDSiotype property, 
// use that for the IFF_SYMPIN_DIRECTION value in preference to the pin direction field.
// In ADS OA, Symbol and Schematic are separate views.
// Also, in ADS OA, properties attached to the symbol view are not copied to the instance.
// Therefore, properties cannot be seen in Edit/Properties dialog. 
defun oa_iffSetupPinDirection(pinIter)
{
    decl pinDirection;
    decl propIter = db_create_prop_iter(pinIter);
    for ( ; db_prop_iter_is_valid(propIter); propIter = db_prop_iter_get_next(propIter) )
    {
        decl propName = db_prop_iter_get_name(propIter);
        if(propName == "CDSiotype")
        {
            decl CDSiotype = db_prop_iter_get_value(propIter);
            if(CDSiotype == "ipin")
            {
                pinDirection="input";
            }
            else if(CDSiotype == "opin") 
            {
                pinDirection="output";
            }
            else if(CDSiotype == "iopin")
            {
                pinDirection="inputOutput";
            }

            return(pinDirection);
        }
    }

    /* No CDSiotype property was found on the ports.  Set the pin direction to be 
    the value that is found for the pin direction. */
    decl pinTerm = db_get_pin_term(pinIter);
    pinDirection = db_get_term_type(pinTerm);
    if(pinDirection == 0)
    {
        pinDirection="input";
    }
    else if(pinDirection == 1)
    {
        pinDirection="output";
    }
    else
    {
        pinDirection="inputOutput";
    }

    return(pinDirection);
}

//////////////////////////////////////////////////////////////////////
// Given a design and the ports/pins of that design check to see
// if a Named Connection exists on the node that the port is 
// connected to. If one exists then verify that the name matches
// the name on the port/pin. If not then issue a warning message
// about the pin/port/node name mismatch and add the node to
// the list to ignore when exporting wire labels.
//////////////////////////////////////////////////////////////////////
defun iff_validate_pins_vs_ports(designPath, pinList)
{
    decl plist;
    decl pinId;
    decl portId;
    decl pinName;
    decl netName;
    decl tmpList;

    decl context = de_find_design_context_from_name(designPath);

    IffBadNamedConnList = NULL;

    decl pinIter = db_create_pin_iter(context);
    for (; db_pin_iter_is_valid(pinIter); pinIter = db_pin_iter_get_next(pinIter))
    {

        decl pinName = db_get_pin_term_name(pinIter);
        decl term = db_get_pin_term(pinIter);
        decl net = db_get_term_net(term);
        decl netName = db_get_net_name(net);
        tmpList = member(netName, IffReNamedNodeList);
        if( tmpList != NULL )
            netName = car(cdr(tmpList));

        portId = db_get_pin_term_number(pinIter);
        plist = pinList;
        while( plist != NULL )
        {
            pinId = car(plist);   
            plist = cdr(plist);
            pinName = car(plist); 
            plist = cdr(plist);

            if( pinId != portId )
                continue;

            if( pinName == netName )
                break;

            decl msg = list("ERROR: The Named Connection does not",
                "match the symbol pin/schematic port name.\n",
                "The name will be transfered.  However this can\n",
                "give incorrect results.  You should resolve this\n",
                "problem and reexport the file.\n\n",
                "        Symbol Pin Name =", pinName, "\n",
                "        Named Connection =", netName, 
                "\n\n");
            iff_log_message(msg);

            if( IffBadNamedConnList == NULL )
                IffBadNamedConnList = list(netName);
            else
                IffBadNamedConnList = append(IffBadNamedConnList,list(netName));
        }
    }

    return(pinList);
}

//////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////
// TODO: ?
defun write_attr_viewer(fileHandle, nameVis, locX, locY, textRot, attrName, attrValue)
{
   decl textSize, textData, textRule;

   textRule=0;
   textSize = "0,0,IN/100";
   textRule = iff_text_rule(iff_get_preference(INST_TEXT_HEIGHT_P));

   if(nameVis)
     nameVis = "LEFT!FULLPATH!DISPLAY";
   else nameVis = "LEFT!NOPATH!DISPLAY";

   textData = list("ATTV",SEP_CHAR,locX,locY,attrName,attrName,
			nameVis, textRule, ShadeRule, textRot,
     			textSize, attrValue);

   if(fileHandle)
     fputs(fileHandle, blanks_to_sepchar(textData));
}

//////////////////////////////////////////////////////////////////////
// Find the parameter "layer" and and return its value (if found)
//////////////////////////////////////////////////////////////////////
defun iff_get_layer_from_params(paramList)
{
  decl layerName = NULL;
  decl param;
  decl formHandle;

  while(( paramList != NULL ) && ( layerName == NULL ))
    {
      param = parse(car( paramList ));
      paramList = cdr(paramList);
      if( param == NULL )
	continue;

      if( car(param) != "layer" )
	continue;

      if( member("prm", param) )
	{
	  layerName = nth(6, param);
	  formHandle = dm_find_form_definition(layerName);
	  if( formHandle != NULL )
	    layerName = dm_get_form_definition_attribute(formHandle, 
							 DM_FORM_LABEL);
	}
      else
	{
	  layerName = car(cdr(cdr(param)));
	}
    }

  if( layerName == NULL ) 
    layerName = defaultMaskName;

  return(layerName);
}

//////////////////////////////////////////////////////////////////////
// paramList = ["port=1"] or [port=prm(<formset>,<value>)]
//////////////////////////////////////////////////////////////////////
defun get_port_num_from_params(paramList)
{
    decl portNum=0;
    decl paramValue;

    while( paramList != NULL )
      {
	paramValue = parse(car(paramList));
	paramList = cdr(paramList);
	if( car(paramValue) != IffConnNumProp )
	  continue;

	if( member("prm", paramValue) )
	  portNum = nth(6, paramValue);
	else
	  portNum=car(cdr(cdr(paramValue)));
      }

    return(portNum);
}

//////////////////////////////////////////////////////////////////////
//given: pinList of all pin names with logical pinNums  
//       ex: [1, "p1", 3, "p3", 2, "pin2"]  
// node name has to match symbol pin name for the hierarchy to match 
// up correctly so get port number and go retrieve cooresponding pin 
// name if symbol pin has no name, use P<log#>
//////////////////////////////////////////////////////////////////////
defun get_pin_name_from_symbol(pinList, portNum, logFile)
{
    decl pinName;
    decl errStr;
    decl envName;

    while(pinList)
    {
      if(portNum == car(pinList))
	return(car(cdr(pinList)));
      
      pinList = cdr(cdr(pinList));
    }
    
    pinName = strcat("P",portNum);
    
    if( repType == REP_LAY )
      envName = "layout";
    else
      envName = "schematic";

    errStr = list("\nWARNING: Possible pin/port mismatch between",
		  envName, "and symbol.\n",
		  "        Unable to find matching symbol pin",
		  strcat("for port number ", portNum, ".\n        "),
		  strcat("Using symbol pin name = ", pinName, ".\n"));

    if( repType != REP_LAY )
      iff_log_message(errStr);

    return(pinName);
}

defun port_stack_clear()
{
    PortStack = NULL;
}

defun port_stack_push(connID, portNum)
{
    PortStack = append(PortStack, list(connID, portNum));
}

// given port name, return logical number
defun port_stack_find(connID, portNum)
{
    decl tmpStack=PortStack;

    while(tmpStack)
    {
        if(car(tmpStack) == connID)
	    return(car(cdr(tmpStack)));

        tmpStack = cdr(cdr(tmpStack));
    }

    /* not found */
    return(-1);
}

/* look for the specified item in the list
   match by first 'len' characters if length > 0 */
defun find_in_list(item, len, inList)
{
  while(inList)
  {
    if(len>0)
    {
      if(leftstr(car(inList),len) == item)
	return(car(inList));
    }
    else
    {
      if(car(inList) == item)
	return(car(inList));
    }
    inList = cdr(inList);
  }

  // not found
  //print_value("NOT FOUND");
  return(NULL);
}


/////////////////////////////////////////////////////////////////////////////
// Search a list of properties in the form of name=value pairs and remove
// from the list any property that matches the property name.
/////////////////////////////////////////////////////////////////////////////
defun iff_find_and_delete_prop(propName, propList)
{
  decl newPropList = NULL;
  decl propPair;
  decl parsedPair;

  while( propList != NULL )
    {
      propPair = car(propList);
      parsedPair = parse(propPair);
      propList = cdr(propList);

      if( car(parsedPair) != propName )
	newPropList = append(newPropList, list(propPair));
    }

  return( newPropList );
}

/////////////////////////////////////////////////////////////////////////////
// given: pinList of all pin names with logical pinNums  
//                  ex: [1, "p1", 3, "p3", 2, "pin2"]  
/////////////////////////////////////////////////////////////////////////////
defun oa_write_connector(fileHandle, inst, isPort, paramList, pinList, logFile, context)
{
    decl portHandle, connX, connY;
    decl portList, connRot, connAngle, connType, labelSize;
    decl pinName, labelX, labelY, labelOn, labelParallel;
    decl busType, textHeight, portNum, userAttrList;
    decl nodeNum, mx, my;
    decl layerName;

    if( IffDebugMessageLevel > 5 )
        print_value("Begin: write_connector");

    if(isPort)
        connType = 26;
    else
        connType = 20;

    //connID = db_get_instance_attribute(instHandle, INST_NAME);
    decl connID = db_get_instance_name(inst);

    labelSize = "OTHER FONT";
    labelOn = "F";
    busType = "N";
    labelParallel = "T";

    decl transform = db_get_instance_placement_transform(inst);
    if( !transform )
    {
        decl errstr = list("WARNING: Skipping PORT/GROUND (", 
            connID, 
            ") no placement information found.");

        iff_log_message(errstr);

        return;
    }

    if( IffDebugMessageLevel > 15 )
        print_value(list(connID, instHandle,transform));

    connAngle = float (db_get_transform_angle(transform));
    mx = db_get_transform_mirror_x(transform);
    my = db_get_transform_mirror_y(transform);
    connRot = iff_conn_rot(connAngle, mx, my);
    connAngle = connAngle/1000.0;

    if(( mx == 1 ) && ( my == 1 ))
        connAngle = connAngle + 180;
    else if( mx == 1 )
        connAngle = -connAngle;
    else if(my == 1 )
        connAngle = 180 - connAngle;

    if(de_is_schematic_context(context) || de_is_symbol_context(context))
    {
        labelX = connX = db_get_transform_x(transform)/UserUnits*100;
        labelY = connY = db_get_transform_y(transform)/UserUnits*100;
    }
    else
    {
        labelX = connX = db_get_transform_x(transform)/UserUnits;
        labelY = connY = db_get_transform_y(transform)/UserUnits;
        layerName = iff_get_layer_from_params(paramList);
    }

    // set the label loc based on rotation of connector
    textHeight = iff_get_preference(INST_TEXT_HEIGHT_P)*100;
    if(connRot == 0 || connRot == 2)
        labelY -= textHeight;
    else 
        labelX += textHeight;

    if(de_is_layout_context(context))
    {
        decl bbox = db_get_instance_bbox(inst, INST_SYMBOL_AND_ANNOT_BBOX);
        decl portSize;
        // Get the port/ground size from the bbox.  Note that grounds are square,
        // so either direction is fine to use, but ports need to use the direction
        // of the arrow for correct sizing.
        if (isPort && (connRot == 1 || connRot == 3))
            portSize = (db_get_bbox_y2(bbox) - db_get_bbox_y1(bbox))/UserUnits;
        else
            portSize = (db_get_bbox_x2(bbox) - db_get_bbox_x1(bbox))/UserUnits;
    }


    // TODO_OA
    //nodeNum = oa_iff_get_node_id_from_instance(inst);

    if(isPort)
    {
        // This path is NEVER executed, because pins are not instances in OA
        // Instead oa_iff_export_ports() is used

        /* node name has to match symbol pin name for the hierarchy to match up correctly
        so get port number and go retrieve cooresponding pin name
        if symbol pin has no name, use P<log#> */

        portNum = get_port_num_from_params(paramList);
        pinName = get_pin_name_from_symbol(pinList, portNum, logFile);

        port_stack_push(connID, portNum);
        paramList = strcat(IffConnNum, "=", portNum);
        if(!de_is_layout_context(context))
        {
            // userAttrList=setupCDSiotype(userAttrList, repH, portNum);
            decl ShadeRule = de_get_preference(PORT_COLOR_P);
            portList = list("CON",ShadeRule,connType,connRot,
                labelSize,connX,connY,pinName,
                labelX,labelY,connX,connY,labelOn,
                labelParallel,busType,
                strcat(IffConnId,"=",connID), paramList);
        }
        else
        {
            // Convert angle to IFF standard and normalize...
            connAngle = iff_normalize_angle(connAngle+180, 0, 360);
            portList = list("ARTPIN",layerName,"", "CONNECTOR", 
                connX,connY, connAngle, "POINTPIN", portNum, 
                connID, 1, connX, connY, "*", nodeNum, paramList);
        }

        if( userAttrList != NULL )
            iff_check_for_bad_pin_name(&pinName, &userAttrList);
    }
    else 
    {
        pinName = "GROUND";
        if(!de_is_layout_context(context))
        {
            decl ShadeRule = de_get_preference(PORT_COLOR_P);
            portList = list("CON",ShadeRule,connType,connRot,
                labelSize,connX,connY,pinName,
                labelX,labelY,connX,connY,labelOn,
                labelParallel,busType,strcat(IffConnId,"=",connID));
        }
        else
        {
            // Convert angle to IFF standard and normalize...
            connAngle = iff_normalize_angle(connAngle-90, 0, 360);
            portList = list("ARTPIN",layerName, "", "GROUND", 
                connX,connY, connAngle, "POINTPIN",
                0, connID, 1, connX, connY, "*", nodeNum);
        }
    }

    decl propIter = db_create_prop_iter(inst);
    decl userAttrList = build_property_list(propIter);
    if(userAttrList)
        portList = append(portList, userAttrList);

    if(fileHandle)
    {
        fputs(fileHandle, blanks_to_sepchar(portList));
        if(!de_is_layout_context(context))
            fputs(fileHandle, strcat("CONEND",SEP_CHAR));
    }

    if( IffDebugMessageLevel > 5 )
        print_value("End:   write_connector");
}

defun setupCDSiotype(attrList, repH, portNum)
{
  /* Search the attribute list to see if CDSIotype is specified.  If it is not, add it to 
     the user attribute list for the port */

  decl param;
  decl tmp=attrList;
  decl CDSiotypeNeeded=TRUE;

  while(param=car(tmp))
  {
      tmp=cdr(tmp);
      param=parse(param, "=", "");

      if(car(param) == "CDSiotype")
      {
	  CDSiotypeNeeded=FALSE;
	  break;
      }
  }

  if(CDSiotypeNeeded)
  {
      decl symH=db_get_rep_attribute(repH, REP_SYMBOL);
      decl pinDirection;
      decl pNum;
      decl pinH=db_get_symbol_attribute(symH, SYMB_PORT_HEAD);

      while(pinH)
      {
	  pNum = db_get_pin_attribute(pinH,PIN_NUMBER);
	  if(pNum == portNum)
	  {
	      pinDirection = db_get_pin_attribute(pinH, PIN_DIRECTION);
	      if(pinDirection == 0)
	      {
		attrList=append(attrList, list("CDSiotype=ipin"));
	      }
	      else if(pinDirection == 1)
	      {
		attrList=append(attrList, list("CDSiotype=opin"));
	      }
	      else
	      {
		attrList=append(attrList, list("CDSiotype=iopin"));
	      }

	      break;
	  }
	  pinH=db_next_port(pinH);
      }
  }

  return(attrList);

}

defun build_internal_node_name(pinHandle)
{
  decl nodeHandle, nodeName;

  nodeHandle = db_get_pin_attribute(pinHandle, PIN_NODE_PTR);
  if(nodeHandle)
    nodeName = strcat("node",db_get_node_number(nodeHandle));
}

//return pinList of all pin names with logical pinNums  ex: [1, "p1", 3, "p3", 2, "pin2"]
defun oa_traverse_symbol(fileHandle, symContext, logFile)
{
    if( fileHandle == NULL )
        return NULL;

    oa_iff_write_geom(symContext, fileHandle, logFile, NULL, NULL/*instHierTransform*/);

    decl pinList = oa_traverse_symbol_pins(symContext, fileHandle, logFile);
    return(pinList);
}



/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
defun iff_store_output_line(buffer)
{
  OutputList = append(OutputList, list(buffer));

  NumOutputLines = NumOutputLines + 1;
}

/* format tokens, inserting new line after 80 chars and cont char in next line */
defun iff_fmt_tokens(fileHandle, dataList)
{
  decl buffer, item;

  while(dataList)
  {
    item = car(dataList);

    buffer = append(buffer, list(item)); 

    dataList= cdr(dataList);
  }

  iff_store_output_line(buffer);
}

defun iff_write_wires(wireList, fileHandle, logFile)
{
  decl longStrg;

  while(wireList)
  {
    longStrg = blanks_to_sepchar(car(wireList));
    if(fileHandle)
      fputs(fileHandle, longStrg);
    wireList = cdr(wireList);
  }
}

defun iff_write_output_lines(fileHandle, logFile)
{
  decl longStrg;

  if(NumOutputLines == 0)
    return;

  while(OutputList)
  {
    longStrg = blanks_to_sepchar(car(OutputList));
    if(fileHandle)
      fputs(fileHandle, longStrg);
    OutputList = cdr(OutputList);
  }

  NumOutputLines = 0;
}

//////////////////////////////////////////////////////////////////////
// Search the property handles looking for the object path that was
// previously used. If found verify that the object path could have
// would have created the design name that we are currently working
// with. If it does not match up or is not found then return NULL else
// return the object path.
//////////////////////////////////////////////////////////////////////
defun oa_iff_find_path_property(propIter)
{
    if(IffIgnorePathProperty)
        return (NULL);

    for ( ; db_prop_iter_is_valid(propIter);
        propIter = db_prop_iter_get_next(propIter) )
    {
        decl propName = db_prop_iter_get_name(propIter);
        if(propName == "HPEESOF_FULL_PATH")
        {
            decl propType = db_prop_iter_get_type(propIter);
            // should be string type
            if(propType == PROPERTY_VALUE_STRING)
            {
                decl propValue = db_prop_iter_get_value(propIter); 
                return(propValue);
            }
        }
    }

    return (NULL);
}

// In open access, ADS2011 , properties are attached with the design not instance
defun oa_iff_find_design_path_property(context, instIter)
{
    decl hierarchyContext = db_create_hierarchy_context(context, DIRECT_DESCENDANTS);
    decl instP = db_inst_iter_get_instance( instIter ); 
    if (!db_is_primitive_instance_in_hierarchy(hierarchyContext, instP))
    {
        decl subHierContext = db_get_hierarchy_context_for_instance(hierarchyContext, instP);
        if( subHierContext )
        {
            decl subDesignContext = db_get_design_context_from_hierarchy(subHierContext);
            decl propIter = db_create_prop_iter(subDesignContext);
            return oa_iff_find_path_property(propIter);
        }
    }
}


/*  Search the symbol property handles looking for the object path that was
 *  previously used. If found verify that the object path could have
 *  would have created the design name that we are currently working
 *  with. If it does not match up or is not found then return NULL else
 *  return the object path.  */

defun iff_find_path_on_symbol(designName)
{
    decl dsnH, repH, symbolH, propH;
    decl propType, propName, propValue;

    dsnH=db_get_design(designName);

    if(dsnH)
    {
      repH=db_get_rep(dsnH, REP_SCHEM);
      if(repH)
      {
	symbolH=db_get_rep_attribute(repH, REP_SYMBOL);
	if(symbolH)
	{
	  propH=db_get_symbol_attribute(symbolH, SYMB_PROPERTY);
	  while(propH)
	  {
	    propName = db_get_property_attribute(propH, PROPERTY_NAME); 
	    if(propName == "HPEESOF_FULL_PATH")
	    {
	      propType = db_get_property_attribute(propH, PROPERTY_TYPE); 

	      /* should be string type */
	      if(propType == PROPERTY_VALUE_STRING)
	      {
		propValue = db_get_property_attribute(propH, propType); 
		return(propValue);
	      }
	    }
	    propH = db_next_property(propH);
	  }
	}
      }
    }

    return(NULL);
}

defun oa_iff_find_bad_instance_property(instIter)
{
    decl propIter = db_create_prop_iter(instIter);
    for ( ; db_prop_iter_is_valid(propIter);  
        propIter = db_prop_iter_get_next(propIter) )
    {
        decl propName = db_prop_iter_get_name(propIter);
        if(propName == IffBadInstNameProperty ) 
        {
            decl propType = db_prop_iter_get_type(propIter);
            // should be string type
            if(propType == PROPERTY_VALUE_STRING)
            {
                decl propValue = db_prop_iter_get_value(propIter);
                if( propValue != NULL )
                {
                    return(propValue);
                }
            }
        }
    }

    return(NULL);
}


//////////////////////////////////////////////////////////////////////
//check for HPEESOF_SYMBOLPAGE_PROP_NAME_x=name and 
//          HPEESOF_SYMBOLPAGE_PROP_VALUE_x=value pairs and convert to 
//          name=value
//////////////////////////////////////////////////////////////////////
defun build_symbolpage_property_list(symbolName)
{
  decl propType, propName, propValue, propList,
       pos, iffNameList, iffValueList, newProp, propIndex;

  propList = NULL;
  iffNameList = NULL;
  iffValueList = NULL;
  decl symContext = de_get_design_context_from_name(symbolName, REP_SCHEM);
  decl propIter = db_create_prop_iter(symContext);
  for ( ; db_prop_iter_is_valid(propIter);
        propIter = db_prop_iter_get_next(propIter) )
    {
      propName = db_prop_iter_get_name(propIter);
      if(leftstr(propName,29) == "HPEESOF_SYMBOLPAGE_PROP_NAME_")
	{
	  propType  = db_prop_iter_get_type(propIter);
	  propValue = db_prop_iter_get_value(propIter);
	  propValue = strcat(strcat(propName,"="),propValue);
	  iffNameList = append(iffNameList, list(propValue));
	}
      else if(leftstr(propName,30) == "HPEESOF_SYMBOLPAGE_PROP_VALUE_")
	{
	  propType  = db_prop_iter_get_type(propIter);
	  propValue = db_prop_iter_get_value(propIter);
	  propValue = strcat(strcat(propName,"="),propValue);
	  iffValueList = append(iffValueList, list(propValue));
	}

    }

  // see if there were any invalid names to change back to input format
  while(iffNameList)
  {
    propName = car(iffNameList);       //HPEESOF_SYMBOLPAGE_PROP_NAME_x=name
    pos = index(propName,"=");
    newProp = rightstr(propName,strlen(propName)-pos-1);
    newProp = strcat(newProp,"=");
    propName = leftstr(propName,pos);  //HPEESOF_SYMBOLPAGE_PROP_NAME_x

    // parse off the 'x' and look for HPEESOF_SYMBOLPAGE_PROP_VALUE_x
    propIndex = rightstr(propName,strlen(propName)-29);
    propValue = find_in_list(strcat("HPEESOF_SYMBOLPAGE_PROP_VALUE_",propIndex),30+strlen(propIndex),iffValueList);

    // now we should have HPEESOF_PROP_VALUE_x=value, finish newProp
    if(propValue)
    {
      pos = index(propValue,"=");
      propValue = rightstr(propValue,strlen(propValue)-pos-1);
      newProp = strcat(newProp,propValue);

      propList = append(propList,list(newProp));
    }
    iffNameList = cdr(iffNameList);
  }

  return(propList);
}

//////////////////////////////////////////////////////////////////////
//check for HPEESOF_<PAGE>_PROP_NAME_x=name and 
//          HPEESOF_<PAGE>_PROP_VALUE_x=value pairs and convert to 
//          name=value
//
//////////////////////////////////////////////////////////////////////
defun build_page_property_list(symContext, page)
{
  decl propType, propName, propValue, propList,
       pos, iffNameList, iffValueList, newProp, propIndex;

  decl pagePropName     = strcat("HPEESOF_", page, "_PROP_NAME_");
  decl pagePropValue    = strcat("HPEESOF_", page, "_PROP_VALUE_");
  decl pagePropNameLen  = strlen(pagePropName);
  decl pagePropValueLen = strlen(pagePropValue);

  propList = NULL;
  iffNameList = NULL;
  iffValueList = NULL;

  decl propIter = db_create_prop_iter(symContext);
  for ( ; db_prop_iter_is_valid(propIter);
        propIter = db_prop_iter_get_next(propIter) )
    {
      propName = db_prop_iter_get_name(propIter);
      if(leftstr(propName,pagePropNameLen) == pagePropName)
	{
	  propType  = db_prop_iter_get_type(propIter);
	  propValue = db_prop_iter_get_value(propIter);
          if (is_string(propValue))
          {
              propValue=iff_fix_escaping(propValue);
          }
	  propValue = strcat(strcat(propName,"="),propValue);
	  iffNameList = append(iffNameList, list(propValue));
	}
      else if(leftstr(propName,pagePropValueLen) == pagePropValue )
      {
          propType  = db_prop_iter_get_type(propIter);
          propValue = db_prop_iter_get_value(propIter); 
          if (is_string(propValue))
          {
              propValue=iff_fix_escaping(propValue);
          }
          propValue = strcat(strcat(propName,"="),propValue);
          iffValueList = append(iffValueList, list(propValue));
      }

    }
  // see if there were any invalid names to change back to input format
  while(iffNameList)
  {
    propName = car(iffNameList);       //HPEESOF_SYMBOLPAGE_PROP_NAME_x=name
    pos = index(propName,"=");
    newProp = rightstr(propName,strlen(propName)-pos-1);
    newProp = strcat(newProp,"=");
    propName = leftstr(propName,pos);  //HPEESOF_SYMBOLPAGE_PROP_NAME_x

    // parse off the 'x' and look for HPEESOF_SYMBOLPAGE_PROP_VALUE_x
    propIndex = rightstr(propName,strlen(propName)-pagePropNameLen);
    propValue = find_in_list(strcat(pagePropValue,propIndex),pagePropValueLen+strlen(propIndex),iffValueList);

    // now we should have HPEESOF_PROP_VALUE_x=value, finish newProp
    if(propValue)
    {
      pos = index(propValue,"=");
      propValue = rightstr(propValue,strlen(propValue)-pos-1);
      newProp = strcat(newProp,propValue);

      propList = append(propList,list(newProp));
    }
    iffNameList = cdr(iffNameList);
  }

  return(propList);
}

//////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////
defun build_symbol_property_list(symContext, objectPath)
{
  decl propType, propName, propValue, propList;

  propList = NULL;
  decl propIter = db_create_prop_iter(symContext);
  for ( ; db_prop_iter_is_valid(propIter);
        propIter = db_prop_iter_get_next(propIter) )
    {
      propName = db_prop_iter_get_name(propIter);
      propName = iff_ex_map_single_prop(objectPath, propName);
      if((leftstr(propName,8) != "HPEESOF_" ) && (propName != "HAS_SHEET" ))
	{
	  propType  = db_prop_iter_get_type(propIter);
	  propValue = db_prop_iter_get_value(propIter); 
          if (is_string(propValue))
          {
              propValue=iff_fix_escaping(propValue);
          }
	  propValue = strcat(strcat(propName,"="),propValue);
	  propList  = append(propList, list(propValue));
	}

    }

  //
  // Now check to see if any property mapping exists. If
  // not then add a empty mapping string during export.
  //
  if( iff_ex_map_has_prop_mapping(objectPath) == FALSE )
    {
      propValue = strcat(IffPropertyMappingName,"=");
      propList  = append(propList, list(propValue));
    }

  return(propList);
}

/*////////////////////////////////////////////////////////////////////
//
// Search the ObjectPathList for the design name. If the design name
// is found then return the object path that was written when the 
// symbol page was written. If the design name is not in the list
// then return NULL.
//
/////////////////////////////////////////////////////////////////////*/
defun iff_find_object_path(designName)
{
  decl objs, tt;

  for(objs=ObjectPathList; objs; objs=cdr(objs))
    {
      if( car(car(objs)) == designName )
	return(car(cdr(car(objs))));
    }

  return( NULL );
}


// **********************************************************
// get attribute list for drawpage
// check for HPEESOF_DRAWPAGE_PROP_NAME_x=name and 
// HPEESOF_DRAWPAGE_PROP_VALUE_x=value pairs and convert to name=value
// **********************************************************
defun build_drawpage_property_list(propHandle)
{
  decl propType, propName, propValue, propList, 
       pos, iffNameList, iffValueList, newProp, propIndex;

  propList = NULL;
  iffNameList = NULL;
  iffValueList = NULL;

  while(propHandle)
  {
    propName = db_get_property_attribute(propHandle,PROPERTY_NAME); 
    if(leftstr(propName,30) == "HPEESOF_DRAWPAGE_PROP_NAME_")
    {
      propValue = db_get_property_attribute(propHandle, 
			db_get_property_attribute(propHandle,PROPERTY_TYPE)); 
      propName = strcat(strcat(propName,"="),propValue);
      iffNameList = append(iffNameList, list(propName));
    }
    else if(leftstr(propName,31) == "HPEESOF_DRAWPAGE_PROP_VALUE_")
    {
      propValue = db_get_property_attribute(propHandle, 
			db_get_property_attribute(propHandle,PROPERTY_TYPE)); 
      propName = strcat(strcat(propName,"="),propValue);
      iffValueList = append(iffValueList, list(propName));
    }
    propHandle = db_next_property(propHandle);
  }

  // see if there were any invalid names to change back to input format
  while(iffNameList)
  {
    propName = car(iffNameList);       //HPEESOF_DRAWPAGE_PROP_NAME_x=name
    pos = index(propName,"=");
    newProp = rightstr(propName,strlen(propName)-pos-1);
    newProp = strcat(newProp,"=");
    propName = leftstr(propName,pos);  //HPEESOF_DRAWPAGE_PROP_NAME_x

    /* parse off the 'x' and look for HPEESOF_DRAWPAGE_PROP_VALUE_x */
    propIndex = rightstr(propName,strlen(propName)-30);
    propValue = find_in_list(strcat("HPEESOF_DRAWPAGE_PROP_VALUE_",propIndex),31+strlen(propIndex),iffValueList);

    // now we should have HPEESOF_PROP_VALUE_x=value, finish newProp
    if(propValue)
    {
      pos = index(propValue,"=");
      propValue = rightstr(propValue,strlen(propValue)-pos-1);
      newProp = strcat(newProp,propValue);

      propList = append(propList,list(newProp));
    }
    iffNameList = cdr(iffNameList);
  }

  return(propList);
}

defun oa_build_drawpage_property_list(context)
{
  decl propName, propValue, pos, newProp, propIndex;

  decl propList = NULL;
  decl iffNameList = NULL;
  decl iffValueList = NULL;

  decl propIter = db_create_prop_iter(context);
  for ( ; db_prop_iter_is_valid(propIter); propIter = db_prop_iter_get_next(propIter))
  {
      propName = db_prop_iter_get_name(propIter);
      if(leftstr(propName,30) == "HPEESOF_DRAWPAGE_PROP_NAME_")
      {
          propValue = db_prop_iter_get_value(propIter);
          propName = strcat(strcat(propName,"="),propValue);
          iffNameList = append(iffNameList, list(propName));
      }
      else if(leftstr(propName,31) == "HPEESOF_DRAWPAGE_PROP_VALUE_")
      {
          propValue = db_prop_iter_get_value(propIter);
          propName = strcat(strcat(propName,"="),propValue);
          iffValueList = append(iffValueList, list(propName));
      }
  }

  // see if there were any invalid names to change back to input format
  while(iffNameList)
  {
    propName = car(iffNameList);       //HPEESOF_DRAWPAGE_PROP_NAME_x=name
    pos = index(propName,"=");
    newProp = rightstr(propName,strlen(propName)-pos-1);
    newProp = strcat(newProp,"=");
    propName = leftstr(propName,pos);  //HPEESOF_DRAWPAGE_PROP_NAME_x

    /* parse off the 'x' and look for HPEESOF_DRAWPAGE_PROP_VALUE_x */
    propIndex = rightstr(propName,strlen(propName)-30);
    propValue = find_in_list(strcat("HPEESOF_DRAWPAGE_PROP_VALUE_",propIndex),31+strlen(propIndex),iffValueList);

    // now we should have HPEESOF_PROP_VALUE_x=value, finish newProp
    if(propValue)
    {
      pos = index(propValue,"=");
      propValue = rightstr(propValue,strlen(propValue)-pos-1);
      newProp = strcat(newProp,propValue);

      propList = append(propList,list(newProp));
    }
    iffNameList = cdr(iffNameList);
  }

  return(propList);
}

/////////////////////////////////////////////////////////////////////////////
// Create the the correct "CMP" or "ARTCOMP" list and return it.
/////////////////////////////////////////////////////////////////////////////
defun oa_iff_create_component(context, instIter, special, logFile, refPath, flipped, instID_Lay)
{
    decl instList;

    decl MDScmpType;
    decl leafFlag="N";
    decl deMorgFlag="N";
    decl labelFreeze="OFF";

    decl color = 0;
    decl rot = 0;
    decl xLoc = 0;
    decl yLoc = 0;

    decl filePath;
    decl designName, designPath;
    decl badInstanceName;
    decl filePath1;

    if(IffIgnoreDeactivatedComponents && db_is_instance_deactivated(instIter))
    {
        return(instList);
    }

    decl policy = de_is_layout_context(context) ? NETLIST_FROM_LAYOUT : NETLIST_FROM_SCHEMATIC;
    decl hierarchyContext = db_create_hierarchy_context(context, policy);
    decl isPrimitive = db_is_primitive_instance_in_hierarchy(hierarchyContext, instIter);

    decl instH = db_inst_iter_get_instance(instIter);
    decl designName = db_get_instance_design_name(instH);

    if (isPrimitive || IffSubDesignAsLeaf)
    {
        InstIsLeaf = TRUE;
        MDScmpType = "leaf";
    }
    else
    {
        InstIsLeaf = FALSE;
        MDScmpType = "layout";
    }

    designPath = db_get_instance_component_name(instIter);
    designName = db_get_instance_cell_name(instIter);
    decl instName = db_get_instance_name(instIter);

    // Check the badInstanceName against the instName.  If the validated badInstanceName 
    // is equal to instName, output badInstanceName instead of instName.
    badInstanceName = oa_iff_find_bad_instance_property(instIter);
    if (ifftolib_fix_name(badInstanceName) == instName)
    {
        instName = badInstanceName;
    }

    decl transform = db_get_instance_placement_transform(instIter);

    // use these later when transform functions are completed 
    if(!de_is_layout_context(context))
    {
        rot = iff_cmp_rot(TRUE, transform, logFile);
        xLoc = db_get_transform_x(transform)/UserUnits*100;
        yLoc = db_get_transform_y(transform)/UserUnits*100;
    }
    else
    {
        rot = iff_artcomp_rot(TRUE, transform, flipped, FALSE);
        xLoc = db_get_transform_x(transform)/UserUnits;
        yLoc = db_get_transform_y(transform)/UserUnits;
    }

    // see if filePath is stored as an instance property HPEESOF_FULL_PATH
    decl propIter = db_create_prop_iter(instIter);
    filePath = oa_iff_find_path_property(propIter);
    if( ! filePath )
    {
        // Check to see if the symbol has an HPEESOF_FULL_PATH property on it.

        filePath = oa_iff_find_design_path_property(context, instIter);
        if( !filePath )
        {
            // Check to see if we have written symbol page for this design 
            filePath = iff_find_object_path(designName);
            if( !filePath )
            {
                decl libName, compName;
                if(de_is_layout_context(context))
                {
                    if(isPrimitive)
                    {
                        libName = db_get_instance_library_name(instIter);
                        compName = db_get_instance_cell_name(instIter);
                    }
                    else
                    {
                        decl subHierContext = db_get_hierarchy_context_for_instance(hierarchyContext, instIter);
                        decl subDesignContext = db_get_design_context_from_hierarchy(subHierContext);
                        libName = db_get_library_name(context);
                        compName = iff_get_short_design_name(subDesignContext);
                    }
                    designName = compName;
                }
                else
                {
                    if(isPrimitive)
                    {
                        libName = db_get_instance_library_name(instIter);
                        compName = db_get_instance_cell_name(instIter);
                    }
                    else
                    {
                        decl subHierContext = db_get_hierarchy_context_for_instance(hierarchyContext, instIter);
                        decl subDesignContext = db_get_design_context_from_hierarchy(subHierContext);
                        decl isWorkSpaceCell = oa_iff_is_workspace_cell(designPath);
                        if(!isWorkSpaceCell && (IffExportHierOption == 2) && !oa_iff_design_in_list(designPath, IffExportProjectList))
                        {
                            // For PDK component it has to be symbols
                            libName = "symbols";
                            compName = db_get_instance_cell_name(instIter);
                        }
                        else if(!isWorkSpaceCell && 
                            ( (IffExportHierOption == 3) ||
                            ((IffExportHierOption == 2)&& oa_iff_design_in_list(designPath, IffExportProjectList))
                            ))
                        {
                            libName = "symbols";
                            compName = iff_get_short_design_name(subDesignContext);
                        }
                        else
                        {
                            libName = db_get_library_name(context);
                            compName = iff_get_short_design_name(subDesignContext);
                        }
                    }
                } //else

                filePath = strcat(strcat("/",libName),":file/");
                filePath = strcat(filePath, strcat(compName, ":design"));
            }
        }
    }
    
    // Check to see if the user has designated a mapping to use for
    // the file path

    filePath1=filePath;

    // TODO_OA: IFF Export
    /*filePath=iffMapObjectPath(filePath, instHandle);
    iff_ex_map_is_loaded(filePath, designName);*/

    decl instId = 0; // Setting to 0 always as arbitrary integer, not serve any purpose
    if(de_is_schematic_context(context))
    {
        instList = list("CMP", filePath, color, rot, xLoc, yLoc, instId, 
            instName, leafFlag, deMorgFlag, labelFreeze);
    }
    else
    {
        if(filePath1 != filePath)
        {
            // Assume that the design name may have been mapped.  Get the 
            // new name by searching through the filePath.

            designName=iff_get_design_from_object_path(filePath);
        }
        iff_log_message(list("  Instance Path =",refPath));
        instList = list("ARTCOMP", designName, MDScmpType, instID_Lay, 
            car(rot), car(cdr(rot)), xLoc, yLoc, 1.0, 
            strcat("PATH=", refPath));
    }
    
    if( db_is_instance_deactivated(instIter) )
        instList = append(instList, list("HPEESOF_DEACTIVATE=TRUE"));

    return(instList);
}

/// Create the via as "ARTCOMP" list and return it.
defun iff_create_via_as_component(viaLibName, via, logFile, refPath, instID_Lay)
{
    decl transform = db_get_via_placement_transform(via);
    decl flipped = iff_object_flipped(transform);
    decl rot = iff_artcomp_rot(TRUE, transform, flipped, FALSE);
    decl xLoc = db_get_transform_x(transform)/UserUnits;
    decl yLoc = db_get_transform_y(transform)/UserUnits;

    decl  compName = db_get_via_def_name(via);
    decl filePath = strcat(strcat("/",viaLibName),":file/");
    filePath = strcat(filePath, strcat(compName, ":design"));

    iff_log_message(list("  Instance Path =", refPath));

    decl InstIsLeaf = FALSE;
    decl compType = "layout";
    decl instList = list("ARTCOMP", compName, compType, instID_Lay, 
        car(rot), car(cdr(rot)), xLoc, yLoc, 1.0, strcat("PATH=", refPath));

    return instList;
}


defun iff_get_design_from_object_path(objectPath)
{
    decl objectPathList;
    decl i, designName="";
    decl objType;
    decl nonDesignTypeList=list("file", "library", "workbench", 
				"partition", "symbol", "index" );
    decl designTypeList=list("design", "art", "form", "document");

    objectPathList=iffParseString(objectPath, "", ":/");

    for(i=0; i<listlen(objectPathList); i++)
    {
        if(nth(i, objectPathList) == ":")
	{
	    objType=tolower(nth(i+1, objectPathList));

	    designName=strcat(designName, nth(i-1, objectPathList));
	    if(leftstr(designName, 1) == "/")
	    {
	        designName=rightstr(designName, strlen(designName));
	    }

	    if(member(objType, designTypeList))
	    {
	        break;
	    }
	    else
	    {
	        if(member(objType, nonDesignTypeList))
		{
		    designName="";
		}
		else
		{
		    // The design name contains an embedded colon
		    designName=strcat(designName, ":");
		}
	    }
	}
	else if(nth(i, objectPathList) == "/" && i>0)
	{
	    objType=tolower(nth(i-1, objectPathList));
	    if(!member(objType, nonDesignTypeList) && 
	       !member(objType, designTypeList ))
	    {
	        // The name has an embedded slash in it.
		designName=strcat(designName, objType, "/");
	    }

	}
    }

    return(designName);
}

//////////////////////////////////////////////////////////////////////
// Search for the property "IFF_PIN_NAME" on the node and check to
// see if the node name could have been from a IFF import by converting
// the name in IFF_PIN_NAME to a valid ADS/S4 name and comparing with
// current node name. If same then return name contained in IFF_PIN_NAME
// else return original name.
//////////////////////////////////////////////////////////////////////
defun iff_check_for_iff_node_name(nodeHandle, nodeName)
{
  decl propHandle;
  decl propType;
  decl propName;
  decl propValue;
  decl wireHandle;
  decl dgHandle;
  decl pinHandle;
  decl tmpName;

  pinHandle = db_get_node_attribute(nodeHandle, NODE_PIN_HEAD);
  while( pinHandle != NULL )
  {
      wireHandle = db_get_pin_attribute(pinHandle, PIN_WIRE_PTR);
      pinHandle  = db_node_next_pin(pinHandle);

      if( wireHandle == NULL )
	  continue;

      dgHandle = db_get_wire_attribute(wireHandle, WIRE_OWNER);
      while( dgHandle != NULL )
      {
	  propHandle = db_get_dg_attribute(dgHandle, DG_PROPERTY);
	  while( propHandle != NULL )
	  {
	      propType = db_get_property_attribute(propHandle, PROPERTY_TYPE);
	      propName = db_get_property_attribute(propHandle, PROPERTY_NAME);
	      if( propName == IffBadPinNameProperty )
	      {
		  propValue = db_get_property_attribute(propHandle, propType);
		  tmpName = ifftolib_fix_name( propValue );
		  if( leftstr(tmpName, 1) == "_" )
		      tmpName = strcat("x",rightstr(tmpName,strlen(tmpName)-1));

		  if((( tmpName != NULL ) && ( nodeName == tmpName )) || 
		     ( nodeName == "" ))
		  {
		      nodeName = propValue;
		  }
		  
		  return( nodeName );
	      }
	      propHandle = db_next_property(propHandle);
	  }
	  dgHandle = db_next_dg(dgHandle);
      }
  }

  return(nodeName);

}

//////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////
defun oa_write_wire_labels(context, instH, fileH, logFile)
{
  decl connType = 28;
  decl labelSize = "OTHER FONT";
  decl labelOn = "T";
  decl busType = "N";
  decl labelParallel = "T";
  decl shadeRule = de_get_preference(PORT_COLOR_P);

  decl instPinIter = db_create_inst_pin_iter(instH);
  for (; db_inst_pin_iter_is_valid(instPinIter);
      instPinIter = db_inst_pin_iter_get_next(instPinIter))
  {
        decl wireLabelH = db_get_wire_label(instPinIter);
        if( wireLabelH )
        {
            decl pinNetName = db_get_shape_text_string(wireLabelH);
            //tmpList = member(pinNetName, IffReNamedNodeList);
            //if( tmpList != NULL )
            //    pinNetName = car(cdr(tmpList));
            //else if( pinNetName != "" )
            //    pinNetName = iff_check_for_iff_node_name(pinNodeH, pinNetName);

            //// Call a user defined pin renaming function
            //if(bound("iff_user_export_net_rename"))
            //{
            //    pinNetName = iff_user_export_net_rename(pinNetName);
            //}

            //if((pinNetName) && (leftstr(pinNetName, 4) != "_net"))
            //{
            decl pinLoc = db_get_inst_pin_snap_point(instPinIter);
            decl connX = db_get_x(pinLoc)/UserUnits*100;
            decl connY = db_get_y(pinLoc)/UserUnits*100;
            decl connRot = db_get_inst_pin_angle_normalized(instPinIter);
            if(labelOn == "T")
            {
                decl pinList = list("CON",shadeRule,connType,connRot,
                    labelSize,connX,connY,pinNetName,
                    connX,connY,connX,connY,labelOn,
                    labelParallel,busType);
                if(fileH)
                {
                    fputs(fileH, blanks_to_sepchar(pinList));
                    fputs(fileH, strcat("CONEND",SEP_CHAR));
                }
            }
            //}
        }
    }

}

//////////////////////////////////////////////////////////////////////////////
// Get each pin for a layout "leaf" component...
//////////////////////////////////////////////////////////////////////////////
defun oa_traverse_layout_leaf_pins(fileHandle, context, instIter, special, logFile)
{
    if( !de_is_layout_context(context) )
    //   || (( !de_is_artwork_macro_context(context) )
    {
        return;
    }

    decl instName = db_get_instance_name(instIter);
    decl instCellName = db_get_instance_cell_name(instIter);

    decl instPinIter = db_create_inst_pin_iter(instIter);
    for (; db_inst_pin_iter_is_valid(instPinIter);
        instPinIter = db_inst_pin_iter_get_next(instPinIter))
    {
        decl pin = db_inst_pin_iter_get_inst_pin(instPinIter);
        decl pinNum = db_get_inst_pin_term_number(instPinIter);
        decl loc = db_get_inst_pin_snap_point(pin);

        decl xPinLoc = db_get_x(loc)/UserUnits;
        decl yPinLoc = db_get_y(loc)/UserUnits;
        decl pinAngle = db_get_inst_pin_angle_normalized(pin)/1000.0;

        decl dbInstTerm = db_get_inst_pin_inst_term(instPinIter);
        decl pinName = db_get_inst_term_name(dbInstTerm);
        decl pinID = pinNum;
        if( !pinName )
        {
            if (pinID == -1)
                pinName="";
            else
                pinName = strcat("P", identify_value(pinID));
        }

        decl entryLayerId = db_get_entry_layerid(context);
        decl layerNum = db_get_layer_number(entryLayerId);
        decl defaultLayerName = db_find_layer_name_by_number(context, layerNum);

        // pinAttrList = build_property_list(); // TODO

        decl pinList = list("ARTPIN", defaultLayerName, strcat(instCellName, ":", instName), "PIN", 
            xPinLoc, yPinLoc, pinAngle, "POINTPIN", pinID, pinName, 
            "OFF", "1", xPinLoc, yPinLoc, "*", "nodeID");  // TODO_OA: nodeID

        if(fileHandle)
            iff_fmt_tokens(fileHandle, pinList);

    }

    return;
}


//////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////
defun iff_get_design_code(designName)
{
    decl designCode;
    decl context = de_find_design_context_from_name(designName);
    if( context == NULL )
        designCode = -1;
    else
        designCode = db_get_design_type(context);

    return(designCode);
}

//////////////////////////////////////////////////////////////////////////////
// oa_iff_read_instance() formats and adds instance data to the buffer for writing
// to the IFF file.
//////////////////////////////////////////////////////////////////////////////
defun oa_iff_read_instance(compName, inst, fileHandle, logFile, 
                           special, parentDesignName, refPath, 
                           flipped, instID_Lay)
{
    decl context = de_find_design_context_from_name(parentDesignName);
    decl instName = db_get_instance_name(inst);
    if( IffDebugMessageLevel > 3 )
    {
        print_value(list("iff_read_instance", 
            parentDesignName, compName, instName, parentPath));

        if(( fileHandle ) &&  ( IffAddCommentsToIff ))
        {
            decl str = strcat("# Reading instance ", compName);
            str = strcat(strcat(str, " PATH="), parentPath);
            fputs(fileHandle, blanks_to_sepchar(list(str)));
        }
    }

    decl policy = de_is_layout_context(context) ? NETLIST_FROM_LAYOUT : NETLIST_FROM_SCHEMATIC;
    decl hierarchyContext = db_create_hierarchy_context(context, policy);
    decl isPrimitive = db_is_primitive_instance_in_hierarchy(hierarchyContext, inst);
    if(!isPrimitive)
        iff_log_message(list("  Reading subckt reference",compName, instName));
    else 
        iff_log_message(list("  Reading element", compName, instName));

    decl parentPath = strcat(strcat(refPath, "."), instName);
    parentPath = strcat(strcat(parentPath, "|"),compName);
    decl instLineList = oa_iff_create_component(context, inst, special, logFile, parentPath, flipped, instID_Lay);
    if (instLineList)
    {
        decl paramList = oa_iff_get_param_list(compName, inst, context);
        if(paramList)
            instLineList = append(instLineList, paramList);

        iff_fmt_tokens(fileHandle, instLineList); 

        if ( de_is_schematic_context(context) && (IffStoreSchemAnnotPos == TRUE))
        {
            // The user wants the annotation position of components stored.
            // The "LABEL" command is used for this purpose.
            // Since each line of the annotation is it's own line in the IFF
            // file, instLabelList is a list of lists.  The inner-most list
            // contain the output for each line in the IFF file.
            decl instLabelList = oa_iff_get_inst_label(context, inst);
            while (instLabelList)
            {
                iff_fmt_tokens(fileHandle, car(instLabelList)); 
                instLabelList = cdr(instLabelList);
            }
        }
    }

    // For layout instances dump the pins here.....
    if (isPrimitive && de_is_layout_context(context))
        oa_traverse_layout_leaf_pins(fileHandle, context, inst, special, logFile);

    // see if there are any pins with named nets that need wire labels
    oa_write_wire_labels(context, inst, fileHandle, logFile);
}


defun iff_read_via(viaLibName, viaInstName, via, fileHandle, logFile, refPath, instID_Lay)
{
    decl viaDefName = db_get_via_def_name(via);
    iff_log_message(list("  Reading via reference", viaDefName, viaInstName));

    decl parentPath = strcat(strcat(refPath, "."), viaInstName);
    parentPath = strcat(strcat(parentPath, "|"), viaDefName);
    decl instLineList = iff_create_via_as_component(viaLibName, via, logFile, parentPath, instID_Lay);
    if (instLineList)
    {
        iff_fmt_tokens(fileHandle, instLineList); 
    }
}


//////////////////////////////////////////////////////////////////////////////
/// iff_get_inst_label() returns a list of the annotation on a given instance.
/// Each line of annotation on the instance is returned as a list (contained
/// in a list of all lines of annotation on the instance) that is designed for 
/// directly writing to the IFF file via iff_fmt_tokens() as a single list
/// (i.e. iterate through the outer list and pass the inner list to
/// iff_fmt_tokens()).
//////////////////////////////////////////////////////////////////////////////
defun oa_iff_get_inst_label(context, inst)
{
    if (!inst)
        return NULL;

    decl instLabelList = list();

    decl bbox = db_get_instance_bbox(inst, INST_SYMBOL_AND_ANNOT_BBOX);
    decl x1 = db_get_bbox_x1(bbox);
    decl y1 = db_get_bbox_y1(bbox);
    decl x2 = db_get_bbox_x2(bbox);
    decl y2 = db_get_bbox_y2(bbox);
    decl shapeIter = db_create_shape_iter(context);
    shapeIter = db_shape_iter_limit_region(shapeIter,x1,y1,x2,y2);
    shapeIter = db_shape_iter_include_annotation(shapeIter);
    for( ; db_shape_iter_is_valid(shapeIter); shapeIter = db_shape_iter_get_next(shapeIter))
    {
        decl extractPath = "";
        if(db_shape_is_annotation(shapeIter))
        {
            decl textString = db_get_shape_text_string(shapeIter);
            if (db_is_cell_name_display(shapeIter))
            {
                extractPath = "label";
            }
            else if (db_is_inst_name_display(shapeIter))
            {
                extractPath = "name";
            }
            else if (!db_is_cell_name_display(shapeIter) && !db_is_inst_name_display(shapeIter))
            {
                // Use the parameter name for the label name
                decl pos = index(textString, "=");
                if (pos != -1)
                {
                    extractPath = leftstr(textString, pos);
                    textString = rightstr(textString, 
                        strlen(textString) - pos - 1);
                }
            }

            if (extractPath == "")
                continue;

            decl textHeight = db_get_text_height(shapeIter) / UserUnits * 100;
            // textSize format: "<width>,<height>,<physical page units>"
            decl textSize = sprintf("0,%.2f,IN/100", textHeight);
            decl textRule = iff_text_rule(textHeight);
            decl textJust = "left";

            decl textLoc = db_get_text_origin(shapeIter);
            decl textLoc_x = db_get_x(textLoc) / UserUnits * 100;
            decl textLoc_y = db_get_y(textLoc) / UserUnits * 100;

            decl textLoc_ang = db_get_text_angle(shapeIter) / 1000.0;
            textLoc_ang = iff_normalize_angle(textLoc_ang, 0, 360);
            decl textRot = iff_text_rot(textLoc_ang);

            instLabelList = append(instLabelList,list(list("LABEL",
                extractPath, textRule, textSize, 0, textRot,
                textJust, extractPath, textLoc_x, textLoc_y, "DISPLAY",
                "USERPATH", textString)));

        } // if
    } // for

    return instLabelList;
}


defun iff_get_grid_preferences()
{
  decl gridDisplayOn, minorGridX, majorGridX;
  decl gridSnapOn, gridSnapX, gridList, schemUnits, dbResolution;

  decl winInst=api_get_current_window();
  decl currentContext = de_get_current_design_context();

  gridDisplayOn = iff_get_preference(GRID_DISPLAY_P);
  minorGridX =    iff_get_preference(GRID_DISPLAY_X_P);
  majorGridX =    iff_get_preference(MAJOR_GRID_DISPLAY_X_P);
  gridSnapOn =    iff_get_preference(GRID_SNAP_P);
  gridSnapX =     iff_get_preference(GRID_SNAP_X_P);

  if(de_is_schematic_context(currentContext))
    schemUnits = iff_get_preference(SCHEM_UNITS_P);
  elseif(de_is_layout_context(currentContext))
    schemUnits = iff_get_preference(LAYOUT_UNITS_P);
  else
      schemUnits = 1; // TODO bad - should never get here

  if(gridDisplayOn)
    gridDisplayOn = "ON";
  else gridDisplayOn = "OFF";

  if(schemUnits == 1)
    schemUnits = "mil";
  else if(schemUnits == 2)
    schemUnits = "in";
  else if(schemUnits == 3)
    schemUnits = "um";      // micron
  else if(schemUnits == 4)
    schemUnits = "mm";
  else if(schemUnits == 5)
    schemUnits = "cm";
  else if(schemUnits == 6)
    schemUnits = "m";
  else if(schemUnits == 7)
    schemUnits = "ft";
  else
    {
      print_value("Warning: Unknown export units, using \"mils\".");
      schemUnits = "mil";
    }

  // for now assume inches, convert to in/100
  //schemUnits = strcat(strcat(schemUnits,"/"), UserUnits);
  if(de_is_schematic_context(winInst))
    {
    schemUnits = "in/100";
    majorGridX = majorGridX * minorGridX * gridSnapX * 100;
    minorGridX = minorGridX * gridSnapX * 100;
    gridSnapX = gridSnapX * 100;
    gridList = list(majorGridX, minorGridX, gridSnapX, 
		  gridDisplayOn, schemUnits);
    }
  else // traversing layout
  {
    majorGridX = majorGridX * minorGridX * gridSnapX;
    minorGridX = minorGridX * gridSnapX;
    gridSnapX = gridSnapX;
    layoutUnits = schemUnits;
    dbResolution = UserUnits;  // 10000
    gridList = list(majorGridX, minorGridX, gridSnapX, 
		  gridDisplayOn, layoutUnits, dbResolution);
    }

  return(gridList);

  // grid/pin/vertex: iff_get_preference(GRID_SNAP_MODE_P);
  // dot or line: iff_get_preference(GRID_DISPLAY_MODE_P);
}

defun get_port_value(instHandleF)
{
    decl value, name, instParam;

    instParam=db_get_instance_attribute(instHandleF, INST_PARAM_HEAD);

    // Get the port number.  Port number is the first parameter for the port.

    if(instParam)
    {
        value=val(db_get_parm_attribute(instParam, PARM_VALUE_SVALUE));            
    }

    /*  
    name = db_get_instance_attribute(instHandleF, INST_NAME);
    value = port_stack_find(name);
    */

    return(value);
}

//////////////////////////////////////////////////////////////////////
// to make the pin/port/wire relationship correct for iff, 
// if the node has a port on it, the node name has to match 
// the node name on the attached port
// given: pinList of all pin names with logical pinNums  
//        ex: [1, "p1", 3, "p3", 2, "pin2"]  
//////////////////////////////////////////////////////////////////////
defun get_node_name_from_port(pinList, nodeHandle, logFile)
{
    decl nodeName=NULL, pinHandle, instHandleG, special, portNum;

    // get the first pin on the node 
    pinHandle = db_get_node_attribute(nodeHandle, NODE_PIN_HEAD);
    while(pinHandle)
    {
	// get the inst that the pin belongs to
        instHandleG = db_get_pin_attribute(pinHandle, PIN_INST_PTR);

	// check the instSpecial flag to see if it is a port
        special = db_get_instance_attribute(instHandleG, INST_SPECIAL);
        if(iff_is_port(special))
	{
            //get the port= value
	    portNum = get_port_value(instHandleG);

            //value is the logical pin number
	    //find the pin # in the pin list and return the pin name
            nodeName = get_pin_name_from_symbol(pinList, portNum);
	    if(nodeName && nodeName != "")
	        return(nodeName);
	}

        // get the next pin on the node 
        pinHandle = db_node_next_pin(pinHandle);
    }

    return(nodeName);
}

/*-----------------------------------------------------------------
  Function: iff_export_get_connector_info
  Purpose:  Generate connector wire label token information 
  -----------------------------------------------------------------*/
defun oa_iff_export_get_connector_info(shape, wireLabelH)
{
    decl connInfo = NULL;
    decl connX, connY;
    decl nodeName;
    decl labelSize = "ANSI100";
    decl labelOn = "T";
    decl labelParallel = "T";
    decl busType = "N";
    decl pointList, coordH, segH;
    decl X1, X2, Y1, Y2;

    if (!shape)
        return (NULL);

    // shadeRule = db_get_text_attribute (textH, TEXT_WIRE_LABEL_COLOR);
    decl shadeRule = 37;

    decl polygon = db_get_shape_primitive_polygon(shape);
    if(polygon)
    {
        decl numPoints = db_get_primitive_polygon_num_points(polygon);
        coordH = db_get_primitive_polygon_point(polygon, 0);
        X1  = db_get_x(coordH);
        Y1  = db_get_y(coordH);

        coordH = db_get_primitive_polygon_point(polygon, 1);
        X2  = db_get_x(coordH);
        Y2  = db_get_y(coordH);
    }// if (polygon)


	/* Wire label must be moved so it will attach to the wire segment. */
    /* This will force the labels "out of position", because there are offsets, and the user 
       can move the labels. */
    if((X1 != NULL) && (X2 != NULL))
    {
        connX = (X1-.5*(X1-X2))/UserUnits*100;
    }
    else if((X1 != NULL) && (X2 != NULL))
    {
        connX = X1/UserUnits*100;
    }
    else if((X2 != NULL) && (X1 == NULL))
    {
        connX = X2/UserUnits*100;
    }

    if((Y1 != NULL) && (Y2 != NULL))
    {
        connY = (Y1-.5*(Y1-Y2))/UserUnits*100;
    }
    else if((Y1 != NULL) && (Y2 == NULL) )
    {
        connY = Y1/UserUnits*100;
    }
    else if((Y2 != NULL) && (Y1 == NULL))
    {
        connY = Y2/UserUnits*100;
    }

    if((connX != NULL) && (connY != NULL))
    {
        nodeName = db_get_shape_text_string(wireLabelH);

        // Call a user defined pin renaming function
        if (bound ("iff_user_export_net_rename"))
        {
            nodeName = iff_user_export_net_rename (nodeName);
        }

        /* Store wire label as connector type 28 */
        if(labelOn == "T")
        {
            connInfo = list ("CON",
                shadeRule,
                28,            /* wire label connector type */
                0,             /* rotation */
                labelSize,
                connX,
                connY,
                nodeName,
                connX,         /* labelX */
                connY,         /* labelY */
                connX,
                connY,
                labelOn,
                labelParallel,
                busType,
                NULL,
                NULL);         /* paramList */
        }
        else
        {
            connInfo=NULL;
        }

    }

    return (connInfo);
}

/*-----------------------------------------------------------------
  Function: iff_export_write_wire_label_info
  Purpose:  Write connector information based on wire labels
  -----------------------------------------------------------------*/
defun oa_iff_export_write_wire_label_info(fileHandle, shape)
{
    decl wireLabelH = db_get_wire_label(shape);
    if (!wireLabelH)
        return (FALSE);

    decl connInfo;
    if(db_shape_is_text_or_annotation(wireLabelH))
    {
        connInfo = oa_iff_export_get_connector_info(shape, wireLabelH);
        if (!connInfo)
            return (FALSE);
    }

    fputs (fileHandle, blanks_to_sepchar (connInfo));
    fputs (fileHandle, strcat ("CONEND", SEP_CHAR));

    return (TRUE);

}

/*-----------------------------------------------------------------
  Function: iff_export_write_wire_labels
  Purpose:  Generate connector information by iterating on wires.
  -----------------------------------------------------------------*/
defun oa_iff_export_write_wire_labels(context, fileHandle, logFile)
{
    decl shapeIter = db_create_shape_iter(context);
    for( ; db_shape_iter_is_valid(shapeIter); shapeIter = db_shape_iter_get_next(shapeIter))
    {
        if(db_shape_is_wire(shapeIter))
        {
            oa_iff_export_write_wire_label_info(fileHandle, shapeIter);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////////////
// Given a pin handle, wire label associated with it.
//
defun iffGetPinWireLabel( pinH )
{
decl netName, nodeH, wireLabelH, textH;
decl wire1H, nodeNum;

    if ( identify_value( pinH) == "<Pin>" ) {

    netName    = NULL;
    nodeH      = db_get_pin_attribute( pinH, PIN_NODE_PTR);
    wireLabelH = db_get_pin_attribute( pinH, PIN_WIRE_LABEL_PTR);

    if ( wireLabelH ) {
      textH = db_get_dg_attribute( wireLabelH, DG_DATA);
      if( textH ) {
        netName = db_get_text_attribute( textH, TEXT_STRING);
        // this break is a bug in the original code...break;
      }
    } else {
/*
      // This code is flawed because we do not want to get the 
      // pin name by looking at wires off other pins of this instance!

      while( pinH ) {
        wire1H = db_get_pin_attribute( pinH, PIN_WIRE_PTR);
        if ( wire1H ) {
          wireLabelH = db_get_wire_attribute( wire1H, WIRE_LABEL_PTR);
          if ( wireLabelH ) {
            textH = db_get_dg_attribute( wireLabelH, DG_DATA);
            if ( textH ) {
              netName = db_get_text_attribute( textH, TEXT_STRING);
              break;
            }
          }
        }
        pinH = db_instance_next_pin( pinH);
      }
*/
    }

    if ( ! netName ) {
      if ( nodeH ) {
        netName = db_get_node_attribute( nodeH, NODE_NAME);
        if ( ! netName || netName == "" ) {
          nodeNum = db_get_node_number( nodeH);
          if ( nodeNum != 0 ) {
            netName = strcat( "_net", identify_value( nodeNum));
          } else {
            netName = "GROUND";
          }
        }
      } else {
        netName = NULL;
      }
    }
  }
  return ( netName);
}

////////////////////////////////////////////////////////////////////////////////////
// Given a tee handle, return the first unselected wire associated with it.
//
defun iffGetUnselectedWireOffOfTee ( teeH )
{
decl aWire = NULL;
decl selected;

  aWire = db_get_tee_attribute( teeH, 1); // TEE_WIRE_1
  if ( aWire ) {
    selected = 
         db_get_dg_attribute( db_get_wire_attribute( aWire, WIRE_OWNER), DG_SELECT);
    if ( selected == 0 )
      return aWire;
  }

  aWire = db_get_tee_attribute( teeH, 2); // TEE_WIRE_2
  if ( aWire ) {
    selected = 
         db_get_dg_attribute( db_get_wire_attribute( aWire, WIRE_OWNER), DG_SELECT);
    if ( selected == 0 )
      return aWire;
  }

  aWire = db_get_tee_attribute( teeH, 3); // TEE_WIRE_3
  if ( aWire ) {
    selected = 
         db_get_dg_attribute( db_get_wire_attribute( aWire, WIRE_OWNER), DG_SELECT);
    if ( selected == 0 )
      return aWire;
  }

  return NULL;
}

////////////////////////////////////////////////////////////////////////////////////
// Given a wire handle, find the node name associated with it.
//
defun iffFindNetNameOfWire ( wireH )
{
decl wireType1, wireType2, pinH, netName, nodeH;
decl wire1H;

  // Assumption 1: If you find a pin, you will have the name...

  netName = pinH = NULL;

  wireType1 = db_get_wire_attribute( wireH, WIRE_TYPE_1);
  wireType2 = db_get_wire_attribute( wireH, WIRE_TYPE_2);

  if ( wireType1 == PIN_CONN ) {
    pinH = db_get_wire_attribute( wireH, WIRE_CONN_1);
  } else if ( wireType2 == PIN_CONN ) {
    pinH = db_get_wire_attribute( wireH, WIRE_CONN_2);
  }

  if ( pinH ) {
    netName = iffGetPinWireLabel( pinH);

//prs("\n");
//prs("\n In iffFindNetNameOfWire PIN stuff...\n");
//pr( db_get_wire_attribute( wireH, WIRE_TYPE_1));
//pr( db_get_wire_attribute( wireH, WIRE_TYPE_2));

    if ( netName )
      return netName;
  }

  /**********************
   *  Interrogate wires off the tee to see if there is a pin...
   */
  if ( wireType1 == TEE_CONN || wireType2 == TEE_CONN ) {
  decl nextWire, teeH, tmpCnt = 0;

    if ( wireType1 == TEE_CONN )
      teeH = db_get_wire_attribute( wireH, WIRE_CONN_1);
    else
      teeH = db_get_wire_attribute( wireH, WIRE_CONN_2);

//prs("\n In iffFindNetNameOfWire Tee stuff...\n");

    /* Mark the current wire as selected */
    db_set_dg_attribute(db_get_wire_attribute(wireH, WIRE_OWNER), DG_SELECT, TRUE);

    nextWire = iffGetUnselectedWireOffOfTee( teeH);

    while ( nextWire && tmpCnt < 5000 ) {
      netName = iffFindNetNameOfWire( nextWire);
      if ( netName )
        return netName;
      nextWire = iffGetUnselectedWireOffOfTee( teeH);
      tmpCnt++;
    }
  }
  return ( netName);

} /* defun iffFindNetNameOfWire ( wireH )                                         */

/*
 * Make a list of nets that are attached to ports.  This list will be consulted by 
 * the iffFindNetNameOfWire, so that port net names can be replaced by the port 
 * instance name.
 *
 */
defun oa_iff_build_port_net_list(context)
{
    decl portLabelList;
    decl pinIter = db_create_pin_iter(context);
    for (; db_pin_iter_is_valid(pinIter);
        pinIter = db_pin_iter_get_next(pinIter))
    {
        decl portName = db_get_pin_term_name(pinIter);
        decl term = db_get_pin_term(pinIter);
        decl net = db_get_term_net(term);
        decl portNet = db_get_net_name(net);
        portLabelList=append(portLabelList, list(portNet, list(portName, portNet)));
    }

    return(portLabelList);
}

////////////////////////////////////////////////////////////////////////////////////
defun oa_iff_build_wire_list(parentDesignName, context, fileHandle, pinList, logFile)
{
    decl firstPoint;
    decl wireList;
    decl currX, currY, prevX, prevY;
    decl needWireStatement;
    decl wireColor=0;
    decl wireProp, wirePropType, propString;

    decl netNum=1;
    decl propInfo;

    // Get a list of the nets that are attached to ports
    decl portLabelList = oa_iff_build_port_net_list(context);
    decl tmpList;
    // Note: Each drawing group will get its own WIRE declaration.  
    decl wireInfo;
    decl shapeIter = db_create_shape_iter(context);
    for( ; db_shape_iter_is_valid(shapeIter); shapeIter = db_shape_iter_get_next(shapeIter))
    {
        decl shape = db_get_shape_type_description(shapeIter);
        if(db_shape_is_wire(shapeIter))
        {
            propInfo = NULL;
            decl propIter = db_create_prop_iter(shapeIter);
            for ( ; db_prop_iter_is_valid(propIter); propIter = db_prop_iter_get_next(propIter))
            {
                propString = db_prop_iter_get_name(propIter);
                wirePropType = db_prop_iter_get_type(propIter);
                if ( wirePropType ) {
                    switch ( wirePropType ) {
              case 0:
                  propString = strcat( propString, "=", db_get_property_as_string(propIter) );
                  break;
              case 1:
                  propString = strcat( propString, "=", identify_value( db_prop_iter_get_value()) );
                  break;
              case 2:
                  propString = strcat( propString, "=", identify_value( db_prop_iter_get_value()) );
                  break;
              case 3:
                  propString = strcat( propString, "=", db_get_property_as_string(propIter) );
                  break;
                    }

                    if ( ! member( propString, propInfo) ) {
                        // Do not duplicate property entries.
                        propInfo=append(propInfo, list(propString));
                    }

                }
            }

            needWireStatement = TRUE; // always set because we are already going through wire shape

            de_deselect_all(); // do this to "unmark" the DG_SELECT flag

            // netName = iffFindNetNameOfWire( wireH);  //DSN
            decl netName = NULL;
            decl net = db_get_shape_net(shapeIter);
            if (net)
                netName = db_get_net_name(net);

            if ( !netName || netName == "" )
            {
                netName = strcat( "_net", identify_value( netNum));
                netNum++;
             }

                // Included for Nortel Concept/Allegro problem:
                // Replace node names that are attached to ports with the port name. 
                if(IffUsePortNameAsNet && (tmpList=nth(1, member(netName, portLabelList))))
                {
                    // The current net attaches to a hierarchical port instance.  Use the name
                    // of the port as the wire name, instead of the ADS specified name.
                    netName=car(tmpList);
                }

                prevX      = NULL;
                prevY      = NULL;
                firstPoint = TRUE;

                decl polygon = db_get_shape_primitive_polygon(shapeIter);
                if(polygon)
                {
                    decl numPoints = db_get_primitive_polygon_num_points(polygon);
                    decl pntList = NULL;
                    decl i;
                    for (i = 0;i<numPoints;++i)
                    {
                        decl coordH = db_get_primitive_polygon_point(polygon, i);
                        currX  = db_get_x( coordH);
                        currX  = currX / UserUnits * 100.0;
                        currY  = db_get_y( coordH);
                        currY  = currY / UserUnits * 100.0;

                        if ( firstPoint )
                        {
                            firstPoint = FALSE;

                        }
                        else if ( prevX != currX || prevY != currY )
                        {
                            if( (prevX != NULL) && (prevY != NULL) )
                            {
                                decl segInfo = list( "WIRESEG","WIRES", prevX, prevY, currX, currY);
                                if ( ! member( segInfo, wireList) ) {
                                    if ( needWireStatement ) {
                                        wireInfo = list( "WIRE",wireColor,"SQUARE,ON,BUSON", netName);
                                        wireInfo = append( wireInfo, propInfo);
                                        needWireStatement = FALSE;
                                        wireList = append( wireList, list( wireInfo));
                                    }
                                    wireList = append( wireList, list( segInfo));
                                }
                            }
                        }
                        prevX = currX;
                        prevY = currY;
                    }
                }// if (polygon)
        }  // if db_shape_is_wire
    } // for

    return( wireList);
}

// Context is used to iterate over the shapes
// parentDesignName is used to get the layers
// instHierTransform is used to get the correct coordinates of the instance subdesign
defun oa_iff_write_geom(context, fileHandle, logFile, refPath, instHierTransform)
{
    decl shapeIter = db_create_shape_iter(context);
    shapeIter = db_shape_iter_include_invisible_layers(shapeIter);
    shapeIter = db_shape_iter_include_protected_layers(shapeIter);
    for( ; db_shape_iter_is_valid(shapeIter); shapeIter = db_shape_iter_get_next(shapeIter))
    {
        if (db_shape_is_rectangle(shapeIter))
        {
            oa_traverse_rectangle_dg(fileHandle, context, shapeIter, instHierTransform);
        }
        else if (db_shape_is_ellipse(shapeIter) || db_shape_is_circle(shapeIter))
        {
            oa_traverse_ellipse_dg(fileHandle, context, shapeIter, instHierTransform);
        }
        else if(db_shape_is_wire_or_trace(shapeIter))
        {
            oa_traverse_wire_trace_dg(fileHandle, context, shapeIter, refPath, instHierTransform);
        }
        else if(db_shape_is_text_or_text_display(shapeIter))
        {
            oa_traverse_text_dg(fileHandle, context, shapeIter, instHierTransform);
        }
        else if(db_shape_is_polygon(shapeIter))
        {
            oa_traverse_polygon_dg(fileHandle, context, shapeIter, instHierTransform);
        }
        else if(db_shape_is_polyline(shapeIter))
        {
            oa_traverse_polyline_dg(fileHandle, context, shapeIter, instHierTransform);
        }
        else if(db_shape_is_path(shapeIter))
        {
            oa_traverse_path_dg(fileHandle, context, shapeIter, refPath, instHierTransform);
        }
        else if(db_shape_is_const_line(shapeIter))
        {
            oa_traverse_const_dg(fileHandle, context, shapeIter, instHierTransform);
        }
        else if(db_shape_is_arc(shapeIter))
        {
            oa_traverse_arc_dg(fileHandle, context, shapeIter, instHierTransform);
        }
        else if (db_object_is_part_of_composite_object(shapeIter))
        {
            oa_traverse_polygon_dg(fileHandle, context, shapeIter, instHierTransform);
        }
        else
        {
            decl shapeStrg = db_get_shape_type_description(shapeIter);
            print_value(list("Unknown shape ", shapeStrg));
        }

    }

  if( IffDebugMessageLevel > 5 )
    print_value("End:   iff_write_geom");

  return;
}

/////////////////////////////////////////////////////////////////////////////
//given: pinList of all pin names with logical pinNums  ex: [1, "p1", 3, "p3", 2, "pin2"]  
/////////////////////////////////////////////////////////////////////////////
defun oa_iff_build_SchemInst_list(parentDesignName, context, fileHandle, pinList, logFile, refPath)
{
    decl instID = 0;
    decl hierarchyContext = db_create_hierarchy_context(context, DIRECT_DESCENDANTS);
    decl instIter = db_create_inst_iter(hierarchyContext);
    for( ; db_inst_iter_is_valid(instIter); instIter = db_inst_iter_get_next(instIter) )
    {
         decl instP = db_inst_iter_get_instance( instIter ); 
         decl instCellName = db_get_instance_cell_name(instIter);
         // Get instances sub-design name if its a non-primitive.
         decl subHierContext;
         decl subDesignContext;
         if (!db_is_primitive_instance_in_hierarchy(hierarchyContext, instP))
         {
             subHierContext = db_get_hierarchy_context_for_instance(hierarchyContext, instP);
             if( subHierContext )
             {
                 subDesignContext = db_get_design_context_from_hierarchy(subHierContext);
                 decl instName = db_get_instance_name(instIter);
                 instName = strcat(strcat(refPath, "."), instName);
                 decl special = db_get_instance_special(instIter);
                 if(db_get_instance_placement_transform(instIter) == NULL)
                 {
                     iff_log_message(list(strcat("ERROR: Unable to export instance for ", 
                         instCellName, ", instance skipped.")));
                 }
                 //else if(iff_is_port(special))// && (designName == IffConnName))
                 //{
                 //    // Only export the standard ADS port as a connector.
                 //    decl paramList;
                 //    paramList = iff_get_param_list(iff_get_design_code(parentDesignName),
                 //        designName, instHandleH, logFile);

                 //    write_connector(fileHandle, instIter, TRUE, paramList, pinList, logFile, repHandle);
                 //}
                 else if(iff_is_ground(special))// && (designName == IffGroundName))
                 {
                     // Only export the standard ADS ground as a connector.
                     oa_write_connector(fileHandle, instIter, FALSE, NULL, NULL, logFile, subDesignContext);
                 }
                 else if(instCellName) //else if(designPath)
                 {
                     ++instID;
                     decl instFlipped = oa_iff_instance_flipped(instIter);
                     oa_iff_read_instance(instCellName, instIter, fileHandle, logFile,
                         special, parentDesignName, refPath, 
                         instFlipped, instID);
                 }
             }
         }
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// For ADS DSN, the pin iterator iterates over the port instances in schematic or layout design contexts,
// and will iterate over the pins in a symbol or artwork macro design context.
// But ports in OA are handled differently.
/////////////////////////////////////////////////////////////////////////////
defun oa_iff_export_ports(context, fileHandle, logFile)
{
    decl pinIter = db_create_pin_iter(context);
    for (; db_pin_iter_is_valid(pinIter);
        pinIter = db_pin_iter_get_next(pinIter))
    {
        decl termName = db_get_pin_term_name(pinIter);
        decl termNumber = db_get_pin_term_number(pinIter);

        decl angle = db_get_pin_angle_normalized(pinIter);

        decl snapCoordH = db_get_pin_snap_point(pinIter);
        decl snapX = db_get_x(snapCoordH)/UserUnits;
        decl snapY = db_get_y(snapCoordH)/UserUnits;


        decl propIter = db_create_prop_iter(pinIter);
        decl userAttrList = build_property_list(propIter);

        decl portList;
        if(de_is_layout_context(context))
        {
            angle = angle/1000.0;

            decl layerId = db_get_pin_snap_layerid(pinIter);
            decl layerNum = db_get_layer_number(layerId);
            decl layerName = db_find_layer_name_by_number(context, layerNum);

            portList = list("ARTPIN",layerName,"", "CONNECTOR", 
                snapX, snapY, angle, "POINTPIN", termNumber, 
                termName, 1, snapX, snapY, "*", ""/*nodeNum*/, ""/*paramList*/);
        }
        else
        {
            //userAttrList=setupCDSiotype(userAttrList, context, portNum);
            decl ShadeRule = de_get_preference(PORT_COLOR_P);
            decl connType = 26;
            decl connRot = oa_iff_conn_rot(angle);
            decl pinName = termName;

            decl labelSize = "OTHER FONT";
            decl labelOn = "F";
            decl busType = "N";
            decl labelParallel = "T";
            decl paramList = strcat(IffConnNum, "=", termNumber);

            snapX = snapX * 100;
            snapY = snapY * 100;
            decl labelX = snapX;
            decl labelY = snapY;

            portList = list("CON",ShadeRule,connType,connRot,
                labelSize,snapX,snapY,pinName,
                labelX,labelY,snapX,snapY,labelOn,
                labelParallel,busType,
                strcat(IffConnId,"=",termName), paramList);
        }

        if(userAttrList)
            portList = append(portList, userAttrList);

        if(fileHandle)
        {
            fputs(fileHandle, blanks_to_sepchar(portList));
            if(!de_is_layout_context(context))
                fputs(fileHandle, strcat("CONEND",SEP_CHAR));
        }
    }
}

defun iff_object_flipped(transform)
{
  decl mX = db_get_transform_mirror_x(transform);
  decl mY = db_get_transform_mirror_y(transform);

  decl flipped;
  if (mX && mY)
    flipped = FALSE;
  else if (mX || mY)
    flipped = TRUE;
  else
    flipped = FALSE;

  return flipped;
}

defun oa_iff_instance_flipped(inst)
{
  decl trans = db_get_instance_placement_transform(inst);
  return iff_object_flipped(trans);
}

/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
// Traverse the design instances - make sure not to output
// "special" (e.g. gnd), "deactivated", and "no plot" instances

// TODO: Refactor this!
defun oa_iff_build_layoutInst_list(context, fileHandle, pinList, logFile, refPath, flipped)
{
    decl parentDesignName = db_get_design_name(context);
    decl hierarchyContext = db_create_hierarchy_context(context, NETLIST_FROM_LAYOUT);
    decl instIter = db_create_inst_iter(hierarchyContext);
    decl instID = 0;
    for( ; db_inst_iter_is_valid(instIter); instIter = db_inst_iter_get_next(instIter) )
    {
        decl instP = db_inst_iter_get_instance( instIter ); 
        decl instCellName = db_get_instance_cell_name(instIter);
        decl instName = db_get_instance_name(instIter);
        instName = strcat(strcat(refPath, "."), instName);

        decl instFlipped = oa_iff_instance_flipped(instIter);
        decl special = db_get_instance_special(instIter);

        // Get instances sub-design name if its a non-primitive.
        decl subHierContext;
        if(iff_is_ground(special))
        {
            hierarchyContext = db_create_hierarchy_context(context, DIRECT_DESCENDANTS);
            subHierContext = db_get_hierarchy_context_for_instance(hierarchyContext, instP);
            if( subHierContext )
            {
                decl subDesignContext = db_get_design_context_from_hierarchy(subHierContext);
                oa_write_connector(fileHandle, instIter, FALSE, NULL, NULL, logFile, subDesignContext);
            }
        }
        else if (db_is_primitive_instance_in_hierarchy(hierarchyContext, instP))
        {
            ++instID;
            oa_iff_read_instance(instCellName, instIter, fileHandle, logFile,
                special, parentDesignName, refPath, 
                instFlipped, instID);
            iff_write_output_lines(fileHandle, logFile);

            // Read the instance' shapes
            // Note - instance name and instance's cell name are not getting written!
            decl designName = db_get_instance_component_name(instIter);
            decl isWorkSpaceCell = oa_iff_is_workspace_cell(designName);
            decl instHierTransform = NULL;
            if(!isWorkSpaceCell)
                instHierTransform = db_get_instance_subcontext_transform(instP, 0, 0);

            hierarchyContext = db_create_hierarchy_context(context, DIRECT_DESCENDANTS);
            subHierContext = db_get_hierarchy_context_for_instance(hierarchyContext, instP);
            if( subHierContext )
            {
                decl subDesignContext = db_get_design_context_from_hierarchy(subHierContext);
                oa_iff_write_geom(subDesignContext, fileHandle, logFile, instCellName, instHierTransform);
            }

            if(fileHandle)
            {
                fputs(fileHandle, blanks_to_sepchar(list("ARTCOMPEND")));
            }
        }
        else
        {
            subHierContext = db_get_hierarchy_context_for_instance(hierarchyContext, instP);
            if( subHierContext )
            {
                decl subDesignContext = db_get_design_context_from_hierarchy(subHierContext);
                if(db_get_instance_placement_transform(instIter) == NULL)
                {
                    iff_log_message(list(strcat("ERROR: Unable to export instance for ", 
                        instCellName, ", instance skipped.")));
                }
                /*else if(iff_is_port(special))
                {
                    decl paramList;
                    paramList = iff_get_param_list(iff_get_design_code(parentDesignName), 
                        designPath, instHandle, logFile);

                    write_connector(fileHandle, instHandle, TRUE, paramList, pinList, logFile, repHandle);
                }*/
                else if(iff_is_ground(special))
                {
                    oa_write_connector(fileHandle, instIter, FALSE, NULL, NULL, logFile, subDesignContext);
                }
                else if(instCellName) //else if(designPath)
                {
                    ++instID;
                    decl instFlipped = oa_iff_instance_flipped(instIter);
                    oa_iff_read_instance(instCellName, instIter, fileHandle, logFile,
                        special, parentDesignName, refPath, 
                        instFlipped, instID);
                    iff_write_output_lines(fileHandle, logFile);

                    // Read the instance' shapes
                    // Note - instance name and instance's cell name are not getting written!
                    decl designName = db_get_instance_component_name(instIter);
                    decl isWorkSpaceCell = oa_iff_is_workspace_cell(designName);
                    decl instHierTransform = NULL;
                    if (!isWorkSpaceCell || InstIsLeaf)
                        instHierTransform = db_get_instance_subcontext_transform(instP, 0, 0);

                    oa_iff_write_geom(subDesignContext, fileHandle, logFile, instCellName, instHierTransform);

                    // Write hieararchical instance
                    designName = db_get_instance_design_name(instIter);
                    decl shortName = iff_get_short_design_name(subDesignContext);
                    decl newParent = strcat(strcat(instName, "|"),shortName);

                    oa_iff_read_design(designName, designName, fileHandle,
                        NULL, logFile,TRUE,newParent, FALSE);

                    if(fileHandle)
                    {
                        fputs(fileHandle, blanks_to_sepchar(list("ARTCOMPEND")));
                    }
                }
            }
        }
    }
}

defun iff_export_oa_vias(context, fileHandle, logFile, refPath)
{
    if (!de_is_layout_context(context))
        return NULL;

    decl hierarchyContext = db_create_hierarchy_context(context, NETLIST_FROM_LAYOUT);
    decl viaIter = db_create_via_iter(hierarchyContext);
    decl instID = 0;
    decl viaCount = 0;
    for ( ; db_via_iter_is_valid(viaIter); viaIter = db_via_iter_get_next(viaIter) )
    {
        decl via = db_via_iter_get_via(viaIter);
        hierarchyContext = db_create_hierarchy_context(context, DIRECT_DESCENDANTS);
        decl subHierContext = db_get_hierarchy_context_for_via(hierarchyContext, via);
        if (subHierContext)
        {
            decl subDesignContext = db_get_design_context_from_hierarchy(subHierContext);

            decl viaLibName = db_get_library_name(subDesignContext);
            decl viaDefName = db_get_via_def_name(via);
            ++viaCount;
            decl viaInstName = strcat(viaDefName, viaCount);
            viaInstName = strcat(strcat(refPath, "."), viaInstName);

            ++instID;
            iff_read_via(viaLibName, viaInstName, via, fileHandle, logFile,
                refPath, instID);
            iff_write_output_lines(fileHandle, logFile);

            oa_iff_write_geom(subDesignContext, fileHandle, logFile, viaDefName, NULL);
        }

        if(fileHandle)
        {
            fputs(fileHandle, blanks_to_sepchar(list("ARTCOMPEND")));
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
// check for HPEESOF_CIRCUITPAGE_PROP_NAME_x=name and 
//           HPEESOF_CIRCUITPAGE_PROP_VALUE_x=value pairs
// and convert to name=value
/////////////////////////////////////////////////////////////////////////////
defun build_circuitpage_property_list(propHandle)
{
  decl propType, propName, propValue, propList, 
       pos, iffNameList, iffValueList, newProp, propIndex;

  propList = NULL;
  iffNameList = NULL;
  iffValueList = NULL;

  while(propHandle)
  {
    propName = db_get_property_attribute(propHandle,PROPERTY_NAME); 
    if(leftstr(propName,30) == "HPEESOF_CIRCUITPAGE_PROP_NAME_")
    {
      propValue = db_get_property_attribute(propHandle, 
			db_get_property_attribute(propHandle,PROPERTY_TYPE)); 
      propName = strcat(strcat(propName,"="),propValue);
      iffNameList = append(iffNameList, list(propName));
    }
    else if(leftstr(propName,31) == "HPEESOF_CIRCUITPAGE_PROP_VALUE_")
    {
      propValue = db_get_property_attribute(propHandle, 
			db_get_property_attribute(propHandle,PROPERTY_TYPE)); 
      propName = strcat(strcat(propName,"="),propValue);
      iffValueList = append(iffValueList, list(propName));
    }
    propHandle = db_next_property(propHandle);
  }

  // see if there were any invalid names to change back to input format
  while(iffNameList)
  {
    propName = car(iffNameList);       //HPEESOF_CIRCUITPAGE_PROP_NAME_x=name
    pos = index(propName,"=");
    newProp = rightstr(propName,strlen(propName)-pos-1);
    newProp = strcat(newProp,"=");
    propName = leftstr(propName,pos);  //HPEESOF_CIRCUITPAGE_PROP_NAME_x

    // parse off the 'x' and look for HPEESOF_CIRCUITPAGE_PROP_VALUE_x
    propIndex = rightstr(propName,strlen(propName)-30);
    propValue = find_in_list(strcat("HPEESOF_CIRCUITPAGE_PROP_VALUE_",propIndex),31+strlen(propIndex),iffValueList);

    // now we should have HPEESOF_PROP_VALUE_x=value, finish newProp
    if(propValue)
    {
      pos = index(propValue,"=");
      propValue = rightstr(propValue,strlen(propValue)-pos-1);
      newProp = strcat(newProp,propValue);

      propList = append(propList,list(newProp));
    }
    iffNameList = cdr(iffNameList);
  }

  return(propList);
}

//////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////
defun iff_build_design_property_list(propHandle)
{
  decl propName;
  decl propType;
  decl propValue;
  decl propList;

  propList = NULL;

  while( propHandle != NULL )
    {
      propName = db_get_property_attribute(propHandle, PROPERTY_NAME);
      if( propName != NULL )
	{
	  propType = db_get_property_attribute(propHandle, PROPERTY_TYPE);
	  propValue = db_get_property_attribute(propHandle, propType);
	  
	  propName = strcat(IffToMgcSystemName,
			    "_DESIGN_PROPERTY_", propName, "=");

	  if(( propValue != NULL ) && ( propValue != "" ))
	    propName = strcat(propName, propValue);

	  propList = append(propList, list(propName));
	}
      propHandle = db_next_property(propHandle);
    }

  return( propList );
}

//////////////////////////////////////////////////////////////////////
//
// Function to write a CIRCUITPAGE statement for schematic design
//////////////////////////////////////////////////////////////////////
defun oa_create_circuit_page(fileHandle, parentPath, designPath, context)
{
  decl designName = iff_valid_short_name(designPath);

  // first create ICON line
  decl iconList = list("CIRCUITPAGE",parentPath);

  decl gridList = iff_get_grid_preferences();
  iconList = append(iconList,gridList);

  decl designCode = iff_get_design_code(designPath);
  decl userAttr = strcat("HPEESOF_DESIGN_CODE=",designCode);
  iconList = append(iconList,list(userAttr));

  decl propList;
  decl propIter = db_create_prop_iter(context);
  for ( ; db_prop_iter_is_valid(propIter); propIter = db_prop_iter_get_next(propIter))
  {
      decl propName = db_prop_iter_get_name(propIter);
      if( propName != NULL )
      {
          decl propValue = db_prop_iter_get_value(propIter);

          propName = strcat(IffToMgcSystemName,
              "_DESIGN_PROPERTY_", propName, "=");

          if(( propValue != NULL ) && ( propValue != "" ))
              propName = strcat(propName, propValue);

          propList = append(propList, list(propName));
      }
  }

  decl userAttrList = propList;
  if(userAttrList)
      iconList = append(iconList,userAttrList);

  iconList = blanks_to_sepchar(iconList);

  if(fileHandle)
    fputs(fileHandle, iconList);
}

defun oa_create_draw_page(fileHandle, parentPath, designPath, context)
{
    decl iconList, gridList, userAttr, userAttrList, 
        designCode, propHandle, designType, designName;

    designName = iff_valid_short_name(designPath);

    // first create ICON line
    iconList = list("DRAWPAGE",parentPath,parentPath);

    gridList = iff_get_grid_preferences();
    iconList = append(iconList,gridList);

    designCode = iff_get_design_code(designPath);
    userAttr = strcat("HPEESOF_DESIGN_CODE=",designCode);
    iconList = append(iconList,list(userAttr));

    userAttrList = oa_build_drawpage_property_list(context);
    if(userAttrList)
        iconList = append(iconList,userAttrList);

    iconList = blanks_to_sepchar(iconList);

    if(fileHandle)
        fputs(fileHandle, iconList);
}

defun oa_create_layer_page(fileHandle, parentPath)
{
  // first create ICON line
  decl iconList = list("LAYERPAGE",parentPath);
  iconList = blanks_to_sepchar(iconList);
  if(fileHandle)
    fputs(fileHandle, iconList);
}

/////////////////////////////////////////////////////////////////////////////
// Read the current layer file and create a LAYER entry for each line in
// the file.
/////////////////////////////////////////////////////////////////////////////
defun oa_iff_write_layers(context, fileHandle)
{
    // If we do not have a file do not bother generating data
    if( !fileHandle )
        return;

    // We should probably use db_get_layout_layerid_names().
    // db_get_layer_names() returns all the layers which may not required, for example layers ads_y<x>, x=1,2,3 etc
    decl layerList = db_get_layer_names(context);
    while ( layerList != NULL )
    {
        decl layerName = car( layerList );

        decl layerId = db_get_layerid(context, layerName);
        decl layerNumber = db_get_layer_number(layerId);
        decl layerColor = db_get_layerid_rgb(context, layerId);
        layerColor = layerColor & 0x00FFFFFF;
        decl layerPattern = db_get_layerid_fill_pattern(context, layerId);
        decl layerOpaque  = "off";

        decl layerData = list("LAYER", layerName, layerNumber, oa_mapColor(val(layerColor)), 
            mapPattern(val(layerPattern)), layerOpaque);

        decl isInVisible = db_is_layerid_invisible(context, layerId);
        decl visible;
        if(isInVisible)
            visible = 0;
        else
            visible = 1;

        decl isProtected = db_is_layerid_protected(context, layerId);
        decl plotmode = db_get_layerid_fill_mode(context, layerId);
        decl layerBinding = db_get_layer_binding(context, layerNumber);

        layerData = append(layerData, 
            list(strcat(IffLayoutBindingName, "=", layerBinding),
            strcat("plotmode=", plotmode),
            strcat("protected=", isProtected),
            strcat("visible=", visible),
            strcat(IffLayoutPatternName, "=", layerPattern),
            strcat(IffLayoutColorName, "=", oa_mapIndex(val(layerColor)))
            ));


        if( layerData != NULL )
            fputs(fileHandle, blanks_to_sepchar(layerData));

        layerList = cdr( layerList );
    }

    if(( iffOpenWinInst != NULL  ) && ( iffOpenWinInstId > 0 ))
    {
      iff_set_current_window(iffOpenWinInst);
      iff_set_current_window_by_seq_num(iffOpenWinInstId);
    }

    return;
}

//////////////////////////////////////////////////////////////////////
// Check the design to see if the object path has been used before.
// Return the object path if found else return NULL.
//////////////////////////////////////////////////////////////////////
defun oa_iff_check_for_object_path(designName, symbolName)
{
  decl parentPath = NULL;
  // first check the rep to see if there is a stored path
  decl context = de_find_design_context_from_name(designName);
  if (!context)
  {
      return NULL;
  }

    // first check the rep to see if there is a stored path
  decl propIter = db_create_prop_iter(context);
  parentPath = oa_iff_find_path_property(propIter);
  if(( parentPath == NULL ) && ( de_is_layout_context(context) ))
  {
      decl layContext = de_get_design_context_from_name(designName, REP_SCHEM);
      if(layContext)
      {
          decl propIter = db_create_prop_iter(layContext);
          parentPath = oa_iff_find_path_property(propIter);
      }

      //
      // If the object path was found it needs to be rebuilt to
      // use the "art" type instead of "design" type.
      //
      if( parentPath != NULL )
      {
          decl oldPath = parentPath;
          decl iconType;
          decl iconName;
          parentPath = "";
          oldPath = next_icon_pair(oldPath, &iconType, &iconName);
          while( oldPath != NULL )
          {
              parentPath = strcat(parentPath, 
                  "/", iconName, ":", iconType);
              oldPath = next_icon_pair(oldPath, &iconType, &iconName);
          }
          parentPath = strcat(parentPath, "/", iconName, ":art");
      }
  }

  if( (parentPath == NULL) && (symbolName != NULL)) // Also check symbol.....
  {
      decl symContext = de_get_design_context_from_name(symbolName, REP_SCHEM);
      decl propIter = db_create_prop_iter(symContext);
      parentPath = oa_iff_find_path_property(propIter);
  }

  return ( parentPath );
}

/////////////////////////////////////////////////////////////////////////////
//given: pinList of all pin names with logical pinNums  
//       ex: [1, "p1", 3, "p3", 2, "pin2"]  
/////////////////////////////////////////////////////////////////////////////
defun oa_iff_read_design(parentDesignName, parentPath, fileHandle, 
                         pinList, logFile, inArtComp, refPath, 
                         flipped)
{
    if( IffDebugMessageLevel > 5 )
        print_value("Begin: iff_read_design");

    if( IffDebugMessageLevel > 3 )
    {
        if(( fileHandle ) && ( IffAddCommentsToIff ))
        {
            decl str;
            str = strcat("# Reading design ", parentDesignName);
            str = strcat(strcat(str, " PATH="), refPath);
            fputs(fileHandle, blanks_to_sepchar(list(str)));
        }
    }

    iff_log_message(list("Exporting design", parentDesignName));
    NumOutputLines = 0;

    port_stack_clear();
    decl context = de_find_design_context_from_name(parentDesignName);
    if(!context)
    {
        iff_log_message(list("Design file not found.  Skipping design", 
            parentDesignName, "\n"));
    }
    else
    {
        decl saveUserUnits = UserUnits;
        UserUnits = db_get_context_db_factor(context);

        // Determine scaling factor required for current scalar and units.
        // For schematic units are always "inches" and exported in centi
        // inches (/100). Layouts are scaled to match the top layout units.
        decl currentUserMksScale = db_get_context_unit_mks(context);
        if( UserMksScale == -1 )
        {
            if(( !de_is_layout_context(context) ) &&
                ( "inches" != db_get_context_unit_name(context)))
            {
                UserMksScale = 0.0254;
            }
            else
            {
                UserMksScale = currentUserMksScale;
            }
        }

        if( currentUserMksScale != UserMksScale )
        {
            UserUnits = UserUnits * ( UserMksScale / currentUserMksScale );
        }

        if(de_is_schematic_context(context))
        {
            // write CIRCUITPAGE line
            oa_create_circuit_page(fileHandle, parentPath, parentDesignName, context);

            // Write instances
            oa_iff_build_SchemInst_list(parentDesignName, context, fileHandle, 
                pinList, logFile, refPath);

            // Write shapes for layout as well as schematic
            oa_iff_write_geom(context, fileHandle, logFile, refPath, NULL/*instHierTransform*/);
        }
        else if(de_is_layout_context(context) && !inArtComp)
        {
            // Initialize the world to a known state....
            db_clear_map();
            InstX = 0.0;
            InstY = 0.0;
            InstAngle = 0.0;
            InstID = 1;
            drawpageUserUnits = UserUnits;

            // write LAYERPAGE line 
            oa_create_layer_page(fileHandle, parentPath);
            oa_iff_write_layers(context, fileHandle);

            if(fileHandle)
                fputs(fileHandle, strcat("ENDPAGE", SEP_CHAR)); 

            // write DRAWPAGE line 
            oa_create_draw_page(fileHandle, parentPath, parentDesignName, context);

            // Write shapes for layout as well as schematic
            oa_iff_write_geom(context, fileHandle, logFile, refPath, NULL/*instHierTransform*/);
        }

        oa_iff_export_ports(context, fileHandle, logFile);

        if(de_is_schematic_context(context))
        {
            // Export connector information for wire labels 
            oa_iff_export_write_wire_labels(context, fileHandle, logFile);

            decl wireList = oa_iff_build_wire_list(parentDesignName, context, 
                fileHandle, pinList, logFile);

            iff_write_output_lines(fileHandle, logFile);

            iff_write_wires(wireList, fileHandle, logFile);

            if(fileHandle)
                fputs(fileHandle, strcat("ENDPAGE", SEP_CHAR)); 
        }
        else
        {
            oa_iff_build_layoutInst_list(context, fileHandle,
                pinList, logFile, refPath, flipped);

            iff_export_oa_vias(context, fileHandle, logFile, refPath);

            if(!inArtComp && fileHandle) 
                fputs(fileHandle, strcat("ENDPAGE", SEP_CHAR)); 

        }
        UserUnits = saveUserUnits;
    }

    iff_log_message(list("Finished exporting design", parentDesignName));

    if( IffDebugMessageLevel > 5 )
      print_value("End:   iff_read_design");
}


defun iff_text_height(textRule)
{
  decl textHeight;  

  if(textRule == 1)
    textHeight = list(10,16.67);
  else if(textRule == 2)
    textHeight = list(12,20);
  else if(textRule == 3)
    textHeight = list(15,25);
  else if(textRule == 4)
    textHeight = list(17.5,29.17);
  else if(textRule == 5)
    textHeight = list(20,33.33);
  else if(textRule == 6)
    textHeight = list(24,40);
  else if(textRule == 7)
    textHeight = list(35,58.33);
  else if(textRule == 8)
    textHeight = list(50,83.33);
  else if(textRule == 12)
    textHeight = list(8.33,13.89);
  else if(textRule == 14)
    textHeight = list(12.5,20.83);
  else if(textRule == 16)
    textHeight = list(10.4,17.36);
  else if(textRule == 18)
    textHeight = list(13.1,21.83);
  else if(textRule == 19)
    textHeight = list(14,23.33);
  else if(textRule == 21)
    textHeight = list(17.9,29.83);
  else if(textRule == 22)
    textHeight = list(18.8,31.33);
  else if(textRule == 23)
    textHeight = list(21.7,36.17);
  else if(textRule == 24)
    textHeight = list(25,41.67);
  else if(textRule == 25)
    textHeight = list(56.25,93.75);
  else if(textRule == 26)
    textHeight = list(62.5,104.17);
  else if(textRule == 27)
    textHeight = list(75,125);
  else 		//if(textRule == 10)
    textHeight = list(15.6,26.04);

  return(textHeight);
}

/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
defun oa_write_symbol_text(context, 
                           instHandleK, paramNameList, fileHandle, objectPath)
{
    decl textData,annotAngle, symbBBox, x1, y1, x2, y2, startX, startY;
    decl fontHeight, textHeight, textRule, textSize, lineSpac, textStrg;
    decl dcsFont, refNameLabel;
    decl firstParamY, paramRows, rowCtr;
    decl paramName;

    symbBBox =  db_get_context_bbox(context);
    if (symbBBox)
    {
        x1=db_get_bbox_x1(symbBBox)/UserUnits*100;
        y1=db_get_bbox_y1(symbBBox)/UserUnits*100;
        x2=db_get_bbox_x2(symbBBox)/UserUnits*100;
        y2=db_get_bbox_y2(symbBBox)/UserUnits*100;
    }
    else
    {
        x1=0;
        x2=0;
        y1=0;
        y2=0;
    }
    if(instHandleK)
    {
        decl transform = db_get_instance_placement_transform(instHandleK);
        annotAngle = float (db_get_transform_angle(transform)) / 1000.0 ;
    }
    else
        annotAngle = 0;

    lineSpac="NORMAL";
    fontHeight = iff_get_preference(INST_TEXT_HEIGHT_P)*100;
    textHeight = fontHeight;
    fontHeight = fontHeight * 1.25;  // Handle line spacing between parameters
    textRule = iff_text_rule(textHeight);
    decl ShadeRule = iff_get_preference(INST_PARAM1_LAYER_P);

    if(annotAngle == 0 || annotAngle == 180)
    {
        startX = x1;
        startY = y1 - fontHeight;
    }
    else 
    {
        startX = x2 + fontHeight;
        startY = y2 - fontHeight;
    }

    annotAngle = iff_text_rot(annotAngle);
    // textSize = "0,0,IN/100";
    textSize = strcat(strcat("0,",textHeight), ",IN/100");

    // add code for NAME and LABEL - always the same
    textData = list("TEXT",ShadeRule,annotAngle,textRule,textSize,
        lineSpac, startX, startY, "@LABEL");
    if(fileHandle)
        fputs(fileHandle, blanks_to_sepchar(textData));

    startY -= fontHeight; 
    textData = list("TEXT",ShadeRule,annotAngle,textRule,textSize,
        lineSpac, startX, startY, "@NAME");
    if(fileHandle)
        fputs(fileHandle, blanks_to_sepchar(textData));

    startY -= fontHeight; 

    firstParamY = startY;
    /* get max number of params rows, (params per column) */
    paramRows = iff_get_preference(INST_TEXT_ROWS_P);
    rowCtr = 0;

    while(paramNameList)
    {
        paramName = iff_ex_map_single_prop(objectPath, car(paramNameList));
        textStrg = strcat(strcat("@", paramName),"=");

        textData = list("TEXT",ShadeRule,annotAngle,textRule,textSize,
            lineSpac, startX, startY, textStrg);

        if(fileHandle)
            fputs(fileHandle, blanks_to_sepchar(textData));

        // reset startY for next param
        startY -= fontHeight;
        paramNameList = cdr(paramNameList);
        rowCtr++;

        if(rowCtr == paramRows)
        {
            rowCtr = 0;
            startY = firstParamY;
            startX += 300.0;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// return string for icon line
/////////////////////////////////////////////////////////////////////////////
defun create_symbol_page(fileHandle, parentPath, symbolName, designPath, symbolHandle)
{
    decl iconList, gridList, userAttr, designCode, propHandle, userAttrList;

    decl context = de_find_design_context_from_name(designPath);
    decl designName;
    if(context)
        designName = iff_get_short_design_name(context);
    else if(is_adsInbuilt_libCell(symbolName))
    {
        decl libName, cellName, viewName;
        de_parse_lib_cell_view_name(symbolName, &libName, &cellName, &viewName);
        designName = cellName; // ADS library component
    }

    ObjectPathList = append(ObjectPathList, 
        list(list(designName, parentPath)));

    // iff_ex_map_is_loaded(parentPath, designName);

    iconList = list("SYMBOLPAGE",parentPath,0,0);

    gridList = iff_get_grid_preferences();
    iconList = append(iconList,gridList);

    designCode = iff_get_design_code(symbolName);
    userAttr = strcat("HPEESOF_DESIGN_CODE=",designCode);
    iconList = append(iconList,list(userAttr));

    userAttrList = build_symbolpage_property_list(symbolName);
    if(userAttrList)
        iconList = append(iconList,userAttrList);

    iconList = blanks_to_sepchar(iconList);
    fputs(fileHandle, iconList);
}

defun make_list_eqn(attrName, attrValue)
{
    decl retVal;

    attrName = strcat(attrName, "=");
    if(attrValue != NULL)
      retVal = list(strcat(attrName,attrValue));
    else 
      retVal = list(attrName);
    return(retVal);
}

//////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////
defun get_symbol_dm_data_item(symbolName, dmData, 
			      itemHandle, itemName, itemCode)
{
  decl attrName;
  decl attrValue;

  attrName  = strcat(strcat(iff_get_item_prefix(symbolName), "_"), itemName);
  attrValue = dm_get_item_definition_attribute(itemHandle,itemCode);

  if( IffDebugMessageLevel > 15 )	
    print_value(attrValue);

  if(attrValue != NULL)
    dmData = append(dmData, make_list_eqn(attrName, attrValue));
  
  return(dmData);
}

//////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////
defun get_symbol_dm_data(symbolPath, symbolName, designCode, symObjPath)
{
    decl dmData, itemHandle, simCode;
    decl attrValue;
    decl tmp;
    decl dirSep;
    simCode = dm_get_simcode_from_designcode(designCode);
    itemHandle = dm_find_item_definition(symbolPath, simCode);

    // get the symbol name from the object path
    symbolName = parse_parent_icon_name(NULL, symObjPath);

    if(! itemHandle )
        return(NULL);

    attrValue = dm_get_item_definition_attribute(itemHandle,ITEM_NAME);

    if( IffDebugMessageLevel > 15 )	
        print_value(attrValue);

    if(attrValue != NULL)
    {
        // Remove any full path data ....
        dirSep = iff_get_directory_delimiter();
	tmp = parse(attrValue, dirSep);
	attrValue = nth(listlen(tmp)-1, tmp);
	if(IffAdsProperties)
	{
	    dmData = append(dmData, 
			    make_list_eqn(strcat(iff_get_item_prefix(symbolName), 
					   "_ITEM_NAME"), attrValue));
	}
    }

    // Output properties to indicate item definition attributes.
    // These properties are only relevant to ADS/Series IV.

    if(IffAdsProperties)  
    {
        dmData = get_symbol_dm_data_item(symbolName, dmData, itemHandle, 
					 "ITEM_LABEL", ITEM_LABEL);

	dmData = get_symbol_dm_data_item(symbolName, dmData, itemHandle, 
					 "ITEM_ATTR", ITEM_ATTR);

    dmData = get_symbol_dm_data_item(symbolName, dmData, itemHandle, 
				     "ITEM_ATTR_EX", ITEM_ATTR_EX);

    dmData = get_symbol_dm_data_item(symbolName, dmData, itemHandle, 
				     "ITEM_DIALOG_NAME", ITEM_DIALOG_NAME);

	dmData = get_symbol_dm_data_item(symbolName, dmData, itemHandle, 
					 "ITEM_PRIORITY", ITEM_PRIORITY);

	dmData = get_symbol_dm_data_item(symbolName, dmData, itemHandle, 
					 "ITEM_PREFIX", ITEM_PREFIX);

	dmData = get_symbol_dm_data_item(symbolName, dmData, itemHandle, 
					 "ITEM_DIALOG_DATA", ITEM_DIALOG_DATA);

	dmData = get_symbol_dm_data_item(symbolName, dmData, itemHandle, 
					 "ITEM_NET_FORMAT", ITEM_NET_FORMAT);

	dmData = get_symbol_dm_data_item(symbolName, dmData, itemHandle, 
					 "ITEM_NET_DATA", ITEM_NET_DATA);

        /* Do not include ADS_ITEM_SCHEM_FORMAT in output.                    */
        /* It is considered internal database information.  PDE.6538          */
        /* dmData = get_symbol_dm_data_item(symbolName, dmData, itemHandle,   */
        /*                           "ITEM_SCHEM_FORMAT", ITEM_SCHEM_FORMAT); */

	dmData = get_symbol_dm_data_item(symbolName, dmData, itemHandle, 
					 "ITEM_SCHEM_NAME", ITEM_SCHEM_NAME);

	dmData = get_symbol_dm_data_item(symbolName, dmData, itemHandle, 
					 "ITEM_ART_DATA", ITEM_ART_DATA);

	dmData = get_symbol_dm_data_item(symbolName, dmData, itemHandle, 
					 "ITEM_ART_TYPE", ITEM_ART_TYPE);

	dmData = get_symbol_dm_data_item(symbolName, dmData, itemHandle, 
					 "ITEM_ICON", ITEM_ICON);

	dmData = get_symbol_dm_data_item(symbolName, dmData, itemHandle, 
					 "ITEM_FILE", ITEM_FILE);

	dmData = get_symbol_dm_data_item(symbolName, dmData, itemHandle, 
					 "ITEM_DATE", ITEM_DATE);

	dmData = get_symbol_dm_data_item(symbolName, dmData, itemHandle, 
					 "ITEM_SIMTYPE", ITEM_SIMTYPE);

    attrValue = dm_get_item_definition_attribute(itemHandle,ITEM_NETLIST_CB);

    if( IffDebugMessageLevel > 15 )	
        print_value(attrValue);

    if((attrValue != NULL) && ( is_list(attrValue) == TRUE ))
        dmData = append(dmData,
			make_list_eqn("ADS_ITEM_NETLIST_CB", attrValue));
    }

    return(dmData);

}

/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
defun iff_fix_escaping(paramValue)
{
    // decl value1=midstr(identify_value(paramValue),1, strlen(identify_value(paramValue))-2); 
    decl value1=paramValue;
    decl tmpValue="", char, i;

    if (value1)
    {
        for (i=0; i<strlen(value1); i++)
        {
            char=midstr(value1, i, i);
            if (char=="\\")
            {
                i++;
                char=midstr(value1, i, i);            
            }
            tmpValue=strcat(tmpValue, char);
        }

    }

    return(tmpValue);
    
}

/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
defun get_symbol_param_dm_data(symbolPath, designCode, objectPath)
{
    decl dmData, itemHandle, itemParams, paramHandle;
    decl paramName, attrName, attrValue, paramValue, paramIndex;
    decl symbolName, formName;
    decl exportParamName;
    decl badValueList;
    decl tList;

    symbolName = iff_valid_short_name(symbolPath);

    itemHandle = dm_find_item_definition(symbolPath,dm_get_simcode_from_designcode(designCode));

    if(! itemHandle)
      return(NULL);

    itemParams = dm_get_item_definition_attribute(itemHandle,ITEM_PARMS);
    if(! itemParams)
      return(NULL);

    //badValueList = iff_get_bad_value_list(propHandle);
    badValueList = NULL;

    dmData = NULL;
    paramIndex = 1;
    paramHandle = dm_first_parm_definition(itemParams);
    while(paramHandle)
    {
        /* PARM_NAME */
        paramName = dm_get_parm_definition_attribute(paramHandle, 0); 
	exportParamName = iff_ex_map_single_prop(objectPath, paramName);
	if( paramName != "HAS_SHEET" )  /* Skip special IFF only properties */
	{
	    /* PARM_DEFVALUE == 6 */
	    paramValue = dm_get_parm_definition_attribute(paramHandle, 
						      DM_PARM_DEFVALUE);
	    formName   = db_get_parm_attribute(paramValue, PARM_FORM_NAME);
	    paramValue = param_value_dm_class(paramValue);
	    if (is_string(paramValue))
	    {   
	        paramValue=iff_fix_escaping(paramValue);
	    }
	    
	    // Only output parameter modifier properties if the 
            // user has requested them.  These properties are 
            // only recognized by ADS, and are relevant only when 
            // transfers are being done from ADS to ADS, which 
            // is not a recommended use model.

	    if(IffAdsProperties)
	    {
	        /* PARM_UNIT == 4 */
	        attrName = strcat(paramName, "_", IffParmMidStr, "_UNIT");
		attrName = iff_ex_map_single_prop(objectPath, attrName);
		attrValue = dm_get_parm_definition_attribute(paramHandle, 
							 DM_PARM_UNIT);
	
		if( badValueList != NULL )
		    tList = member(paramName, badValueList);
		else 
		    tList = NULL;

		if(( tList != NULL ) && ( paramValue == car(car(cdr(tList))) ))
		    paramValue = nth(1, car(cdr(tList)));  
		else if( symbolName != "UNITS" )
		    paramValue = iff_add_units_to_symbol(paramValue, attrValue);

		dmData = append(dmData, make_list_eqn(exportParamName, paramValue));
		dmData = append(dmData, make_list_eqn(attrName, attrValue));
	
		/* PARM_LABEL == 1 */
		attrName = strcat(paramName, "_", IffParmMidStr, "_LABEL");
		attrName = iff_ex_map_single_prop(objectPath, attrName);
		attrValue = dm_get_parm_definition_attribute(paramHandle, 
							     DM_PARM_LABEL);
		dmData = append(dmData, make_list_eqn(attrName, attrValue));
		
		/* PARM_ATTR == 2 */
		attrName = strcat(paramName, "_", IffParmMidStr, "_ATTR");
		attrName = iff_ex_map_single_prop(objectPath, attrName);
		attrValue = dm_get_parm_definition_attribute(paramHandle, 
							 DM_PARM_ATTR);
		/* dm_get_parm_definition_attribute() should do right shift
		   and it may do so later, until then we need to do it for
		   create_parm to work right since it left shifts it on input
		   
		   10/16/95 - note from ghawisher that this fix was made.
		   attrValue = attrValue>>16;		 */

		dmData = append(dmData, make_list_eqn(attrName, attrValue));

		/* PARM_FORMSET == 5 */
		attrName = strcat(paramName, "_", IffParmMidStr, "_FORMSET");
		attrName = iff_ex_map_single_prop(objectPath, attrName);
		attrValue = dm_get_parm_definition_attribute(paramHandle, 
							     DM_PARM_FORMSET);
		//print_value(list(attrName,attrValue));
		dmData = append(dmData, make_list_eqn(attrName, attrValue));
		
		/* PARM_INDEX */
		attrName = strcat(paramName, "_", IffParmMidStr, "_INDEX");
		attrName = iff_ex_map_single_prop(objectPath, attrName);
		attrValue = paramIndex++;
		dmData = append(dmData, make_list_eqn(attrName, attrValue));

		/* FORM NAME */
		attrName = strcat(paramName, "_", IffParmMidStr, "_FORM_NAME");
		attrName = iff_ex_map_single_prop(objectPath, attrName);
		dmData = append(dmData, make_list_eqn(attrName, formName));
	    }
	    else
	    {
		attrName = iff_ex_map_single_prop(objectPath, attrName);
		attrValue = dm_get_parm_definition_attribute(paramHandle, 
							 DM_PARM_UNIT);
	
		if( badValueList != NULL )
		    tList = member(paramName, badValueList);
		else 
		    tList = NULL;

		if(( tList != NULL ) && ( paramValue == car(car(cdr(tList))) ))
		    paramValue = nth(1, car(cdr(tList)));  
		else if( symbolName != "UNITS" )
		    paramValue = iff_add_units_to_symbol(paramValue, attrValue);

		dmData = append(dmData, make_list_eqn(exportParamName, paramValue));

	    }
	}

	paramHandle = dm_next_parm_definition(paramHandle);
    }

    //print_value(dmData);
    return(dmData);

}

//////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////
defun create_scion_page(fileHandle, symbolName, designPath, parentPath, logFile)
{
  decl scionData, pathAttr, userAttrList;
  decl designName = iff_valid_short_name(designPath);
  //print_value(list("create_scion_page", designName));

  // Get the item info data
  decl itemData = get_symbol_dm_data(designPath, 
				designName, TopDesignCode, parentPath);
  //print_value(scionData);
  //print_value("");

  if(!is_pdeoa_mode())
      iff_ex_map_is_loaded(parentPath, designName);

  scionData = list("SCIONPAGE", parentPath);

  if( itemData )
    scionData = append(scionData, itemData);

  decl symContext = de_get_design_context_from_name(symbolName, REP_SCHEM);
  userAttrList = build_page_property_list(symContext, "SCIONPAGE");
  if( userAttrList )
      scionData = append(scionData, userAttrList);

  if(fileHandle)
    fputs(fileHandle, blanks_to_sepchar(scionData));

  scionData = get_symbol_param_dm_data(designPath, TopDesignCode, parentPath);
  userAttrList = build_symbol_property_list(symContext, parentPath);
  if( userAttrList )
      scionData = append(scionData, userAttrList);

  // scionData = append(scionData, itemData);

  // Add property to identify if a symbol has a schematic
  if( schematic_in_list(designName) == TRUE )
    scionData = append(scionData, make_list_eqn("HAS_SHEET", "Y"));
  //print_value(scionData);ff(2);
  // M stands for master igon - just hard code it
  scionData = append(list("SCIONOBJ","M", 
			  parse_parent_icon_name(fileHandle, parentPath)),
			  scionData);

  if(fileHandle)
  {
    fputs(fileHandle, blanks_to_sepchar(scionData));
    fputs(fileHandle, strcat("ENDPAGE", SEP_CHAR)); 
  }
}

/////////////////////////////////////////////////////////////////////////////
//return pinList of all pin names with logical pinNums  ex: [1, "p1", 3, "p3", 2, "pin2"]  
/////////////////////////////////////////////////////////////////////////////
defun oa_iff_read_symbol(designName, symbolName, paramNames, 
                         parentPath, fileHandle, logFile)
{
    if( IffDebugMessageLevel > 5 )
        print_value("Begin: iff_read_symbol");

    decl symContext = de_find_design_context_from_name(symbolName, REP_SCHEM);
    if(!de_is_symbol_context(symContext))
    {
        iff_log_message(list("Failed to create SYMBOLPAGE for design ", 
            symbolName, "."));

        if( IffDebugMessageLevel > 5 )
            print_value("End:   iff_read_symbol");

        return;
    }

    // get user units and store for global access 
    UserUnits = db_get_context_db_factor(symContext);

    if( fileHandle != NULL ) // For schematic/symbol context
    {
        create_scion_page(fileHandle, 
            symbolName, designName, parentPath, logFile);
        decl symbolHandle = NULL;
        create_symbol_page(fileHandle, 
            parentPath, symbolName, designName, symbolHandle);
    }

    decl pinList = oa_traverse_symbol(fileHandle, symContext, logFile);
    //pinList = iff_validate_pins_vs_ports(designName, pinList);
    if( fileHandle != NULL )
        oa_write_symbol_text(symContext, NULL, paramNames, fileHandle, parentPath);

    if(fileHandle)
        fputs(fileHandle, strcat("ENDPAGE", SEP_CHAR)); 

    if( IffDebugMessageLevel > 5 )
        print_value("End:   iff_read_symbol");

    return(pinList);
}

/* return string for icon line */
defun create_icon(fileHandle, iconType, parentPath, designName)
{
  decl iconList, iconPath;

  if((rightstr(parentPath,1)) != "/")
    iconPath = list(parentPath,"/",designName,":",iconType);
  else iconPath = list(parentPath,designName,":",iconType);

  iconPath = iff_strip_inner_blanks(iconPath);

  //iconPath = strcat(strcat(parentPath,designName), strcat(":",iconType));

  iconList = list("ICON",parentPath,iconType,designName,iconPath,0,0,SEP_CHAR);

  iconList = blanks_to_sepchar(iconList);  
  if(fileHandle)
    fputs(fileHandle, iconList);
  return(iconPath);
}

// parse off every pair between fwd slashes and make an icon line
defun parse_parent_path(fileHandle, parentPath)
{
  decl startPath, iconType, iconName;

  startPath = "/";
  while(parentPath)
  {
    // returns NULL when no pairs left
    parentPath = next_icon_pair(parentPath, &iconType, &iconName);

    if(iconType && iconName)
      startPath = create_icon(fileHandle, iconType, startPath, iconName);
  }
}

defun oa_create_icon_lines(fileHandle, designName, symbolName, isSchematicDesign)
{
    //decl context designName
    decl parentPath = oa_iff_check_for_object_path(designName, symbolName);
    if( parentPath != NULL )
    {
        // make the required icon lines by parsing the parentPath 
        parentPath = iffMapObjectPath(parentPath, NULL); 
        parse_parent_path(fileHandle, parentPath);
        return(parentPath);
    }

    decl libraryName, cellName, viewName;
    de_parse_lib_cell_view_name(designName, &libraryName, &cellName, &viewName);
    decl context = de_find_design_context_from_name(designName);
    if (context)
    {
        cellName = iff_get_short_design_name(context);
        libraryName = db_get_library_name(context);

        decl isWorkSpaceCell = oa_iff_is_workspace_cell(symbolName);
        if(!isWorkSpaceCell && !de_is_layout_context(context))
        {
            // Actually for PDK component it has to be symbols
            libraryName = "symbols";
        }
    }

    decl parentPath = create_icon(fileHandle, "file", "/", libraryName);
    if (isSchematicDesign)
        parentPath = create_icon(fileHandle, "design", parentPath, cellName);
    else
        parentPath = create_icon(fileHandle, "art", parentPath, cellName);

    parentPath = iffMapObjectPath(parentPath, NULL); 
    return(parentPath);
}

defun create_icon_lines_symbol(fileHandle, symbolName)
{
    decl context = de_find_design_context_from_name(symbolName);
    if(!context)
        return NULL;

    decl parentPath = NULL;
    if(de_is_symbol_context(context))
    {
        decl propIter = db_create_prop_iter(context);
        parentPath = oa_iff_find_path_property(propIter);
    }
    if(parentPath)
    {
        // make the required icon lines by parsing the parentPath 
        parentPath = iffMapObjectPath(parentPath, NULL); 
        parse_parent_path(fileHandle, parentPath);
        return(parentPath);
    }

    decl libName, cellName, viewName;
    de_parse_lib_cell_view_name(symbolName, &libName, &cellName, &viewName);

    // ICON will be created with a default object path.
    parentPath = create_icon(fileHandle, "file", "/", DefaultLibraryPath);
    parentPath = create_icon(fileHandle, "design", parentPath, cellName);

    parentPath = iffMapObjectPath(parentPath, NULL); 

    return(parentPath);
}

// turn a regular list of strings into a list of quoted strings
defun list_with_quotes(listIn)
{
  decl listItem, listOut;
  listOut = NULL;

  while(listIn)
  {
    listItem = car(listIn);

    listItem = fmt_tokens(list("\"", listItem, "\""));

    // take the blanks out

    // put in storage list
    if(! listOut)
      listOut = list(listItem);
    else listOut = append(listOut, list(",", listItem));

    listIn = cdr(listIn);
  }

  return(fmt_tokens(listOut));
}

// build add_library_partition() string to output if successful
defun build_add_library_string(partitionID, partitionName, symbolList)
{
  decl libraryPartStrg;

  symbolList = list_with_quotes(symbolList);
  libraryPartStrg = fmt_tokens(list(
		"add_library_partition\(\"", 
		partitionID,
		"\", \"", 
		partitionName, "\",
		list(", symbolList, "\));"));

  return(libraryPartStrg);
}

/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
defun iff_export_close_logfile(logFile)
{
  if(logFile)
  {
    fclose(logFile);
  }
}

/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////
defun iff_export_open_logfile(logfileName, outfileName)
{
  decl logFile;

  remove(logfileName);

  iff_log_message(list(strcat("Log file name: ", logfileName, "\n",
			      TransferTypeName,
			      " translation \n\n",
			      "Output format: Intermediate File Format")));
  if(outfileName)
    iff_log_message(list("Output filename:", outfileName));

  return(NULL);
}


// return TRUE if found
defun symbol_in_list(symbolName)
{
  decl symbolList;

  symbolList = SymbolList;
  while(symbolList)
  {
    if(symbolName == car(car(symbolList)))
      return(TRUE);

    symbolList = cdr(symbolList);
  }

  // not found
  return(FALSE);
}

//////////////////////////////////////////////////////////////////////////////
// Search the design list for the specified schematic. If found return true
// else return false.
//////////////////////////////////////////////////////////////////////////////
defun schematic_in_list(schName)
{
  decl schList;

  schList = DesignList;
  while(schList)
  {
    if(schName == car(car(schList)))
      return(TRUE);

    schList = cdr(schList);
  }

  // not found
  return(FALSE);
}

defun iff_store_new_symbol(designName,symbolName,paramNames)
{
  // first make sure we did not already store it
  if(symbol_in_list(designName))
    return;

  SymbolList = append(SymbolList, list(list(designName,symbolName,paramNames)));
}

// return level if found, -1 if not found
defun find_design_level(designName,pos)
{
  decl designList;

  designList = DesignList;
  *pos=0;

  while(designList)
  {
    if(designName == car(car(designList)))
      return(car(cdr(car(designList))));

    designList = cdr(designList);
    *pos = *pos+1;
  }

  // not found
  return(-1);
}

defun replace_design_level(designName,level,symbolName,paramNames,pos)
{
  // verify valid pos

  //print_value("in replace_design_level");

  if(listlen(DesignList) > pos)
    repla(DesignList,list(designName,level,symbolName,paramNames),pos);
}

defun iff_store_new_design(designName, level, symbolName, paramNames)
{
  decl oldLevel, pos;

  // first see if design is in list yet, returns -1 if not found
  oldLevel = find_design_level(designName,&pos);

  if(oldLevel == -1)      // not found
  {
    DesignList = append(DesignList,
		   list(list(designName,level,symbolName,paramNames)));
    return;
  }

  // found, now check level, replace if higher
  if(level > oldLevel)
    replace_design_level(designName,level,symbolName,paramNames,pos);

  // if lower or the same, do nothing
  return;
}

defun design_list_dump_before()
{
  decl designList,designName,level;

  designList = DesignList;

  while(designList)
  {
    print_value(car(designList));
    designList = cdr(designList);
  }
}

defun design_list_dump_after()
{
  decl designList;

  designList = DesignList;

  print_value("Designs to write:");
  while(designList)
  {
    print_value(car(designList));
    designList = cdr(designList);
  }
}

defun dump_symbol_list()
{
  decl symbolList;

  symbolList = SymbolList;

  print_value("Symbols to write:");
  while(symbolList)
  {
    print_value(car(symbolList));
    symbolList = cdr(symbolList);
  }
}

// return a list of all designs at given level
defun designs_at_level(designList,level)
{
  decl newList, newInfo;

  newList = NULL;

  while(designList)
  {
    if(car(cdr(car(designList))) == level)
    {
      newInfo = list(car(car(designList)),       //designName
                     car(cdr(cdr(car(designList)))), //symbolName
                     car(cdr(cdr(cdr(car(designList)))))); //paramNames
      // found one
      newList = append(newList,list(newInfo));
    }
    designList = cdr(designList);
  }

  return(newList);
}

// put design names w/symbolName in a list where the highest levels are first
// so they will written in the correct order
defun sort_design_list()
{
  decl i,len, newList,partList;

  len = listlen(DesignList);
  newList = NULL;
  i=len-1;

  while(listlen(newList) < len && i>=0)
  {
      partList = designs_at_level(DesignList,i);
      if(partList)
          newList = append(newList, partList);
      i--;
  }

  DesignList = newList;
}

//////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////
// This function is calld only for schematic design
defun oa_iff_build_design_list(parentDesignName, level, symbolName, paramNames)
{
  decl designHandle, repHandle, instHandle;
  decl designName, special, ignore;
  decl designType, myIndent, i;
  decl deactivated;

  myIndent = "";
  for(i=0; i<level; i++ )
    myIndent = strcat(myIndent, "  ");

  iff_store_new_design(parentDesignName, level, symbolName, paramNames);
  level++;

  if( IffDebugMessageLevel > 3 )
    print_value(list("looking for parentDesignName", parentDesignName));

  decl context = de_find_design_context_from_name(parentDesignName);
  if(!context/* && !de_is_schematic_context(context)*/)
    {
      print_value(list("failed to get design handle for", parentDesignName));
      return;
    }

  decl policy = de_is_layout_context(context) ? NETLIST_FROM_LAYOUT : NETLIST_FROM_SCHEMATIC;
  decl hierarchyContext = db_create_hierarchy_context(context, policy);
  decl instIter = db_create_inst_iter(hierarchyContext);
  for( ; db_inst_iter_is_valid(instIter); instIter = db_inst_iter_get_next(instIter) )
  {
      designName = db_get_instance_sub_design_name(instIter);
      special = db_get_instance_special(instIter);

    // Only output hierarchy for activated components
    if(IffIgnoreDeactivatedComponents)
        deactivated = db_is_instance_deactivated(instIter);
    else
        deactivated = FALSE;

    if(designName && iff_analyze_special(special) && !deactivated)
    {
        decl designCode = iff_get_design_code(designName);
        decl itemHandle = dm_find_item_definition(designName, dm_get_simcode_from_designcode(designCode));
        if(itemHandle)
            symbolName = dm_get_item_definition_attribute(itemHandle, ITEM_SCHEM_NAME);

        decl paramNames;
        decl paramIter = db_create_param_iter(instIter);
        for ( ; db_param_iter_is_valid(paramIter);
            paramIter = db_param_iter_get_next(paramIter) )
        {
            decl paramName = db_get_param_name(paramIter);
            paramNames = append(paramNames, list(paramName));
        }

        decl symbol = db_get_instance_design_name(instIter);
        decl isPrimitive = db_is_primitive_instance_in_hierarchy(hierarchyContext, instIter);
        if(!isPrimitive)
        {
            // Add symbol context for the symbol name
            oa_iff_build_design_list(designName, level, symbol, paramNames);
        }
        else
        {
            iff_store_new_symbol(designName, symbol, paramNames);
        }
    }
  }
}


// return value if buffer = "optionName = value"
defun parse_option_value(buffer)
{
  decl pos;

  // first pull off everything after the = sign
  pos = index(buffer,"=");
  if(pos < 1 || pos >= strlen(buffer))
    return(NULL);

  buffer = rightstr(buffer,(strlen(buffer)-pos-1));
  if(! buffer)
    return(NULL);

  // next strip off any possible comments after value
  pos = index(buffer,"!");
  if(pos >= 0 && pos < strlen(buffer))
    buffer = leftstr(buffer,pos);

  return(stripstr(buffer));
}

//////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////
defun iff_remove_prj_ext(prjName)
{
  decl len;
  decl tmp;

  tmp = iff_get_prj_ext();
  len = strlen(tmp);
  if( len > 0 && (leftstr(prjName,strlen(prjName)-len) == tmp))
    prjName = leftstr(prjName,strlen(prjName)-len);

  return(prjName);
}

//////////////////////////////////////////////////////////////////////////////
// This routine returns the current directory path with the appended _prj.
//////////////////////////////////////////////////////////////////////////////
defun iff_get_project_path()
{
  return(getcwd());
}


defun oa_iff_build_export_project_list(fp, value)
{
    decl libs = list();
    if( value == NULL )
        value = "";

    decl tmp = index(value, ";"); // remove ; at end
    decl nstr = leftstr(value, tmp);
    decl s = parse(nstr, ",", NULL, TRUE);
    while( s )
    {
        libs = append(libs, list(car(s)));
        s = cdr(s);
    }

    return libs;
}

//////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////
defun read_iff_options(logFile, hierOption, defLibraryPath)
{
    decl fp, buffer, fileName, value, s;

    fileName = iff_find_searchpath_file("IFF_OPTION_FILE", IffOptionsFileName);
    if( fileName != NULL )
        fp = fopen(fileName, "R");
    else
        fp = NULL;

    if( fp == NULL )
    {
        iff_log_message(list("No export options defined - using default values.\n"));
    }
    else
    {
        iff_log_message(list("Reading options file", fileName, "\n"));

        buffer = fgets(fp);
        while(! (buffer==NULL))
        {
            if(strlen(buffer) > 0 && ! iff_comment_char(leftstr(buffer,1)))
            {
                // search for expected option names
                if(leftstr(buffer, 15) == "HierarchyOption")
                {
                    value = parse_option_value(buffer);
                    if(value)
                    {
                        // TODO_OA: Review
                        if(value=="1" || value=="2" || value=="3")
                            *hierOption = val(value);
                        else 
                        {
                            iff_log_message(list("   Invalid HierarchyOption =", 
                                value, "\n",
                                "   Using default value", 
                                *hierOption));
                        }
                    }
                }
                else if(leftstr(buffer, 18) == "DefaultLibraryPath")
                {
                    value = parse_option_value(buffer);
                    if(value)
                        *defLibraryPath = value;
                }
                else if(leftstr(buffer, 20) == "PromptForUserMessage")
                {
                    MGCpromptForUserMessage = TRUE;		 
                    value = parse_option_value(buffer);
                    if(( value ) && ( strcasecmp(value, "FALSE") == 0 ))
                        MGCpromptForUserMessage = FALSE;		 
                }
                else if(( s = "ExportProjects" ) && 
                    ( leftstr(buffer, strlen(s)) == s ))
                {
                    value = parse_option_value(buffer);
                    IffExportProjectList = oa_iff_build_export_project_list(&fp, value);
                }
                else if(( s = "ExportOverwriteIFF" ) && 
                    ( leftstr(buffer, strlen(s)) == s ))
                {
                    value = parse_option_value(buffer);
                    if(( value ) && ( strcasecmp(value, "TRUE") == 0 ))
                        IffOverwriteFile = TRUE;		 
                    else
                        IffOverwriteFile = FALSE;		 
                }
                else if(( s = "ExportVersion" ) && 
                    ( leftstr(buffer, strlen(s)) == s ))
                {
                    value = parse_option_value(buffer);
                    if(( value == 2 ) || ( value == 3 ))
                        IFILE_VER = value;
                }
                else if( leftstr(buffer, 17) == "ExportInterActive" )
                {
                    value = parse_option_value(buffer);
                    if(( value ) && ( strcasecmp(value, "FALSE") == 0 ))
                        IffInteractive = FALSE;
                }
                else if( leftstr(buffer, 20) == "ExportIgnoreDisabled" )
                {
                    value = parse_option_value(buffer);
                    if(( value ) && ( strcasecmp(value, "TRUE") == 0 ))
                        IffIgnoreDeactivatedComponents = TRUE;
                }
                else if( leftstr(buffer, 19) == "ExportAdsProperties" )
                {
                    value = parse_option_value(buffer);
                    if(( value ) && ( strcasecmp(value, "FALSE") == 0 ))
                        IffAdsProperties = FALSE;
                }
                else if( leftstr(buffer, 22) == "ExportUseSpaceInValues" )
                {
                    value = parse_option_value(buffer);
                    if(( value ) && ( strcasecmp(value, "TRUE") == 0 ))
                        IffValueSeparator = " ";
                    else
                        IffValueSeparator = "";
                }
                else if( leftstr(buffer, 24) == "ExportStoreSchemAnnotPos" )
                {
                    value = parse_option_value(buffer);
                    if(( value ) && ( strcasecmp(value, "TRUE") == 0 ))
                        IffStoreSchemAnnotPos = TRUE;
                    else
                        IffStoreSchemAnnotPos = FALSE;
                }
                else if( leftstr(buffer, strlen("ExportPrefixLibNameToCellName")) == "ExportPrefixLibNameToCellName" )
                {
                    value = parse_option_value(buffer);
                    if(( value ) && ( strcasecmp(value, "TRUE") == 0 ))
                        IffPrefixLibNameToCellName = TRUE;
                    else
                        IffPrefixLibNameToCellName = FALSE;
                }
                else if( leftstr(buffer, strlen("ExportIgnoreIffPathProperty")) == "ExportIgnoreIffPathProperty" )
                {
                    value = parse_option_value(buffer);
                    if(( value ) && ( strcasecmp(value, "TRUE") == 0 ))
                        IffIgnorePathProperty = TRUE;
                    else
                        IffIgnorePathProperty = FALSE;
                }
                else if( leftstr(buffer, strlen("ExportSubDesignAsLeaf")) == "ExportSubDesignAsLeaf" )
                {
                    value = parse_option_value(buffer);
                    if(( value ) && ( strcasecmp(value, "TRUE") == 0 ))
                        IffSubDesignAsLeaf = TRUE;
                    else
                        IffSubDesignAsLeaf = FALSE;
                }
                else if( leftstr(buffer, strlen("ImportOverwriteExistingDesign")) == "ImportOverwriteExistingDesign" )
                {
                    value = parse_option_value(buffer);
                    if(( value ) && ( strcasecmp(value, "TRUE") == 0 ))
                        IffOverwriteExistingDesign = TRUE;
                    else
                        IffOverwriteExistingDesign = FALSE;
                }
            }
            buffer = fgets(fp);
        }
        fclose(fp);
    }

    iff_log_message(list("Export Options: "));

    decl context = de_get_current_design_context();
    if( de_is_schematic_context(context) )
    {
        if(*hierOption == 1)
        {
            iff_log_message(list("   HierarchyOption: 1 (Current Level Only)"));
        }
        else if(*hierOption == 2)
        {
            iff_log_message(list("   HierarchyOption: 2 (All Levels - parts from Selected Libraries)"));
            iff_log_message(list("   The following libraries will be included in the export:"));
            s = IffExportProjectList;
            while( s )
            {
                iff_log_message(list("      ",car(s)));
                s = cdr(s);
            }
        }
        else if(*hierOption == 3)
        {
            iff_log_message(list("   HierarchyOption: 3 (All Levels - plus all library parts)"));
        }
    }

    iff_log_message(list("   DefaultLibraryPath:", *defLibraryPath));

    if( IffOverwriteFile == TRUE )
        iff_log_message(list("   The IFF file will be overwritten."));
    else
        iff_log_message(list("   The IFF file will be appended to."));

    iff_log_message(list("   Export IFF Version", IFILE_VER, "\n"));

}

// open the design and see if it is type 3 or 33
defun is_defaults_design(designName)
{
    decl designCode, designPtr;

    designCode = iff_get_design_code(designName);

    return(designCode == 3 || designCode == 33);
}

//////////////////////////////////////////////////////////////////////////////
// Check to see if the pathName is a full path or relative path. Two cases
// are checked for. The first is the case where the directory seperator
// is the first character in the path. The next case is where there is
// a windows drive letter as the first part of the path.
//////////////////////////////////////////////////////////////////////////////
defun iff_is_full_path(pathName)
{
  decl i;
  decl tmp;
  decl dirSep;
  decl winDrive;
  decl winPath;
  decl returnValue;

  returnValue = FALSE;
  dirSep = iff_get_directory_delimiter();

  if( leftstr(pathName, 1) == dirSep )
  {
      returnValue = TRUE;
  }
  else if(( dirSep == "\\" ) && (( i = index(pathName,":") ) > 0 ))
  {
      tmp = rightstr(leftstr(pathName, i+1),1);
      winDrive = leftstr(pathName, i);
      winPath  = rightstr(pathName, strlen(pathName)-1-i);

      // Check to make sure drive does not have delimiter
      i = index(winDrive, dirSep);
      if( i == -1 )
      {
	  returnValue = TRUE;
      }
  }

  return( returnValue );
}

//////////////////////////////////////////////////////////////////////////////
// Give a project path return the project name (currently the last component
// in the project path).
//////////////////////////////////////////////////////////////////////////////
defun iff_get_project_name_from_path(projectPath)
{
  decl dirSep;
  decl tmpPath;
  decl pos;
  decl i;

  dirSep = iff_get_directory_delimiter();

  tmpPath = projectPath;

  while(( i = index(tmpPath, dirSep)) != -1 )
  {
    tmpPath = rightstr(tmpPath, strlen(tmpPath)-i-1);
  }
  
  tmpPath = iff_remove_prj_ext(tmpPath);

  return( tmpPath );
}

//////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////
defun is_local_design(designRoot)
{
  decl fp, fileName;
  
  if( leftstr(designRoot, 1) == "/" )
    return(FALSE); // Full path not local???

  if(is_defaults_design(designRoot))
    fileName = strcat("./defaults/", designRoot);
  else 
    fileName = strcat("./networks/", designRoot);

  fileName = strcat(fileName, ".dsn");

  fp = fopen(fileName, "R");
  if(fp)
    {
      fclose(fp);
      return(TRUE);
    }
  else 
    {
      return(FALSE);
    }
}

// IFF export in OA
// Function write_iff_data() in ADS OA function writes an IFF file which is compatible
// with the file generated from ADS DSN.
defun write_iff_data(context, fileName, skipDefaults, logFile)
{
    // TODO_OA: Check if it's better to pass window rather than context
    if (context == NULL)
    {
        iff_log_message(list(strcat("Design context is not valid. \n")));
    }

    // Initialization of global variables
    DesignList = NULL;
    SymbolList = NULL;
    ObjectPathList = NULL;
    UserMksScale = -1;

    //IffExportProjectList = list(iff_get_project_path());
    DefaultLibraryPath = "ads_rflib";

    // Global variables
    // get top level design name to be used as ICON filename at all levels
    TopDesignName = db_get_design_name(context);
    TopDesignPath = TopDesignName;
    TopDesignCode = iff_get_design_code(TopDesignPath);
    IffWorkSpaceCellList = de_get_workspace_cell_list();

    iff_log_message(list(strcat("Design name: ", TopDesignName, "\n")));

    // defaults for options otherwise defined in options file iff.opt
    decl hierOption = 2;        // full hierarchy - All designs

    // Read export options from the options file
    read_iff_options(logFile, &hierOption, &DefaultLibraryPath);
    IffExportHierOption = hierOption;

    fileName = stripstr(fileName);
    if(fileName == NULL)
    {
        iff_log_message(list("Filename not specified - no iff file created"));

        if( IffDebugMessageLevel > 5 )
            print_value("End:   write_iff_data");

        return; 
    } 

    decl openMode;
    if( IffOverwriteFile == TRUE )
        openMode = "W";
    else
        openMode = "A";

    decl fileHandle = fopen(fileName, openMode);

    if(fileHandle == NULL)
    {
        iff_log_message(list("Failed to open file", fileName,
            ".  No iff file created."));
        if( IffDebugMessageLevel > 5 )
            print_value("End:   write_iff_data");

        return; 
    } 
    fputs(fileHandle, blanks_to_sepchar(list("FRAMEWORK",IFILE_VER)));

    //if(de_is_schematic_context(context))
    //{
    //    // Force bus connections to be resolved for unnamed wires
    //    decl busErr=de_resolve_bus_connections_ex( context, FALSE );
    //}

    decl parentPath;
    decl pinList = NULL;
    decl isSchematicDesign = de_is_schematic_context(context);
    if(( hierOption == 1 ) || ( de_is_layout_context(context) ))
    {
        decl symbolName = NULL;
        parentPath = oa_create_icon_lines(fileHandle, TopDesignName, symbolName, isSchematicDesign);

        // Exporting current schematic/layout context only
        // Not exporting symbol context.
        decl shortName = iff_get_short_design_name(context);
        oa_iff_read_design(TopDesignPath, parentPath, fileHandle,
            pinList, logFile,FALSE,shortName, FALSE);

    }
    else
    {
        // Create a list of designs for hierarchical design
        decl level=0;
        decl symbolName = NULL;

        decl libName, cellName, viewName;
        de_parse_lib_cell_view_name(TopDesignName, &libName, &cellName, &viewName);
        decl symbolViewName = "symbol";
        decl symViewList = de_get_views_in_library_cell(libName,cellName,SYMBOL_WINDOW);
        if(symViewList != NULL)
        {
            if(de_design_exists(libName, cellName, symbolViewName))
            {
                symbolName = strcat(libName, ":", cellName, ":", symbolViewName);
            }

            if(listlen(symViewList) > 1)
                iff_log_message(list("WARNING: IFF export does not support multiple views of a cell. Only \"symbol\" view is exported.\n"));
        }

        oa_iff_build_design_list(TopDesignPath, level, symbolName, NULL);

        // Sort the designs with the deepest one first
        sort_design_list();

        // Write SYMBOLPAGE for the primitive components
        if(( hierOption == 2 ) || ( hierOption == 3 ))
        {
            while(SymbolList)
            {
                if(( hierOption == 3 ) || 
                    ( oa_iff_design_in_list(car(car(SymbolList)),IffExportProjectList) ))
                {
                    decl designName = car(car(SymbolList));
                    decl symbolName = car(cdr(car(SymbolList)));
                    decl paramNames = car(cdr(cdr(car(SymbolList))));
                    parentPath = create_icon_lines_symbol(fileHandle, symbolName);

                    oa_iff_read_symbol(designName, symbolName, paramNames,
                        parentPath, fileHandle, logFile);
                }
                SymbolList = cdr(SymbolList);
            }
        }

        // Write the IFF file for the designs one by one 
        while(DesignList)
        {
            if(( hierOption == 3 ) || 
           ( oa_iff_design_in_list(car(car(DesignList)) ,IffExportProjectList) ) ||
           ( is_defaults_design(car(car(DesignList))) == TRUE ))
        {
            decl designName = car(car(DesignList));
            decl symbolName = car(cdr(car(DesignList)));
            if(! is_defaults_design(car(car(DesignList))))
            {
                parentPath = oa_create_icon_lines(fileHandle, designName, symbolName, isSchematicDesign);
            }

            // create symbol and scion pages for all except top design
            pinList = NULL;
            if(car(cdr(car(DesignList)))!=NULL)
            {
                pinList = oa_iff_read_symbol(car(car(DesignList)), 
                    car(cdr(car(DesignList))), 
                    car(cdr(cdr(car(DesignList)))),   //paramNames
                    parentPath, fileHandle, logFile);
            }

            context = de_find_design_context_from_name(designName);
            if (context != NULL)
            {
                decl shortName = iff_get_short_design_name(context);
                oa_iff_read_design(designName, parentPath, fileHandle,
                    pinList, logFile,FALSE,shortName, FALSE);
            }
        }
            DesignList = cdr(DesignList);
        }
    }

    iff_log_message(list(" "));
    iff_log_message(list(TransferTypeName, "file", fileName, "created."));

    fclose(fileHandle);

    if( IffDebugMessageLevel > 5 )
        print_value("Begin: write_iff_data");
}

//////////////////////////////////////////////////////////////////////////////
// Set the transfer type. This is required for layout transfers. Schematic
// transfers are the default transfer mode.
//////////////////////////////////////////////////////////////////////////////
defun oa_iff_set_trans_type(context)
{
    decl windowCode;
    if( de_is_schematic_context(context) )
        windowCode = SCHEMATIC_WINDOW;
    else
        windowCode = LAYOUT_WINDOW;

    decl winList = api_get_windows_by_id(windowCode);
    if(winList)
    {
        iffOpenWinInst = car(winList);
        iffOpenWinInstId = api_get_window_seq_num(iffOpenWinInst);
        iffOpenedWindow = FALSE;
    }
    else
    {
        iffOpenWinInst = de_create_window(windowCode);
        iffOpenWinInstId = iff_get_window_seq_num();
        iffOpenedWindow = TRUE;
    }

    de_show_context_in_new_window(context);
}


//////////////////////////////////////////////////////////////////////////////
// Schematic entry point. 
//////////////////////////////////////////////////////////////////////////////
defun iff_write_schematic(fileName, skipDefaults)
{
  if( IffDebugMessageLevel > 1 )
    print_value(strcat("BEGIN: Export of Schematic IFF into ", fileName));

  TransferTypeName = "IFF";
  iffOpenWinInst   = NULL;
  iffOpenWinInstId = 0;

  decl curWinInst    = api_get_current_window();
  decl curWinInstId  = iff_get_window_seq_num();
  iffOpenWinInst = curWinInst;
  iffOpenWinInstId = curWinInstId;

  decl logFile = iff_export_open_logfile(IffExportLogFile, fileName);

  decl context = de_get_current_design_context();
  write_iff_data(context, fileName, TRUE, logFile);

  iff_export_close_logfile(logFile);

// print_value(list("open", iffOpenWinInst, iffOpenWinInstId));

  if(( iffOpenWinInst != NULL ) && ( iffOpenWinInstId > 0 ))
    {
      iff_set_current_window(iffOpenWinInst);
      iff_set_current_window_by_seq_num(iffOpenWinInstId);
      if( iffOpenedWindow == TRUE )
        close_window();
      iffOpenWinInst = NULL;
      iffOpenWinInstId = 0;
    }

// print_value(list("current", curWinInst, curWinInstId));

  if(( curWinInstId > 0 ) && ( curWinInst != NULL ))
    {
      iff_set_current_window(curWinInst);
      iff_set_current_window_by_seq_num(curWinInstId);
    }

  if( IffDebugMessageLevel > 1 )
    print_value("END:   Export of Schematic IFF.");
}

//////////////////////////////////////////////////////////////////////////////
// Export layout iff data
// TODO: WHY DO WE NEED TO KEEP SEPARATE FUNCTIONS FOR LAYOUT AND SCHEMATIC?
//////////////////////////////////////////////////////////////////////////////
defun iff_write_layout(fileName)
{
  if( IffDebugMessageLevel > 1 )
    print_value(strcat("BEGIN: Export of Layout IFF into ", fileName));

  TransferTypeName = "IFF";
  iffOpenWinInst   = NULL;
  iffOpenWinInstId = 0;

  decl curWinInst    = api_get_current_window();
  decl curWinInstId  = iff_get_window_seq_num();
  iffOpenWinInst = curWinInst;
  iffOpenWinInstId = curWinInstId;

  decl logFile = iff_export_open_logfile(IffExportLogFile, fileName);

  decl context = de_get_current_design_context();
  write_iff_data(context, fileName, TRUE, logFile);

  iff_export_close_logfile(logFile);

  if(( iffOpenWinInst != NULL ) && ( iffOpenWinInstId > 0 ))
    {
      iff_set_current_window(iffOpenWinInst);
      iff_set_current_window_by_seq_num(iffOpenWinInstId);
      if( iffOpenedWindow == TRUE )
        close_window();
      iffOpenWinInst   = NULL;
      iffOpenWinInstId = 0;
    }

  if(( curWinInst != NULL ) && ( curWinInstId > 0 ))
    {
      iff_set_current_window(curWinInst);
      iff_set_current_window_by_seq_num(curWinInstId);
    }

  if( IffDebugMessageLevel > 1 )
    print_value("END:   Export of Layout IFF.");
}

//////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////
defun iff_set_mgc_xfer_info(mgcXferDir, schFileName, layFileName)
{
  MGCxferDirectory        = mgcXferDir;
  MGCschIffFileName       = schFileName;
  MGClayIffFileName       = layFileName;
  MGCpromptForUserMessage = TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// Test to see if the file exist in the OS. Return TRUE if found 
// and FALSE if not.
//////////////////////////////////////////////////////////////////////////////
defun iff_file_exists(fileName)
{
  decl cmd, status;

  status = filestat(fileName);
  if( status != NULL )
    return(TRUE);
  else
    return(FALSE);
}

//////////////////////////////////////////////////////////////////////////////
//
// A standard directory structure will be used to simplify the design
// transfer to MGC. The structure in Series IV will be fixed under the
// project directory. For MDS the default directory will default to the
// current directory but the user will have control over where this
// directory will be created.
// 
// The directory structure will be:
// 
// 	<top dir>/to_mgc/<trans_name>.hpxfer
// 
//      to_mgc		== This is a fixed directory name and is not
// 			   user modifiable.
//   
// 	"<top dir>"	== This is the project directory. The user
// 			   will not be allowed to change this
// 			   directory. 
// 
// 	"<trans_name>"	== The name of the design object being
// 			   transfered. In SeriesIV the design object
// 			   name is unique so the will not be allowed
// 	                   to change this name.
// 
//  RETURNS:
//          NULL if directory structure could not be verified.
//      FileName if the directory is ok and writable.
// 
//////////////////////////////////////////////////////////////////////////////
defun iff_check_mgc_dir_structure()
{
  decl dir, design_name, cmd, status, win, tmpFileName, tmpFile;
  decl dirSep;

  design_name = iff_current_design_name();
  if( design_name == NULL )
    {
      warning("", 0, "No design open to export command aborted.");
      return(NULL);
    }

  //
  // Build the directory structure by calling the OS command mkdir.
  // We ignore the return status and just verify that the we can
  // create a file in the directory when done.
  //
  dirSep = iff_get_directory_delimiter();
  dir = strcat(strcat(iff_get_project_path(), dirSep), "to_mgc");
  if( iff_is_dir(dir) == FALSE )
    mkdir(dir);
  dir = strcat(strcat(strcat(dir, dirSep), design_name), ".hpxfer");
  if( iff_is_dir(dir) == FALSE )
    mkdir(dir);

  tmpFileName = strcat(strcat(strcat(dir, dirSep),"."), getpid());
  tmpFile = fopen(tmpFileName, "W");
  if( tmpFile == NULL )
    {
      warning("", 0, strcat("Unable to create files in ", dir));
      return(NULL);
    }

  fclose(tmpFile);
  remove(tmpFileName);

  return(dir);
}

//////////////////////////////////////////////////////////////////////////////
// Find out the current user name. This will only work on UNIX must be
// fixed for PC...
//////////////////////////////////////////////////////////////////////////////
defun iff_get_current_user_name()
{
   decl cmd, filename, status, fd;
   decl userName = expandenv("$USER");
   
   if(!userName)
       userName="<unknown>";

   // Only works on UNIX...
	  /*
   if( iff_get_directory_delimiter() == "/" )
     {
       filename = tmpnam();
       cmd = strcat("who am i | awk '{print $1}' > ", filename);
       status = iff_system(cmd);
       if( status == 0 )
	 {
	   fd = fopen(filename, "R");
	   if( fd != NULL )
	     {
	       userName = fgets(fd);
	       fclose(fd);
	       remove(filename);
	     }
	 }
     }
     */

   return(userName);
}

//////////////////////////////////////////////////////////////////////////////
//
//  The "design_info" file (formally known as the "status" file) contains
//  information about the status of the design transfer in the
//  "<trans_name>.hpxfer" directory. It contains name/value pairs one per
//  line. The name and value are separated by first "=" character
//  encountered. The "=" is illegal in any name. The name can be made up
//  of any number of alphanumeric, "_" and "." characters. The value can
//  be any number printable ascii character. Leading and trailing white
//  space characters will be removed from the name and value.  Comments
//  are only allowed on lines that begin with the character '#'.
//  
//  The following are the only supported names currently defined. All
//  other name/value pairs are silently ignored.
//  
//  	HPSYSTEM
//  	HPUSER
//  	HPDTC
//  	IFF_LAYOUT
//  	IFF_SCHEMATIC
//  	MDS_SCREEN
//  	IFF_MESSAGE
//  
//  These name/value pairs are defined as follows:
//  
//  	HPSYSTEM = "MDS" | "S4"
//  	HPUSER = <string> | NULL
//  	HPDTC = <year>":"<month>":"<day> <hour>":"<minute>
//  	<month> = <number pair>
//  	<day> = <number pair>
//  	<hour> = <number pair>
//  	<minute> = <number pair>
//  	<year> = <number pair>
//  	<number pair> = [0-9][0-9]
//  
//  	IFF_LAYOUT = <iff object path>
//  	IFF_SCHEMATIC = <iff object path>		
//  
//  	<iff object path> = [<file path> | <collec path> 
//                                              [<collect path>...]]<data path>
//  	<data path> = "/" <name> ":" <data object>
//  	<data object> = "DESIGN" | "ART" | "FORM" | "DOCUMENT"
//  	<file path> = "/" <file name> ":" <file object>
//  	<file object> = "FILE"
//  	<collect path> = "/" <name> ":" <collect object>
//  	<collect object> = "LIBRARY" | "WORKBENCH" | "PARTITION"
//  	<name> = <string>
//  
//  	MDS_SCREEN = <directory path> "/screen.dcs"
//  
//  	IFF_MESSAGE = <string>
//  
//  
//  The name "MDS_SCREEN" will only occur when the name "HPSYSTEM" has a
//  value of "MDS". The name "HPUSER" may have any valid OS login name
//  or none at all if the system does not provide one. The values for the
//  names "IFF_LAYOUT" and "IFF_SCHEMATIC" are the top level schematic and
//  layout object paths for the current design transfer. The case for each
//  string in <data object>, <file object> and <collect object> can be
//  upper, lower, or mixed. The <file name> is the base name of the OS
//  filename. The name "IFF_MESSAGE" is intended to allow user messages to
//  be passed from one tool to another. There may be multiple
//  "IFF_MESSAGE" lines in each transfer and each line will be displayed
//  in the order that they appear in the design_info file.
//  
//  Some example "design_info" entries:
//  
//  	HPSYSTEM = MDS
//  	HPUSER = george
//  	HPDTC = 96:06:20 21:15
//  	IFF_LAYOUT = /cool layout:ART
//  	IFF_LAYOUT = /myProject:WORKBENCH/AnotherLayout:ART
//  	IFF_SCHEMATIC = /myProject:WORKBENCH/topDesign:DESIGN
//  	IFF_SCHEMATIC = /A:PARTITION/b:LIBRARY/c:DESIGN
//  	IFF_SCHEMATIC=/hpeesoflib:WORKBENCH/MyDesign:DESIGN
//  	MDS_SCREEN =/users/baker/screen.dcs
//  	# This is a comment string......
//  	IFF_MESSAGE = This is a single line user message
//  	IFF_MESSAGE = This is a multiline
//  	IFF_MESSAGE = message that has a newline in it..........
//   
//
//////////////////////////////////////////////////////////////////////////////
defun write_mgc_design_info_file(dirName, projName, schName, layName, msg)
{
   decl filename, objPath, fd, userName;
   decl pos, a, b;

   filename = strcat(dirName, "/design_info");

   fd = fopen(filename, "W");
   if( fd == NULL )
     {
       warning("", 0, strcat("Unable open design_info file in ", dirName));
       return;
     }

   fputs(fd, strcat("HPSYSTEM = ", IffToMgcSystemName));

   userName = iff_get_current_user_name();
   fputs(fd, strcat("HPUSER = ", userName));

   fputs(fd, strcat("HPDTC = ", format_date_time("%y:%m:%d %H:%M")));

   objPath = strcat(strcat("/",projName),":file/");
   objPath = strcat(objPath, strcat(schName, ":design"));
   fputs(fd, strcat("IFF_SCHEMATIC = ", objPath));

   objPath = strcat(strcat("/",projName),":file/");
   objPath = strcat(objPath, strcat(layName, ":art"));
   fputs(fd, strcat("IFF_LAYOUT = ", objPath));

   if(( msg != NULL ) && ( strlen(msg) > 0 ))
     {
       pos = index(msg, "\n");
       while( pos != -1 )
	 {
	   a = leftstr(msg, pos);
	   fputs(fd, strcat("IFF_MESSAGE = ", a));
	   msg = rightstr(msg, strlen(msg) - pos - 1);
	   pos = index(msg, "\n");
	 }
       if( strlen(msg) > 0 )
	 fputs(fd, strcat("IFF_MESSAGE = ", msg));
     }
   fclose(fd);
}


//////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////
defun iff_handle_status_cb(input)
{
  input = "";
  return;  
}

//////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////
defun iff_display_status_dialog(logFileName)
{
  decl logFile, line, message, count;

  logFile = fopen(logFileName, "R");
  if(! logFile )
    {
      print_value(strcat("ERROR: Failed to open logfile ", logFileName));
      return;
    }

  message = "";
  line = fgets(logFile); // First line of the data
  while( line != NULL )
    {
      message = strcat(strcat(message, line), "\n");
      line = fgets(logFile);
    }

  fclose(logFile);

  if( message != "" )
    {
      if( IffInteractive == TRUE )
	iff_invoke_text_editor(logFileName);
      else
	fputs(stderr, message);
    }
}

//////////////////////////////////////////////////////////////////////////////
// Write the schematic and layout iff files required for the MGC transfer.
// Also write the design info files.
//////////////////////////////////////////////////////////////////////////////
defun iff_write_mgc_files()
{
  decl logFileName, logFile, cmd, status;
  decl curDesignName, curWinInst, curWinInstId;
  decl layoutCurWinInst, layoutCurWinInstId;

  logFileName = IffExportLogFile;
  logFile = iff_export_open_logfile(logFileName, MGCschIffFileName);

  if( iff_file_exists(MGCschIffFileName) )
    remove(MGCschIffFileName);

  iffOpenWinInst   = NULL;
  iffOpenWinInstId = 0;
  curWinInst    = iff_get_current_window();
  curWinInstId  = iff_get_window_seq_num();
  layoutCurWinInst = curWinInst;
  layoutCurWinInstId = curWinInstId;

  iffOpenWinInst = curWinInst;
  iffOpenWinInstId = curWinInstId;

  curDesignName = iff_current_design_name();

  // TODO check for unsaved designs - return if so

// Get contexts for schematic and layout views. This function is called from a layout window.
    decl layoutContext = de_get_current_design_context();
    decl libName = db_get_library_name(layoutContext);
    decl cellName = db_get_cell_name(layoutContext);
    decl viewName = db_get_view_name(layoutContext);
    decl layoutDesignName = de_format_lib_cell_view_name(libName, cellName, viewName);
    decl schematicDesignName = de_format_lib_cell_view_name(libName, cellName, "schematic");
    decl schematicContext = de_find_design_context_from_name(schematicDesignName);
    if (!schematicContext)
    {
        de_info(strcat("Could not find schematic view to go with ", layoutDesignName));
        return;
    }

if (0)
{
    decl layoutFileName = MGClayIffFileName;
    decl schematicFileName = MGCschIffFileName;

// Write the design info file
    write_mgc_design_info_file(MGCxferDirectory, ProjectName, 
			     TopDesignName, TopDesignName, MGCuserMessage);
// Write the IFF files
    // first the layout view
    decl layoutWinInst = de_show_context_in_new_window(layoutContext);
    api_set_current_window(layoutWinInst);
    iff_main_write(layoutFileName, layoutWinInst, TRUE, FALSE);
    api_set_current_window(layoutWinInst);
    de_close_window();

    // now the schematic - open the context in a window, write the IFF, then close the window
    decl schematicWinInst = de_show_context_in_new_window(schematicContext);
    api_set_current_window(schematicWinInst);
    iff_main_write(schematicFileName, schematicWinInst, TRUE, FALSE);
    api_set_current_window(schematicWinInst);
    de_close_window();

    // back to the layout window
    api_set_current_window(layoutCurWinInst);
}
else
{

    remove(IffExportLogFile);
    iff_log_message(list(strcat("Log file name: ", IffExportLogFile, "\n",
                              TransferTypeName, " translation \n\n",
                              "Output format: Intermediate File Format")));

    iff_log_message(list("Output filename:", MGClayIffFileName));
    write_iff_data(layoutContext, MGClayIffFileName, TRUE, NULL); 

    iff_log_message(list("\n\n*****************************************************************\n\n"));

    iff_log_message(list("Output filename:", MGCschIffFileName));
    write_iff_data(schematicContext, MGCschIffFileName, TRUE, NULL); 


}

// Write the design info file
write_mgc_design_info_file(MGCxferDirectory, ProjectName, 
    TopDesignName, TopDesignName, MGCuserMessage);

  return;
}

//////////////////////////////////////////////////////////////////////////////
// The MGC/PCB transfer was aborted, tell the user and terminate
//////////////////////////////////////////////////////////////////////////////
defun iff_aborted_write_mgc_files()
{
  de_info(fmt_tokens(list(TransferTypeName, "export aborted")), 1);

  iff_export_complete();

  return;
}

//////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////
defun iff_handle_user_message(input)
{
  if( input )
    MGCuserMessage = input;
  else
    MGCuserMessage = " ";

  iff_write_mgc_files();
}

//////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////
defun iff_prompt_for_user_message()
{
  de_data_dialog(fmt_tokens(list(TransferTypeName, "User Message")),
	      MGCuserMessage, 1, NULL, "iff_handle_user_message");
}

//////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////
defun iff_write_mgc_files_with_sch_and_lay_prompt()
{
  decl msg, funcToCall;
  
  if(( MGCpromptForUserMessage == TRUE ) && ( IffInteractive == TRUE ))
    funcToCall = "iff_prompt_for_user_message";
  else
    funcToCall = "iff_write_mgc_files";

  if(( IffInteractive == TRUE ) && ( IffOverwriteFile == FALSE ))
    {
      msg = "OK to overwrite the following files?\n\n'";
      msg = strcat(msg, MGCschIffFileName, "'\n'",MGClayIffFileName, "'");

      question(fmt_tokens(list(TransferTypeName, "Files Exist")), msg, 
	       funcToCall, "iff_aborted_write_mgc_files");
    }
  else
    {
      evaluate(strcat(funcToCall, "()"));
    }
  return;
}

//////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////
defun iff_write_mgc_files_with_sch_prompt()
{
  decl msg, funcToCall;
  
  if(( MGCpromptForUserMessage == TRUE ) && ( IffInteractive == TRUE ))
    funcToCall = "iff_prompt_for_user_message";
  else
    funcToCall = "iff_write_mgc_files";

  if(( IffInteractive == TRUE ) && ( IffOverwriteFile == FALSE ))
    {
      msg = "OK to overwrite the following file?\n\n'";
      msg = strcat(strcat(msg, MGCschIffFileName), "'");
      question(fmt_tokens(list(TransferTypeName, "File Exist")), msg, 
	       funcToCall, "iff_aborted_write_mgc_files");
    }
  else
    {
      evaluate(strcat(funcToCall, "()"));
    }

  return;
}

//////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////
defun iff_write_mgc_files_with_lay_prompt()
{
  decl msg, funcToCall;
  
  if(( MGCpromptForUserMessage == TRUE ) && ( IffInteractive == TRUE ))
    funcToCall = "iff_prompt_for_user_message";
  else
    funcToCall = "iff_write_mgc_files";

  if(( IffInteractive == TRUE ) && ( IffOverwriteFile == FALSE ))
    {
      msg = "OK to overwrite the following file?\n\n'";
      msg = strcat(strcat(msg, MGClayIffFileName), "'");
      question(fmt_tokens(list(TransferTypeName, "File Exist")), msg, 
	       funcToCall, "iff_aborted_write_mgc_files");
    }
  else
    {
      evaluate(strcat(funcToCall, "()"));
    }

  return;
}


//////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////
defun iff_write_mgc()
{
  decl mgcXferDir, schFileName, layFileName, msg;
  decl cmd, schStatus, layStatus, status, a, b;

  TransferTypeName = "MGC/PCB";

  mgcXferDir = iff_check_mgc_dir_structure();
  if( mgcXferDir == NULL )
    {
      iff_aborted_write_mgc_files();
      return;
    }

  schFileName = strcat(mgcXferDir, "/schematic.iff");
  layFileName = strcat(mgcXferDir, "/layout.iff");

  schStatus = iff_file_exists(schFileName);
  layStatus = iff_file_exists(layFileName);

  iff_set_mgc_xfer_info(mgcXferDir, schFileName, layFileName);

  // Force the option file to be read 
  // (needed for user message prompt status)
  read_iff_options(NULL, &a, &b);

  //
  // These calls may prompt the user so do not execute anything
  // after this point that depends on the users response let 
  // the call back do the work.
  //
  if( schStatus && layStatus )
    iff_write_mgc_files_with_sch_and_lay_prompt();
  else if( schStatus )
    iff_write_mgc_files_with_sch_prompt();
  else if( layStatus )
    iff_write_mgc_files_with_lay_prompt();
  else if( MGCpromptForUserMessage )
    iff_prompt_for_user_message();
  else
    iff_write_mgc_files();

  return;
}

//////////////////////////////////////////////////////////////////////////////
//
// A standard directory structure will be used to simplify the design
// transfer to MGC. The structure in Series IV will be fixed under the
// project directory. For MDS the default directory will default to the
// current directory but the user will have control over where this
// directory will be created.
// 
// The directory structure will be:
// 
// 	<top dir>/to_mgc/<trans_name>.hpxfer
// 
//      to_mgc		== This is a fixed directory name and is not
// 			   user modifiable.
//   
// 	"<top dir>"	== This is the project directory. The user
// 			   will not be allowed to change this
// 			   directory. 
// 
// 	"<trans_name>"	== The name of the design object being
// 			   transfered. In SeriesIV the design object
// 			   name is unique so the will not be allowed
// 	                   to change this name.
// 
//  RETURNS:
//          NULL if directory structure could not be verified.
//      FileName if the directory is ok and writable.
// 
//////////////////////////////////////////////////////////////////////////////
defun iff_check_cds_dir_structure()
{
  decl dir, design_name, cmd, status, win, tmpFileName, tmpFile;
  decl dirSep;

  design_name = iff_current_design_name();
  if( design_name == NULL )
    {
      warning("", 0, "No design open to export command aborted.");
      return(NULL);
    }

  //
  // Build the directory structure by calling the OS command mkdir.
  // We ignore the return status and just verify that the we can
  // create a file in the directory when done.
  //
  dirSep = iff_get_directory_delimiter();
  dir = strcat(strcat(iff_get_project_path(), dirSep), "to_cds");
  if( iff_is_dir(dir) == FALSE )
    mkdir(dir);
  dir = strcat(strcat(strcat(dir, dirSep), design_name), ".hpxfer");
  if( iff_is_dir(dir) == FALSE )
    mkdir(dir);

  tmpFileName = strcat(strcat(strcat(dir, dirSep),"."), getpid());
  tmpFile = fopen(tmpFileName, "W");
  if( tmpFile == NULL )
    {
      warning("", 0, strcat("Unable to create files in ", dir));
      return(NULL);
    }

  fclose(tmpFile);
  remove(tmpFileName);

  return(dir);
}

//////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////
defun iff_write_cds()
{
  decl cdsXferDir, schFileName, layFileName, msg;
  decl cmd, schStatus, layStatus, status, a, b;

  TransferTypeName = "Cadence/PCB";

  cdsXferDir = iff_check_cds_dir_structure();
  if( cdsXferDir == NULL )
    {
      iff_aborted_write_mgc_files();
      return;
    }

  schFileName = strcat(cdsXferDir, "/schematic.iff");
  layFileName = strcat(cdsXferDir, "/layout.iff");

  schStatus = iff_file_exists(schFileName);
  layStatus = iff_file_exists(layFileName);

  iff_set_mgc_xfer_info(cdsXferDir, schFileName, layFileName);

  // Force the option file to be read 
  // (needed for user message prompt status)
  read_iff_options(NULL, &a, &b);

  //
  // These calls may prompt the user so do not execute anything
  // after this point that depends on the users response let 
  // the call back do the work.
  //
  if( schStatus && layStatus )
    iff_write_mgc_files_with_sch_and_lay_prompt();
  else if( schStatus )
    iff_write_mgc_files_with_sch_prompt();
  else if( layStatus )
    iff_write_mgc_files_with_lay_prompt();
  else if( MGCpromptForUserMessage )
    iff_prompt_for_user_message();
  else
    iff_write_mgc_files();

  return;
}
